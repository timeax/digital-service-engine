*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L51 -->
<!-- PRODEX_FILE_COUNT: 44 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/workspace/__tests__/provider.test.tsx](#1)  L55-L318
- [src/react/workspace/app.tsx](#2)  L319-L406
- [src/react/workspace/components/canvas.tsx](#3)  L407-L527
- [src/react/workspace/components/context-menu-renderer.tsx](#4)  L528-L733
- [src/react/workspace/components/reactflow/edge.tsx](#5)  L734-L743
- [src/react/workspace/components/reactflow/index.tsx](#6)  L744-L765
- [src/react/workspace/components/reactflow/nodes/comments.tsx](#7)  L766-L775
- [src/react/workspace/components/reactflow/nodes/field.tsx](#8)  L776-L810
- [src/react/workspace/components/reactflow/nodes/node.tsx](#9)  L811-L979
- [src/react/workspace/components/reactflow/nodes/options.tsx](#10)  L980-L998
- [src/react/workspace/components/reactflow/nodes/tags.tsx](#11)  L999-L1021
- [src/react/workspace/context/backend.ts](#12)  L1022-L1582
- [src/react/workspace/context/context.tsx](#13)  L1583-L1894
- [src/react/workspace/context/ctxmenu.tsx](#14)  L1895-L2193
- [src/react/workspace/context/index.tsx](#15)  L2194-L2239
- [src/react/workspace/context/memory/errors.ts](#16)  L2240-L2292
- [src/react/workspace/context/memory/ids.ts](#17)  L2293-L2353
- [src/react/workspace/context/memory/index.ts](#18)  L2354-L2373
- [src/react/workspace/context/memory/memory-backend.ts](#19)  L2374-L3674
- [src/react/workspace/context/memory/seed.ts](#20)  L3675-L3772
- [src/react/workspace/context/memory/store.ts](#21)  L3773-L3898
- [src/react/workspace/context/memory/time.ts](#22)  L3899-L3923
- [src/react/workspace/context/provider/compose/use-branch-cache.ts](#23)  L3924-L4205
- [src/react/workspace/context/provider/compose/use-live-polling.ts](#24)  L4206-L4493
- [src/react/workspace/context/provider/compose/use-workspace-refresh.ts](#25)  L4494-L4713
- [src/react/workspace/context/provider/context.ts](#26)  L4714-L4741
- [src/react/workspace/context/provider/helpers.ts](#27)  L4742-L4852
- [src/react/workspace/context/provider/live/adapters/manual.ts](#28)  L4853-L4862
- [src/react/workspace/context/provider/live/adapters/poll.ts](#29)  L4863-L4943
- [src/react/workspace/context/provider/live/adapters/sse.ts](#30)  L4944-L4953
- [src/react/workspace/context/provider/live/adapters/ws.ts](#31)  L4954-L4963
- [src/react/workspace/context/provider/live/types.ts](#32)  L4964-L5046
- [src/react/workspace/context/provider/provider.tsx](#33)  L5047-L5565
- [src/react/workspace/context/provider/runtime/use-backend-runtime.ts](#34)  L5566-L5613
- [src/react/workspace/context/provider/slices/use-authors-slice.ts](#35)  L5614-L5683
- [src/react/workspace/context/provider/slices/use-branches-slice.ts](#36)  L5684-L5899
- [src/react/workspace/context/provider/slices/use-comments-slice.ts](#37)  L5900-L6349
- [src/react/workspace/context/provider/slices/use-permissions-slice.ts](#38)  L6350-L6427
- [src/react/workspace/context/provider/slices/use-policies-slice.ts](#39)  L6428-L6644
- [src/react/workspace/context/provider/slices/use-services-slice.ts](#40)  L6645-L6721
- [src/react/workspace/context/provider/slices/use-snapshots-slice.ts](#41)  L6722-L7168
- [src/react/workspace/context/provider/slices/use-templates-slice.ts](#42)  L7169-L7408
- [src/react/workspace/context/provider/types.ts](#43)  L7409-L7653
- [src/react/workspace/index.ts](#44)  L7654-L7671
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/workspace/__tests__/provider.test.tsx`  [↑ Back to top](#index)

```tsx
// src/react/workspace/context/provider/__tests__/workspace-provider.integration.test.ts
// @vitest-environment jsdom

import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import * as React from "react";
import { act } from "react";
import { createRoot, type Root } from "react-dom/client";

import { WorkspaceProvider, useWorkspace } from "@/react";
import type { Actor, Branch } from "../context/backend";
import type { WorkspaceAPI } from "@/react";

import { createMemoryWorkspaceBackend } from "../context/memory";

/**
 * React’s act() warnings happen if the test environment doesn’t opt in.
 * This silences: “The current testing environment is not configured to support act(...)”
 */
(
    globalThis as unknown as { IS_REACT_ACT_ENVIRONMENT?: boolean }
).IS_REACT_ACT_ENVIRONMENT = true;

async function flushMicrotasks(): Promise<void> {
    await Promise.resolve();
    await Promise.resolve();
}

function makeActor(): Actor {
    return { id: "actor-1", name: "Tester" };
}

function makeBranch(id: string, isMain: boolean): Branch {
    const iso = new Date(0).toISOString();
    return { id, name: id, isMain, createdAt: iso, updatedAt: iso };
}

describe("WorkspaceProvider (integration)", () => {
    let container: HTMLDivElement;
    let root: Root | null;

    beforeEach(() => {
        container = document.createElement("div");
        document.body.appendChild(container);
        root = createRoot(container);
    });

    afterEach(() => {
        if (root) {
            act(() => root?.unmount());
            root = null;
        }
        container.remove();
        vi.useRealTimers();
        vi.restoreAllMocks();
    });

    it("refresh.all() calls workspace-wide refreshers then current-branch context refreshers (memory backend)", async () => {
        const actor: Actor = makeActor();

        const backend = createMemoryWorkspaceBackend({
            workspaceId: "ws-1",
            actorId: actor.id,
            seed: {
                authors: [{ id: actor.id, name: actor.name ?? "Tester" }],
                branches: [makeBranch("b1", true)],
            },
        });

        // spy on the real backend methods
        const spyAuthorsRefresh = vi.spyOn(backend.authors, "refresh");
        const spyPermissionsRefresh = vi.spyOn(backend.permissions, "refresh");
        const spyBranchesRefresh = vi.spyOn(backend.branches, "refresh");
        const spyServicesRefresh = vi.spyOn(backend.services, "refresh");
        const spyAccessRefreshParticipants = vi.spyOn(
            backend.access,
            "refreshParticipants",
        );
        const spyTemplatesRefresh = vi.spyOn(backend.templates, "refresh");
        const spySnapshotsRefresh = vi.spyOn(backend.snapshots, "refresh");

        let api: WorkspaceAPI | null = null;

        function Capture(): null {
            const ctx: WorkspaceAPI = useWorkspace();
            React.useEffect(() => {
                api = ctx;
            }, [ctx]);
            return null;
        }

        await act(async () => {
            root?.render(
                <WorkspaceProvider
                    backend={backend}
                    actor={actor}
                    autoAutosave={false}
                    initial={{
                        branches: [makeBranch("b1", true)],
                        mainId: "b1",
                        currentBranchId: "b1",
                    }}
                >
                    <Capture />
                </WorkspaceProvider>,
            );
            await flushMicrotasks();
        });

        expect(api).not.toBeNull();

        vi.clearAllMocks();

        await act(async () => {
            await api!.refresh.all({ strict: true });
            await flushMicrotasks();
        });

        const wsId: string = backend.info.id;

        // workspace-wide
        expect(spyAuthorsRefresh).toHaveBeenCalledWith(wsId);
        expect(spyPermissionsRefresh).toHaveBeenCalledWith(wsId, actor);
        expect(spyBranchesRefresh).toHaveBeenCalledWith(wsId);

        // services.refresh(workspaceId, { since? }) — provider may pass a second arg
        expect(spyServicesRefresh).toHaveBeenCalledWith(
            wsId,
            expect.objectContaining({ since: undefined }),
        );

        // branch-local (participants, templates, snapshot pointers for current branch)
        expect(spyAccessRefreshParticipants).toHaveBeenCalledWith(
            wsId,
            "b1",
            expect.anything(),
        );

        expect(spyTemplatesRefresh).toHaveBeenCalledWith(
            expect.objectContaining({
                workspaceId: wsId,
                branchId: "b1",
            }),
        );

        expect(spySnapshotsRefresh).toHaveBeenCalledWith(
            expect.objectContaining({
                workspaceId: wsId,
                branchId: "b1",
                actorId: actor.id,
            }),
        );
    });

    it("refresh.branchContext({ includeWorkspaceData:false }) refreshes only branch-local context (memory backend)", async () => {
        const actor: Actor = makeActor();

        const backend = createMemoryWorkspaceBackend({
            workspaceId: "ws-1",
            actorId: actor.id,
            seed: {
                authors: [{ id: actor.id, name: actor.name ?? "Tester" }],
                branches: [makeBranch("b1", true)],
            },
        });

        const spyAuthorsRefresh = vi.spyOn(backend.authors, "refresh");
        const spyPermissionsRefresh = vi.spyOn(backend.permissions, "refresh");
        const spyServicesRefresh = vi.spyOn(backend.services, "refresh");

        const spyAccessRefreshParticipants = vi.spyOn(
            backend.access,
            "refreshParticipants",
        );
        const spyTemplatesRefresh = vi.spyOn(backend.templates, "refresh");
        const spySnapshotsRefresh = vi.spyOn(backend.snapshots, "refresh");

        let api: WorkspaceAPI | null = null;

        function Capture(): null {
            const ctx: WorkspaceAPI = useWorkspace();
            React.useEffect(() => {
                api = ctx;
            }, [ctx]);
            return null;
        }

        await act(async () => {
            root?.render(
                <WorkspaceProvider
                    backend={backend}
                    actor={actor}
                    autoAutosave={false}
                    initial={{
                        branches: [makeBranch("b1", true)],
                        mainId: "b1",
                        currentBranchId: "b1",
                    }}
                >
                    <Capture />
                </WorkspaceProvider>,
            );
            await flushMicrotasks();
        });

        expect(api).not.toBeNull();

        vi.clearAllMocks();

        await act(async () => {
            await (
                api!.refresh.branchContext as (
                    opts?: Readonly<{
                        branchId?: string;
                        strict?: boolean;
                        includeWorkspaceData?: boolean;
                    }>,
                ) => Promise<unknown>
            )({
                branchId: "b1",
                strict: true,
                includeWorkspaceData: false,
            });
            await flushMicrotasks();
        });

        const wsId: string = backend.info.id;

        // must NOT run workspace-wide refreshers
        expect(spyAuthorsRefresh).not.toHaveBeenCalled();
        expect(spyPermissionsRefresh).not.toHaveBeenCalled();
        expect(spyServicesRefresh).not.toHaveBeenCalled();

        // must run branch-local refreshers
        expect(spyAccessRefreshParticipants).toHaveBeenCalledWith(
            wsId,
            "b1",
            expect.anything(),
        );

        expect(spyTemplatesRefresh).toHaveBeenCalledWith(
            expect.objectContaining({
                workspaceId: wsId,
                branchId: "b1",
            }),
        );

        expect(spySnapshotsRefresh).toHaveBeenCalledWith(
            expect.objectContaining({
                workspaceId: wsId,
                branchId: "b1",
                actorId: actor.id,
            }),
        );
    });
});
```

---
#### 2


` File: src/react/workspace/app.tsx`  [↑ Back to top](#index)

```tsx
// src/react/workspace/app.tsx
import * as React from "react";

import { WorkspaceProvider } from "./context";
import type { WorkspaceProviderProps } from "./context";
import type { Actor, WorkspaceBackend } from "./context/backend";

import type { ToolsConfig } from "../adapters/reactflow";
import { CanvasProvider } from "./context/context";

/**
 * Props for the Workspace wrapper. Mirrors WorkspaceProvider options.
 */
export interface WorkspaceProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    /** Optional pre-hydration to avoid blank first paint */
    readonly initial?: WorkspaceProviderProps["initial"];

    /** Ensure a 'main' branch exists; otherwise first branch is used (default true) */
    readonly ensureMain?: WorkspaceProviderProps["ensureMain"];

    /** Live refresh mode (poll/SSE/WS/off). Defaults to off. */
    readonly live?: WorkspaceProviderProps["live"];

    /** Optional live adapter registry (ws/sse/custom). */
    readonly liveAdapters?: WorkspaceProviderProps["liveAdapters"];

    /** Debounce refresh ticks (WS bursts etc). */
    readonly liveDebounceMs?: WorkspaceProviderProps["liveDebounceMs"];

    /** Autosave debounce window in ms (default 9000) */
    readonly autosaveMs?: WorkspaceProviderProps["autosaveMs"];

    /** Auto-run autosave when dirty (default true) */
    readonly autoAutosave?: WorkspaceProviderProps["autoAutosave"];

    readonly tools?: ToolsConfig;
    readonly children: (tools?: ToolsConfig) => React.ReactNode;
}

/**
 * Workspace: wraps app panels with WorkspaceProvider.
 * Accepts the same inputs as WorkspaceProvider and passes them through.
 */
export function Workspace(props: WorkspaceProps): React.JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain,
        live,
        liveAdapters,
        liveDebounceMs,
        autosaveMs,
        autoAutosave,
        tools,
        children,
    } = props;

    return (
        <WorkspaceProvider
            backend={backend}
            actor={actor}
            initial={initial}
            ensureMain={ensureMain}
            live={live}
            liveAdapters={liveAdapters}
            liveDebounceMs={liveDebounceMs}
            autosaveMs={autosaveMs}
            autoAutosave={autoAutosave}
        >
            <CanvasProvider>{children(tools)}</CanvasProvider>
        </WorkspaceProvider>
    );
}

export default Workspace;
```

---
#### 3


` File: src/react/workspace/components/canvas.tsx`  [↑ Back to top](#index)

```tsx
// src/react/adapters/reactflow/ReactFlowCanvas.tsx
import React, { useMemo, useState } from "react";
import ReactFlow, { Background, ConnectionMode, MiniMap } from "reactflow";
import "reactflow/dist/style.css";

import {
    type AdapterOptions,
    useReactFlowAdapter,
} from "../../adapters/reactflow/adapter";
import type { CanvasAPI } from "@/react";
import { Toolbar } from "../../adapters/reactflow/toolbar";
import type { LabelPlacement, ToolsConfig } from "../../adapters/reactflow";
import { edgeTypes, nodeTypes } from "./reactflow";

export type ReactFlowCanvasProps = {
    api: CanvasAPI;
    options?: AdapterOptions;

    showToolbar?: boolean;
    tools?: ToolsConfig;
    labelPlacement?: LabelPlacement;
    renderTool?: Parameters<typeof Toolbar>[0]["renderButton"];

    initialShowGrid?: boolean;
    initialShowMiniMap?: boolean;

    /** absolute position classes relative to the ReactFlow canvas */
    toolbarPositionClassName?: string; // e.g. "left-2 top-2"
};

export function Canvas({
    api,
    options,
    showToolbar = true,
    tools,
    labelPlacement = "tooltip",
    renderTool,
    initialShowGrid = true,
    initialShowMiniMap = false,
    toolbarPositionClassName = "left-2 top-2",
}: ReactFlowCanvasProps) {
    const [showGrid, setShowGrid] = useState(initialShowGrid);
    const [showMiniMap, setShowMiniMap] = useState(initialShowMiniMap);

    const {
        nodes,
        edges,
        onNodesChange,
        onEdgesChange,
        onConnect,
        onConnectStart,
        onConnectEnd,
        onMoveEnd,
        onSelectionChange,
        isValidConnection,
        snapVector,
    } = useReactFlowAdapter(api, options);

    const snapToGrid = useMemo(
        () => !!options?.snapToGrid,
        [options?.snapToGrid],
    );
    const snapGrid = useMemo<[number, number] | undefined>(
        () => snapVector,
        [snapVector],
    );

    return (
        <div className="relative h-full w-full bg-gray-50">
            <ReactFlow
                nodes={nodes}
                edges={edges}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                connectionMode={ConnectionMode.Loose}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnectStart={onConnectStart}
                onConnectEnd={onConnectEnd}
                onConnect={onConnect}
                onMoveEnd={onMoveEnd}
                onSelectionChange={onSelectionChange}
                isValidConnection={isValidConnection}
                fitView
                snapToGrid={snapToGrid}
                snapGrid={snapGrid}
            >
                {/* toolbar inside ReactFlow so useReactFlow() works */}
                {showToolbar && (
                    <div
                        className={`pointer-events-none absolute z-10 ${toolbarPositionClassName}`}
                    >
                        <Toolbar
                            api={api}
                            mode="dev"
                            showGrid={showGrid}
                            setShowGrid={setShowGrid}
                            showMiniMap={showMiniMap}
                            setShowMiniMap={setShowMiniMap}
                            tools={tools}
                            labelPlacement={labelPlacement}
                            renderButton={renderTool}
                        />
                    </div>
                )}

                {showMiniMap && <MiniMap />}
                {showGrid && <Background />}
            </ReactFlow>
        </div>
    );
}
```

---
#### 4


` File: src/react/workspace/components/context-menu-renderer.tsx`  [↑ Back to top](#index)

```tsx
import type { ContextState, MenuItem } from "@/react/workspace/context/ctxmenu";
import React, {
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState,
} from "react";

/**
 * Pure presentational menu. Mirrors Stitch spec:
 * - 8px+ padding groups with 1px separators
 * - Icons on the left, label, right-aligned hint
 * - Disabled shows muted colors + not-allowed cursor
 * - Danger shows red accents
 */
export const ContextMenuRenderer: React.FC<{
    items: MenuItem[];
    ctx: ContextState;
    onClose: () => void;
    onAction: (item: MenuItem, e: MouseEvent | KeyboardEvent) => void;
}> = ({ items, ctx, onClose, onAction }) => {
    const rootRef = useRef<HTMLDivElement | null>(null);
    const [focusIdx, setFocusIdx] = useState<number>(() =>
        nextFocusable(items, ctx, -1),
    );

    const flat = useMemo(
        () => items, // simple 1-level for now; submenus can extend this
        [items],
    );

    const isDisabled = useCallback(
        (it: MenuItem) =>
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled,
        [ctx],
    );

    const handleActivate = useCallback(
        (it: MenuItem, e: MouseEvent | KeyboardEvent) => {
            if (isDisabled(it) || it.divider || !it.onSelect) return;
            onAction(it, e);
            onClose();
        },
        [isDisabled, onClose, onAction],
    );

    // Keyboard support
    useEffect(() => {
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") {
                e.preventDefault();
                onClose();
                return;
            }
            if (e.key === "ArrowDown") {
                e.preventDefault();
                setFocusIdx((i) => nextFocusable(flat, ctx, i));
                return;
            }
            if (e.key === "ArrowUp") {
                e.preventDefault();
                setFocusIdx((i) => prevFocusable(flat, ctx, i));
                return;
            }
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                const it = flat[focusIdx];
                if (it) handleActivate(it, e);
            }
        };
        document.addEventListener("keydown", onKey, true);
        return () => document.removeEventListener("keydown", onKey, true);
    }, [flat, ctx, focusIdx, handleActivate, onClose]);

    return (
        <div
            ref={rootRef}
            className="w-64 min-w-max rounded-lg border border-slate-200/80 bg-white shadow-xl shadow-slate-950/5 backdrop-blur-sm dark:border-slate-800 dark:bg-slate-900"
            role="menu"
            aria-orientation="vertical"
        >
            <div className="flex flex-col gap-0.5 p-1.5">
                {flat.map((it, idx) => {
                    if (it.divider) {
                        return (
                            <hr
                                key={`div-${idx}`}
                                className="my-1.5 border-t border-slate-200 dark:border-slate-800"
                                aria-hidden
                            />
                        );
                    }

                    const disabled = isDisabled(it);
                    const danger = !!it.danger;
                    const focused = idx === focusIdx;

                    return (
                        <button
                            key={it.key ?? idx}
                            type="button"
                            role="menuitem"
                            aria-disabled={disabled || undefined}
                            onMouseEnter={() => setFocusIdx(idx)}
                            onClick={(e) => {
                                e.preventDefault();
                                if (disabled) return;
                                handleActivate(it, e.nativeEvent);
                            }}
                            className={[
                                "flex min-h-10 w-full items-center justify-between gap-3 rounded-md px-3 text-sm font-medium",
                                disabled
                                    ? "cursor-not-allowed text-slate-400 dark:text-slate-600"
                                    : danger
                                      ? "text-red-600 hover:bg-red-50 hover:text-red-700 dark:text-red-400 dark:hover:bg-red-950/30 dark:hover:text-red-300"
                                      : focused
                                        ? "bg-primary/10 text-slate-900 dark:text-slate-100"
                                        : "text-slate-700 hover:bg-primary/10 dark:text-slate-300",
                            ].join(" ")}
                        >
                            <span className="flex items-center gap-3">
                                {it.icon ?? null}
                                <span className="truncate">{it.label}</span>
                            </span>
                            {it.hint ? (
                                <span className="text-xs text-slate-400 dark:text-slate-500">
                                    {it.hint}
                                </span>
                            ) : (
                                <span />
                            )}
                        </button>
                    );
                })}
            </div>
        </div>
    );
};

/* ───────────────────── Helpers ───────────────────── */

function nextFocusable(
    items: MenuItem[],
    ctx: ContextState,
    from: number,
): number {
    for (let i = from + 1; i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = 0; i <= from && i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}

function prevFocusable(
    items: MenuItem[],
    ctx: ContextState,
    from: number,
): number {
    for (let i = from - 1; i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = items.length - 1; i >= from && i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}
```

---
#### 5


` File: src/react/workspace/components/reactflow/edge.tsx`  [↑ Back to top](#index)

```tsx

```

---
#### 6


` File: src/react/workspace/components/reactflow/index.tsx`  [↑ Back to top](#index)

```tsx
import Tag from "./nodes/tags";
import Field from "./nodes/field";
import Options from "./nodes/options";

const nodeTypes = {
    tag: Tag,
    field: Field,
    option: Options,
};

const edgeTypes = {};

export { nodeTypes, edgeTypes };
```

---
#### 7


` File: src/react/workspace/components/reactflow/nodes/comments.tsx`  [↑ Back to top](#index)

```tsx

```

---
#### 8


` File: src/react/workspace/components/reactflow/nodes/field.tsx`  [↑ Back to top](#index)

```tsx
import Node from "./node";
import React from "react";
import { FlowNode } from "@/schema/graph";

const Field: React.FC<FlowNode> = (props) => {
    const {
        id,
        data: {
            node: { label },
        },
    } = props;
    return (
        <Node label={label} id={id} type={"field"}>
            {(label, icon) => {
                return (
                    <span className="flex gap-2 items-center">
                        {icon}
                        {label}
                    </span>
                );
            }}
        </Node>
    );
};

export default Field;
```

---
#### 9


` File: src/react/workspace/components/reactflow/nodes/node.tsx`  [↑ Back to top](#index)

```tsx
import React, { ReactNode, useEffect, useRef } from "react";
import { LiaTagsSolid } from "react-icons/lia";
import { RxInput } from "react-icons/rx";
import { TbHandClick } from "react-icons/tb";
import { LuTextSelect } from "react-icons/lu";
import { TfiComments } from "react-icons/tfi";
import { Handle, Position } from "reactflow";
import { useCanvasAPI } from "@/react/workspace/context/context";
import { clsx } from "clsx";

interface Errors {
    title?: string;
    description: string;
    meta?: Record<string, unknown>;
}
interface NodeProps {
    children?: (
        label: ReactNode,
        icon: ReactNode,
        errors?: Errors[],
    ) => React.ReactNode;
    description?: string;
    label: string;
    id: string;
    type: "tag" | "field" | "option" | "button" | "comment";
    errors?: Errors[];
    meta?: Record<string, unknown>;
}

function getIcon(
    type: NodeProps["type"],
): React.FC<React.SVGProps<SVGSVGElement>> {
    switch (type) {
        case "tag":
            return LiaTagsSolid;
        case "field":
            return RxInput;
        case "option":
            return LuTextSelect;
        case "button":
            return TbHandClick;
        case "comment":
            return TfiComments;
    }
}
const Node: React.FC<NodeProps> = ({
    children,
    label,
    errors,
    id,
    type,
    description,
}) => {
    const labelRef = useRef<HTMLDivElement>(null);
    const descRef = useRef<HTMLDivElement>(null);
    const { editor } = useCanvasAPI();

    useEffect(() => {
        if (labelRef.current && labelRef.current.innerText !== label) {
            labelRef.current.innerText = label;
        }
        if (
            descRef.current &&
            descRef.current.innerText !== (description ?? "")
        ) {
            descRef.current.innerText = description ?? "";
        }
    }, [label, description]);
    const Icon = getIcon(type);
    const Label = (
        <div
            contentEditable
            suppressContentEditableWarning
            tabIndex={0} // make it focusable
            onPointerDown={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
            onContextMenu={(e) => {
                e.preventDefault(); // prevent default context menu
                labelRef.current?.focus(); // focus the editable div
            }}
            onDoubleClick={(e) => {
                e.stopPropagation();
                labelRef.current?.focus();
            }}
            onBlur={() => {
                const newText = labelRef.current?.innerText.trim() || "";
                if (newText && newText !== label) {
                    editor.reLabel(id, newText);
                }
            }}
            className="text-[12px] outline-none w-full cursor-text text-center"
        >
            {label}
        </div>
    );
    return (
        <div
            className={clsx(
                "px-4 items-center gap-2 relative min-h-[40px] flex h-fit bg-card ring ring-grey-100 rounded-md shadow text-card-foreground font-black",
            )}
        >
            {children ? (
                children(Label, <Icon />, errors)
            ) : (
                <span className={"flex gap-2 items-center"}>
                    <Icon /> {Label}
                </span>
            )}

            <Handle
                id="mid-top"
                type="target"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-top"
                type="source"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />

            {/* mid-bottom: target + source */}
            <Handle
                id="mid-bottom"
                type="target"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-bottom"
                type="source"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
        </div>
    );
};

export default Node;
```

---
#### 10


` File: src/react/workspace/components/reactflow/nodes/options.tsx`  [↑ Back to top](#index)

```tsx
import Node from "./node";
import { NodeProps } from "reactflow";
import { GraphNode } from "@/schema/graph";
import React from "react";

const Options: React.FC<NodeProps<GraphNode>> = ({ id, data: { label } }) => {
    return <Node label={label} id={id} type={"option"} />;
};

export default Options;
```

---
#### 11


` File: src/react/workspace/components/reactflow/nodes/tags.tsx`  [↑ Back to top](#index)

```tsx
import Node from "./node";
import React from "react";
import type { FlowNode } from "@/schema/graph";

const Tag: React.FC<FlowNode> = ({
    id,
    data: {
        node: { label },
    },
}) => {
    return <Node type={"tag"} label={label} id={id} />;
};

export default Tag;
```

---
#### 12


` File: src/react/workspace/context/backend.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend.ts
// Transport-agnostic contracts for the Workspace layer.
// Explicit types only (no implicit any). Result shape: { ok, value | error }.

import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import {
    CommentAnchor,
    CommentMessage,
    CommentThread,
} from "@/schema/comments";
import { DynamicRule } from "@/schema/validation";
import { PolicyDiagnostic } from "@/core/policy";

/* ---------------- core result & identity ---------------- */

export interface BackendError {
    readonly meta?: any;
    readonly code: string;
    readonly message: string;
    readonly status?: number;
    readonly hint?: string;
    readonly cause?: unknown;
}

export type BackendResult<T> =
    | { ok: true; value: T }
    | { ok: false; error: BackendError };

export type Result<T> = Promise<BackendResult<T>>;

export interface Actor {
    readonly id: string;
    readonly name?: string;
    readonly roles?: readonly string[];
    readonly meta?: Readonly<Record<string, unknown>>;
}

/* ---------------- common entities ---------------- */

export interface Author {
    readonly id: string;
    readonly name: string;
    readonly handle?: string;
    readonly avatarUrl?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export type PermissionsMap = Readonly<Record<string, boolean>>;

export interface Branch {
    readonly id: string;
    readonly name: string;
    readonly isMain: boolean;
    readonly headVersionId?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface MergeResult {
    readonly sourceId: string;
    readonly targetId: string;
    readonly conflicts?: number;
    readonly message?: string;
}

/* ---------------- services ---------------- */

export type ServicesInput = readonly DgpServiceCapability[] | DgpServiceMap;

export interface ServicesBackend {
    get(workspaceId: string): Result<ServicesInput>;
    refresh(
        workspaceId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<ServicesInput>;
}

/* ---------------- branch access / participants ---------------- */

export interface BranchParticipant {
    readonly id: string;
    readonly workspaceId: string;
    readonly branchId: string;

    /** points into Authors directory */
    readonly authorId: string;

    /** roles are intentionally loose; host decides taxonomy */
    readonly roles?: readonly string[];

    readonly canRead: boolean;
    readonly canWrite: boolean;

    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export interface BranchAccessBackend {
    listParticipants(
        workspaceId: string,
        branchId: string,
    ): Result<readonly BranchParticipant[]>;
    refreshParticipants(
        workspaceId: string,
        branchId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<readonly BranchParticipant[]>;
}

/* ---------------- snapshots (editor state) ---------------- */

export interface ServiceSnapshot {
    readonly schema_version: string;
    readonly data: EditorSnapshot;
    readonly meta?: Readonly<Record<string, unknown>>;
}

export interface Draft {
    readonly id: string;
    readonly branchId: string;
    readonly status: "uncommitted";
    readonly etag?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface Commit {
    readonly id: string;
    readonly branchId: string;
    readonly message?: string;
    readonly versionId?: string;
    readonly etag?: string;
    readonly createdAt: string;
}

export interface SnapshotsLoadResult {
    readonly head?: Commit;
    readonly draft?: Draft;
    readonly snapshot: ServiceSnapshot;
}

export interface SnapshotsBackend {
    load(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            versionId?: string;
        }>,
    ): Result<SnapshotsLoadResult>;
    autosave(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            clientId?: string;
            since?: number | string;
            etag?: string;
        }>,
    ): Result<Readonly<{ draft: Draft }>>;
    save(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            message?: string;
            draftId?: string;
            etag?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    publish(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
            message?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    discard(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
        }>,
    ): Result<void>;
    refresh(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            since?: number | string;
        }>,
    ): Result<Readonly<{ head?: Commit; draft?: Draft }>>;
}

/* ---------------- templates (replacing "assets") ---------------- */

export interface TemplateValidator {
    readonly type: string; // e.g., "required" | "regex" | "min" | "max" | custom code
    readonly rule?: unknown; // params for the validator
    readonly message?: string;
}

export interface FieldTemplate {
    readonly id: string;
    /** Unique key (per workspace, optionally per branch) used to reference this template */
    readonly key: string;
    readonly name: string;
    /** logical kind e.g. "text", "number", "date", "select", "relation", ... */
    readonly kind: string;

    /** Optional branch scoping (can be global if undefined) */
    readonly branchId?: string;

    /** Canonical, builder-consumable definition (shape up to your app) */
    readonly definition: Readonly<Record<string, unknown>>;

    /** Default values the editor may inject when using this template */
    readonly defaults?: Readonly<Record<string, unknown>>;

    /** UI metadata (icons, color, sizing, render hints, etc.) */
    readonly ui?: Readonly<Record<string, unknown>>;

    /** Client- or server-side validators */
    readonly validators?: readonly TemplateValidator[];

    readonly tags?: readonly string[];
    readonly category?: string;

    /** Published templates are selectable by default in the editor palette */
    readonly published: boolean;

    /** Incremented on every update */
    readonly version: number;

    readonly createdAt: string;
    readonly updatedAt: string;
}

/** Narrow list/search input */
export interface TemplatesListParams {
    readonly workspaceId: string;
    readonly branchId?: string;
    readonly q?: string;
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly since?: string | number;
}

export interface TemplateCreateInput {
    readonly key?: string; // if omitted, backend generates a unique one
    readonly name: string;
    readonly kind: string;
    readonly branchId?: string;
    readonly definition: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>>;
    readonly ui?: Readonly<Record<string, unknown>>;
    readonly validators?: readonly TemplateValidator[];
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly published?: boolean;
}

export interface TemplateUpdatePatch {
    readonly name?: string;
    readonly kind?: string;
    readonly branchId?: string | null;
    readonly definition?: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>> | null;
    readonly ui?: Readonly<Record<string, unknown>> | null;
    readonly validators?: readonly TemplateValidator[] | null;
    readonly tags?: readonly string[] | null;
    readonly category?: string | null;
    readonly published?: boolean;
}

export interface TemplatesBackend {
    list(params: TemplatesListParams): Result<readonly FieldTemplate[]>;
    get(id: string): Result<FieldTemplate | null>;
    getByKey(
        workspaceId: string,
        key: string,
        branchId?: string,
    ): Result<FieldTemplate | null>;
    create(
        workspaceId: string,
        input: TemplateCreateInput,
    ): Result<FieldTemplate>;
    update(id: string, patch: TemplateUpdatePatch): Result<FieldTemplate>;
    clone(
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ): Result<FieldTemplate>;
    publish(id: string): Result<FieldTemplate>;
    unpublish(id: string): Result<FieldTemplate>;
    delete(id: string): Result<void>;
    refresh(
        params: Omit<TemplatesListParams, "q" | "tags" | "category">,
    ): Result<readonly FieldTemplate[]>;
}

/* ---------------- live channel ---------------- */

export type WorkspaceEvent =
    | { type: "authors.updated"; since?: number | string }
    | { type: "permissions.updated" }
    | { type: "services.updated"; since?: number | string }
    | {
          type: "branch.participants.updated";
          branchId: string;
          since?: number | string;
      }
    | { type: "branch.created"; branch: Branch }
    | { type: "branch.deleted"; branchId: string }
    | { type: "branch.setMain"; branchId: string }
    | { type: "branch.merged"; sourceId: string; targetId: string }
    | { type: "template.created"; template: FieldTemplate }
    | { type: "template.updated"; template: FieldTemplate }
    | { type: "template.deleted"; templateId: string }
    | { type: "snapshot.autosaved"; branchId: string; draft: Draft }
    | { type: "snapshot.saved"; branchId: string; commit: Commit }
    | { type: "snapshot.published"; branchId: string; commit: Commit }
    | { type: "snapshot.discarded"; branchId: string }
    | { type: "policies.updated"; since?: number | string; branchId?: string };

export type LiveOptions =
    | { mode: "off" }
    | { mode: "poll"; intervalMs?: number }
    | { mode: "sse"; url: string; headers?: Readonly<Record<string, string>> }
    | { mode: "ws"; url: string; protocols?: readonly string[] };

/* ---------------- authors / permissions / branches ---------------- */

export interface AuthorsBackend {
    list(workspaceId: string): Result<readonly Author[]>;
    get(authorId: string): Result<Author | null>;
    refresh(workspaceId: string): Result<readonly Author[]>;
}

export interface PermissionsBackend {
    get(workspaceId: string, actor: Actor): Result<PermissionsMap>;
    refresh(workspaceId: string, actor: Actor): Result<PermissionsMap>;
}

export interface BranchesBackend {
    list(workspaceId: string): Result<readonly Branch[]>;
    create(
        workspaceId: string,
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ): Result<Branch>;
    setMain(workspaceId: string, branchId: string): Result<Branch>;
    merge(
        workspaceId: string,
        sourceId: string,
        targetId: string,
    ): Result<MergeResult>;
    delete(workspaceId: string, branchId: string): Result<void>;
    refresh(workspaceId: string): Result<readonly Branch[]>;
}

/* ---------------- workspace backend root ---------------- */

export interface WorkspaceInfo {
    readonly id: string;
    readonly name: string;
    readonly description?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
    readonly meta?: Readonly<Record<string, unknown>>;
}

/**
 * Shared request scope for host backends (workspace + optional branch + optional actor).
 * This is intentionally transport-agnostic and minimal so other layers (e.g. canvas/comments)
 * can reuse it without redefining identity types.
 */
export interface BackendScope {
    readonly workspaceId: string;
    readonly actorId: string;
    readonly branchId: string;
}

/**
 * Generic canvas comments backend contract.
 *
 * We keep this in workspace backend so HOSTS have a single place to implement
 * transport-agnostic interfaces.
 *
 * The canvas module can “bind” these generics to its concrete types.
 */
export interface CommentsBackend<
    ThreadDTO = unknown,
    MessageDTO = unknown,
    AnchorDTO = unknown,
> {
    listThreads(ctx: BackendScope): Result<readonly ThreadDTO[]>;

    createThread(
        ctx: BackendScope,
        input: {
            anchor: AnchorDTO;
            body: string;
            meta?: Record<string, unknown>;
        },
    ): Result<ThreadDTO>;

    addMessage(
        ctx: BackendScope,
        input: {
            threadId: string;
            body: string;
            meta?: Record<string, unknown>;
        },
    ): Result<MessageDTO>;

    editMessage(
        ctx: BackendScope,
        input: {
            threadId: string;
            messageId: string;
            body: string;
        },
    ): Result<MessageDTO>;

    deleteMessage(
        ctx: BackendScope,
        input: {
            threadId: string;
            messageId: string;
        },
    ): Result<void>;

    moveThread(
        ctx: BackendScope,
        input: {
            threadId: string;
            anchor: AnchorDTO;
        },
    ): Result<ThreadDTO>;

    resolveThread(
        ctx: BackendScope,
        input: {
            threadId: string;
            resolved: boolean;
        },
    ): Result<ThreadDTO>;

    deleteThread(
        ctx: BackendScope,
        input: {
            threadId: string;
        },
    ): Result<void>;
}

/* ---------------- policies (dynamic rules) ---------------- */

/**
 * Policies are stored as raw JSON for round-tripping (comments/formatting, etc.),
 * and compiled into DynamicRule[] for runtime validation.
 *
 * Scope rules:
 * - If branchId is provided -> branch-scoped policies
 * - If branchId is omitted  -> workspace-scoped policies
 */
export interface PolicyScope extends BackendScope {}

export interface PoliciesLoadResult {
    /** the raw JSON the host stored (authoring format) */
    readonly raw: unknown;

    /** optional precompiled rules (host may compile server-side) */
    readonly compiled?: readonly DynamicRule[];

    /** optional diagnostics (host may compile server-side) */
    readonly diagnostics?: readonly PolicyDiagnostic[];

    readonly updatedAt?: string;
    readonly etag?: string;
}

/**
 * Transport contract for policy storage/compilation.
 *
 * - UI can compile locally via compilePolicies()
 * - Host can also compile/validate server-side by implementing compile()
 */
export interface PoliciesBackend {
    load(ctx: PolicyScope): Result<PoliciesLoadResult | null>;

    save(
        ctx: PolicyScope,
        input: Readonly<{
            raw: unknown;
            etag?: string;
        }>,
    ): Result<Readonly<{ updatedAt?: string; etag?: string }>>;

    /** Optional server-side compile/validate (for shared editing / enforcement). */
    compile?(
        ctx: PolicyScope,
        input: Readonly<{ raw: unknown }>,
    ): Result<
        Readonly<{
            policies: readonly DynamicRule[];
            diagnostics: readonly PolicyDiagnostic[];
        }>
    >;

    /** Optional: reset/delete policies at scope (branch or workspace). */
    clear?(ctx: PolicyScope): Result<Readonly<{ updatedAt?: string }>>;
}

export interface WorkspaceBackend {
    readonly info: WorkspaceInfo;

    readonly authors: AuthorsBackend;
    readonly permissions: PermissionsBackend;
    readonly branches: BranchesBackend;

    /** branch-scoped access control / participants */
    readonly access: BranchAccessBackend;

    /** first-class services channel */
    readonly services: ServicesBackend;

    readonly templates: TemplatesBackend;
    readonly snapshots: SnapshotsBackend;

    /** dynamic policies: workspace-scoped and/or branch-scoped rules */
    readonly policies: PoliciesBackend;

    readonly comments: CommentsBackend<
        CommentThread,
        CommentMessage,
        CommentAnchor
    >;
}
```

---
#### 13


` File: src/react/workspace/context/context.tsx`  [↑ Back to top](#index)

```tsx
import React, {
    createContext,
    useContext,
    useEffect,
    useMemo,
    useRef,
    type ReactNode,
} from "react";
import { CanvasAPI } from "@/react";
import { Builder, BuilderOptions, createBuilder } from "@/core";
import type { CanvasOptions } from "@/schema/canvas-types";
import type { CanvasBackendOptions } from "../../canvas/backend";
import type { ServiceProps } from "@/schema";
import { useWorkspaceMaybe } from ".";

/* ───────────────────────── context ───────────────────────── */

const Ctx = createContext<CanvasAPI | null>(null);

/** Managed props (back-compat): host provides the API instance. */
type CanvasProviderManagedProps = { api: CanvasAPI; children: ReactNode };

/** Workspace-aware props: host omits `api`, we attach to Workspace on demand. */
type CanvasProviderWorkspaceProps = {
    children: ReactNode;
    /** Optional Builder options (e.g., historyLimit, serviceMap if you already have one). */
    builderOpts?: BuilderOptions;
    /** Canvas view/backend options for CanvasAPI ctor. */
    canvasOpts?: CanvasOptions & CanvasBackendOptions;
    /** If false, we won’t attempt to read Workspace; will throw if no api is provided. */
    attachToWorkspace?: boolean; // default true
};

type CanvasProviderProps =
    | CanvasProviderManagedProps
    | CanvasProviderWorkspaceProps;

/**
 * CanvasProvider
 * - Managed mode (existing): <CanvasProvider api={api}>{...}</CanvasProvider>
 * - Workspace-aware mode (new): if no `api` and inside a Workspace, auto-create Builder+CanvasAPI and load snapshot props.
 */
export function CanvasProvider(props: CanvasProviderProps) {
    // Managed mode: unchanged behavior
    if ("api" in props) {
        return <Ctx.Provider value={props.api}>{props.children}</Ctx.Provider>;
    }

    // Workspace-aware mode
    const {
        children,
        builderOpts,
        canvasOpts,
        attachToWorkspace = true,
    } = props;

    const ws = useWorkspaceMaybe();

    if (!attachToWorkspace || !ws) {
        throw new Error(
            "CanvasProvider: no `api` provided and no Workspace context available. " +
                "Either pass an `api` prop or render within <WorkspaceProvider>.",
        );
    }

    // 🔹 NEW: if snapshot props aren’t loaded yet, trigger a one-time load
    const triedInitialLoadRef = useRef<boolean>(false);
    useEffect(() => {
        const hasProps = Boolean(ws.snapshot.data?.props);
        if (!hasProps && !triedInitialLoadRef.current) {
            triedInitialLoadRef.current = true;
            void ws.snapshot.load().then((res) => {
                // dev-only noise; stay silent in prod
                if (
                    typeof window !== "undefined" &&
                    // @ts-expect-error allow host env guard
                    window.SITE?.env !== "production"
                ) {
                    if (!res.ok) {
                        // eslint-disable-next-line no-console
                        console.warn(
                            "[CanvasProvider] snapshot.load() failed:",
                            res.error?.code ?? "load_error",
                            res.error?.message ?? "(no message)",
                        );
                    }
                }
            });
        }
    }, [ws]);

    // Pull initial ServiceProps from current editor snapshot (if present)
    const initialProps: ServiceProps | undefined = ws.snapshot.data?.props as
        | ServiceProps
        | undefined;

    // If the Workspace exposes services as a map, we can forward it to builderOpts.
    // (We avoid any normalization here; arrays are ignored by design.)
    const resolvedBuilderOpts: BuilderOptions | undefined = useMemo(() => {
        const svc = ws.services.data as unknown;
        const hasMap =
            svc != null &&
            typeof svc === "object" &&
            !Array.isArray(svc as unknown[]);
        return hasMap
            ? {
                  ...(builderOpts ?? {}),
                  serviceMap: svc as BuilderOptions["serviceMap"],
              }
            : builderOpts;
    }, [builderOpts, ws.services.data]);

    const { api } = useCanvasOwned(
        initialProps,
        canvasOpts,
        resolvedBuilderOpts,
    );

    return <Ctx.Provider value={api}>{children}</Ctx.Provider>;
}

export function useCanvasAPI(): CanvasAPI {
    const api = useContext(Ctx);
    if (!api)
        throw new Error("useCanvasAPI must be used within <CanvasProvider>");
    return api;
}

/**
 * Create & memoize a CanvasAPI from a Builder.
 * - Disposes the previous API when builder changes.
 * - Accepts both view/state options and backend options.
 * - Warns (DEV only) if `opts` identity is changing every render.
 */
export function useCanvasFromBuilder(
    builder: Builder,
    opts?: CanvasOptions & CanvasBackendOptions,
): CanvasAPI {
    // Warn (DEV) if the raw opts reference is churning each render
    useDevWarnOnOptsChurn(opts);

    // Stabilize opts content to avoid churn-driven re-instantiation
    const lastOptsRef = useRef<
        (CanvasOptions & CanvasBackendOptions) | undefined
    >(undefined);
    const stableOpts =
        opts &&
        lastOptsRef.current &&
        shallowEqualOpts(lastOptsRef.current, opts)
            ? lastOptsRef.current
            : (lastOptsRef.current = opts);

    const api = useMemo(
        () => new CanvasAPI(builder, stableOpts),
        [builder, stableOpts],
    );

    useEffect(() => {
        return () => {
            // Clean up listeners / timers when API instance is replaced or unmounted
            api.dispose?.();
        };
    }, [api]);

    return api;
}

/**
 * Use an existing CanvasAPI instance without creating/disposing anything.
 * Useful when the host fully manages the API lifecycle (e.g., from a parent).
 */
export function useCanvasFromExisting(api: CanvasAPI): CanvasAPI {
    // No disposal here—the host owns the instance
    return api;
}

/* ───────────────────────── helpers ───────────────────────── */

function shallowEqualOpts(
    a?: CanvasOptions & CanvasBackendOptions,
    b?: CanvasOptions & CanvasBackendOptions,
) {
    if (a === b) return true;
    if (!a || !b) return false;
    const aKeys = Object.keys(a) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    const bKeys = Object.keys(b) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    if (aKeys.length !== bKeys.length) return false;
    for (const k of aKeys) {
        if ((a as any)[k] !== (b as any)[k]) return false;
    }
    return true;
}

/** DEV-only: warn if opts identity changes on most renders (suggests wrapping in useMemo). */
function useDevWarnOnOptsChurn(opts?: CanvasOptions & CanvasBackendOptions) {
    const rawRef = useRef<typeof opts>(undefined);
    const churnCountRef = useRef(0);
    const lastWindowStartRef = useRef<number>(Date.now());
    const warnedRef = useRef(false);

    useEffect(() => {
        // @ts-ignore
        if (window.SITE?.env === "production") return;
        const now = Date.now();

        // Reset window every 2s
        if (now - lastWindowStartRef.current > 2000) {
            lastWindowStartRef.current = now;
            churnCountRef.current = 0;
        }

        if (rawRef.current !== opts) {
            churnCountRef.current += 1;
            rawRef.current = opts;
        }

        // If we see churn on most renders in the window, warn once.
        if (!warnedRef.current && churnCountRef.current >= 5) {
            warnedRef.current = true;
            // eslint-disable-next-line no-console
            console.warn(
                "[digital-service-ui-builder] useCanvasFromBuilder: `opts` is changing identity frequently. " +
                    "Wrap your options in useMemo to avoid unnecessary API re-instantiation.",
            );
        }
    });
}

type UseCanvasOwnedReturn = { api: CanvasAPI; builder: Builder };

/** Creates a Builder once, loads initial props, and owns the CanvasAPI lifecycle. */
export function useCanvasOwned(
    initialProps?: ServiceProps,
    canvasOpts?: CanvasOptions & CanvasBackendOptions,
    builderOpts?: BuilderOptions, // ← pass builder params here
): UseCanvasOwnedReturn {
    // 1) Create the builder ONCE with the provided builder options
    const builderRef = useRef<Builder>();
    const builderOptsRef = useRef<BuilderOptions | undefined>(builderOpts);
    const loadedOnceRef = useRef<boolean>(false);

    if (!builderRef.current) {
        builderRef.current = createBuilder(builderOptsRef.current); // ← forwarded
        if (initialProps) {
            builderRef.current.load(initialProps);
            loadedOnceRef.current = true;
        }
        // @ts-ignore
    } else if (window.SITE?.env !== "production") {
        // Warn if builderOpts identity changes after first mount (they won't be applied)
        if (builderOptsRef.current !== builderOpts) {
            // eslint-disable-next-line no-console
            console.warn(
                "[useCanvasOwned] builderOpts changed after init; new values are ignored. " +
                    "If you need to recreate the builder, remount the hook (e.g. change a React key).",
            );
            builderOptsRef.current = builderOpts;
        }
    }
    const builder = builderRef.current!;

    // If initial props arrive later (async Workspace load), load them once.
    useEffect(() => {
        if (!loadedOnceRef.current && initialProps) {
            builderRef.current!.load(initialProps);
            loadedOnceRef.current = true;
        }
    }, [initialProps]);

    // 2) Stabilize canvas options to avoid churn re-instantiation of CanvasAPI
    const lastCanvasOptsRef = useRef<typeof canvasOpts>();
    const stableCanvasOpts = useMemo(() => {
        if (!lastCanvasOptsRef.current) {
            lastCanvasOptsRef.current = canvasOpts;
            return canvasOpts;
        }
        const a = canvasOpts ?? {};
        const b = lastCanvasOptsRef.current ?? {};
        const same = Object.keys({ ...a, ...b }).every(
            (k) => (a as any)[k] === (b as any)[k],
        );
        if (same) return lastCanvasOptsRef.current;
        lastCanvasOptsRef.current = canvasOpts;
        return canvasOpts;
    }, [canvasOpts]);

    // 3) Create CanvasAPI and dispose on change/unmount
    const api = useMemo(
        () => new CanvasAPI(builder, stableCanvasOpts),
        [builder, stableCanvasOpts],
    );

    useEffect(
        () => () => {
            api.dispose?.();
        },
        [api],
    );

    return { api, builder };
}
```

---
#### 14


` File: src/react/workspace/context/ctxmenu.tsx`  [↑ Back to top](#index)

```tsx
import { ContextMenuRenderer } from "@/react/workspace/components/context-menu-renderer";
import React, {
    createContext,
    useCallback,
    useContext,
    useEffect,
    useLayoutEffect,
    useMemo,
    useRef,
    useState,
} from "react";
import { createPortal } from "react-dom";
import { CanvasAPI } from "@/react";

/* ───────────────────── Types ───────────────────── */

export type ContextScope =
    | "file"
    | "folder"
    | "library"
    | "empty"
    | (string & {});

export type ContextState = CtxWithAttach;

// Allow attaching UI-scoped helpers (e.g., Sidebar startAdd)
type CtxWithAttach = CanvasAPI;
export interface MenuItem {
    key?: React.Key;
    label?: string;
    icon?: React.ReactNode;
    hint?: string;
    divider?: boolean;
    danger?: boolean;
    disabled?: boolean | ((ctx: CtxWithAttach) => boolean);
    onSelect?: (args: {
        ctx: CtxWithAttach;
        nativeEvent: MouseEvent | KeyboardEvent;
    }) => void | Promise<void>;
    children?: MenuItem[];
}

interface InternalState {
    open: boolean;
    x: number;
    y: number;
    items: MenuItem[];
    ariaLabel?: string;
    ctx: CtxWithAttach;
}

export type MenuBuilder =
    | MenuItem[]
    | ((opts: {
          ctx: ContextState;
          nativeEvent?: MouseEvent;
      }) => MenuItem[] | Promise<MenuItem[]>);

export interface OpenOptions {
    /** A11y label for the menu. */
    ariaLabel?: string;
    /** Context state used by disabled predicates & callbacks. */
    ctx?: ContextState;
    /** If you already have precise coords, pass them. Otherwise we’ll use the event’s clientX/Y. */
    coords?: { x: number; y: number };
    /** Native event (if any). */
    nativeEvent?: MouseEvent;
}

export interface ContextMenuApi {
    openAt: (
        evOrCoords: MouseEvent | { x: number; y: number },
        items: MenuBuilder,
        options?: OpenOptions,
    ) => void;
    close: () => void;
    /** Ergonomic helper for `onContextMenu={cm.bind(() => items, { ctx: ... })}` */
    bind: (
        builder: (ev: React.MouseEvent) => MenuBuilder | Promise<MenuBuilder>,
        options?: Omit<OpenOptions, "nativeEvent" | "coords">,
    ) => (ev: React.MouseEvent) => void;
}

/* ───────────────────── Context ───────────────────── */

const Ctx = createContext<ContextMenuApi | null>(null);

export const useContextMenu = (): ContextMenuApi => {
    const api = useContext(Ctx);
    if (!api) {
        throw new Error(
            "useContextMenu() must be used under <ContextMenuProvider>.",
        );
    }
    return api;
};

/* ───────────────────── Provider ───────────────────── */

export const Ctxmenu: React.FC<{
    children: React.ReactNode;
    zIndex?: number;
}> = ({
    children,
    zIndex = 60, // sits above most app chrome; tweak if needed
}) => {
    const containerRef = useRef<HTMLDivElement | null>(null);

    const [state, setState] = useState<InternalState>({
        open: false,
        x: 0,
        y: 0,
        items: [],
        ariaLabel: "Context menu",
        //@ts-expect-error
        ctx: {},
    });

    const [measured, setMeasured] = useState<{ w: number; h: number }>({
        w: 0,
        h: 0,
    });

    // Close on outside click / ESC
    useEffect(() => {
        if (!state.open) return;

        const onDown = (e: MouseEvent) => {
            const el = containerRef.current;
            if (el && !el.contains(e.target as Node)) {
                setState((s) => ({ ...s, open: false }));
            }
        };
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") {
                setState((s) => ({ ...s, open: false }));
            }
        };

        document.addEventListener("mousedown", onDown, true);
        document.addEventListener("keydown", onKey, true);
        return () => {
            document.removeEventListener("mousedown", onDown, true);
            document.removeEventListener("keydown", onKey, true);
        };
    }, [state.open]);

    // Clamp menu within viewport after render
    useLayoutEffect(() => {
        if (!state.open) return;
        const el = containerRef.current;
        if (!el) return;

        const rect = el.getBoundingClientRect();
        if (rect.width !== measured.w || rect.height !== measured.h) {
            setMeasured({ w: rect.width, h: rect.height });
        }

        const margin = 8;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let nx = state.x;
        let ny = state.y;

        if (nx + rect.width + margin > vw)
            nx = Math.max(margin, vw - rect.width - margin);
        if (ny + rect.height + margin > vh)
            ny = Math.max(margin, vh - rect.height - margin);

        if (nx !== state.x || ny !== state.y) {
            setState((s) => ({ ...s, x: nx, y: ny }));
        }
    }, [state.open, state.x, state.y, measured.w, measured.h]);

    const resolveItems = useCallback(
        async (items: MenuBuilder, opts: OpenOptions): Promise<MenuItem[]> => {
            let raw: MenuItem[] | Promise<MenuItem[]>;
            if (typeof items === "function") {
                raw = items({
                    //@ts-expect-error
                    ctx: opts.ctx ?? {},
                    nativeEvent: opts.nativeEvent,
                });
            } else {
                raw = items;
            }
            const resolved = await raw;
            return Array.isArray(resolved) ? resolved : [];
        },
        [],
    );

    const openAt = useCallback<ContextMenuApi["openAt"]>(
        async (evOrCoords, items, options) => {
            const nativeEvent =
                "x" in evOrCoords
                    ? options?.nativeEvent
                    : (evOrCoords as MouseEvent);
            const coords =
                "x" in evOrCoords
                    ? evOrCoords
                    : {
                          x: (evOrCoords as MouseEvent).clientX,
                          y: (evOrCoords as MouseEvent).clientY,
                      };

            if (
                !("x" in evOrCoords) &&
                (evOrCoords as MouseEvent).preventDefault
            ) {
                (evOrCoords as MouseEvent).preventDefault();
            }

            const resolved = await resolveItems(items, {
                ...(options ?? {}),
                nativeEvent,
            });
            setState({
                open: true,
                x: coords.x,
                y: coords.y,
                items: resolved,
                ariaLabel: options?.ariaLabel ?? "Context menu",
                //@ts-expect-error
                ctx: options?.ctx ?? {},
            });
        },
        [resolveItems],
    );

    const close = useCallback(
        () => setState((s) => ({ ...s, open: false })),
        [],
    );

    const bind = useCallback<ContextMenuApi["bind"]>(
        (builder, options) => {
            return (ev: React.MouseEvent) => {
                ev.preventDefault();
                const native: MouseEvent = ev.nativeEvent;
                const maybePromise = builder(ev);
                Promise.resolve(maybePromise).then((items) => {
                    openAt(
                        { x: native.clientX, y: native.clientY },
                        // If builder returned a function or array, pass through; openAt will resolve again safely.
                        typeof items === "function" || Array.isArray(items)
                            ? (items as MenuBuilder)
                            : [],
                        { ...(options ?? {}), nativeEvent: native },
                    );
                });
            };
        },
        [openAt],
    );

    const api = useMemo<ContextMenuApi>(
        () => ({ openAt, close, bind }),
        [openAt, close, bind],
    );

    return (
        <Ctx.Provider value={api}>
            {children}
            {state.open &&
                createPortal(
                    <div
                        ref={containerRef}
                        className="fixed z-[9999]"
                        style={{ left: state.x, top: state.y, zIndex }}
                        role="dialog"
                        aria-label={state.ariaLabel}
                    >
                        <ContextMenuRenderer
                            items={state.items}
                            ctx={state.ctx}
                            onClose={close}
                            onAction={(it, e) =>
                                it.onSelect?.({
                                    ctx: state.ctx,
                                    nativeEvent: e,
                                })
                            }
                        />
                    </div>,
                    document.body,
                )}
        </Ctx.Provider>
    );
};
```

---
#### 15


` File: src/react/workspace/context/index.tsx`  [↑ Back to top](#index)

```tsx
// src/react/workspace/context/index.ts

export {
    WorkspaceContext,
    useWorkspace,
    useWorkspaceMaybe,
} from "./provider/context";

export { WorkspaceProvider } from "./provider/provider";

export type {
    WorkspaceAPI,
    WorkspaceProviderProps,
    Loadable,
    SnapshotSlice,
    BranchesSlice,
} from "./provider/types";

/**
 * Live adapter contracts — exposed so the host can implement custom adapters
 * (Echo, native WebSocket, SSE, custom protocols).
 */
export type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterRegistry,
    WorkspaceLiveAdapterHandlers,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "./provider/live/types";

/**
 * Default poll adapter — hosts may use this or provide their own ws/sse adapters.
 */
export { createPollAdapter } from "./provider/live/adapters/poll";

export * from "./memory";
```

---
#### 16


` File: src/react/workspace/context/memory/errors.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/errors.ts

import type { BackendError, BackendResult } from "../backend";

export function ok<T>(value: T): BackendResult<T> {
    return { ok: true, value };
}

export function fail<T = never>(
    code: string,
    message: string,
    opts?: Readonly<{
        status?: number;
        hint?: string;
        meta?: unknown;
        cause?: unknown;
    }>,
): BackendResult<T> {
    const err: BackendError = {
        code,
        message,
        status: opts?.status,
        hint: opts?.hint,
        meta: opts?.meta as any,
        cause: opts?.cause,
    };
    return { ok: false, error: err };
}

export function asError(e: unknown): BackendError {
    if (
        typeof e === "object" &&
        e !== null &&
        "code" in (e as Record<string, unknown>) &&
        "message" in (e as Record<string, unknown>)
    ) {
        return e as BackendError;
    }
    return {
        code: "unknown_error",
        message: String(e ?? "Unknown error"),
        meta: e as any,
    };
}
```

---
#### 17


` File: src/react/workspace/context/memory/ids.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/ids.ts

let __seq: number = 0;

function nextSeq(): number {
    __seq += 1;
    return __seq;
}

export function newId(prefix: string): string {
    // stable-enough for memory usage; predictable in tests if you reset module state
    const t: string = Date.now().toString(36);
    const s: string = nextSeq().toString(36);
    return `${prefix}_${t}_${s}`;
}

export function newBranchId(): string {
    return newId("br");
}

export function newAuthorId(): string {
    return newId("au");
}

export function newTemplateId(): string {
    return newId("tpl");
}

export function newTemplateKey(): string {
    return `tpl_${Date.now().toString(36)}_${nextSeq().toString(36)}`;
}

export function newDraftId(): string {
    return newId("dr");
}

export function newCommitId(): string {
    return newId("cm");
}

export function newThreadId(): string {
    return newId("th");
}

export function newMessageId(): string {
    return newId("msg");
}

export function bumpEtag(prev?: string): string {
    const n: number = (prev ? parseInt(prev, 10) : 0) + 1;
    return String(Number.isFinite(n) ? n : 1);
}
```

---
#### 18


` File: src/react/workspace/context/memory/index.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/index.ts

export { createMemoryWorkspaceBackend } from "./memory-backend";

export type {
    CreateMemoryWorkspaceBackendOptions,
    MemoryBackendSeed,
    MemorySeedBranchSnapshots,
    MemorySeedComments,
    MemorySeedParticipants,
} from "./seed";
```

---
#### 19


` File: src/react/workspace/context/memory/memory-backend.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/memory-backend.ts

import type {
    Actor,
    Author,
    AuthorsBackend,
    BackendScope,
    Branch,
    BranchAccessBackend,
    BranchParticipant,
    BranchesBackend,
    CommentsBackend,
    Commit,
    Draft,
    FieldTemplate,
    PoliciesBackend,
    PoliciesLoadResult,
    PolicyScope,
    ServiceSnapshot,
    ServicesBackend,
    ServicesInput,
    SnapshotsBackend,
    SnapshotsLoadResult,
    TemplatesBackend,
    TemplatesListParams,
    TemplateCreateInput,
    TemplateUpdatePatch,
    WorkspaceBackend,
    WorkspaceInfo,
    PermissionsBackend,
    PermissionsMap,
    MergeResult,
} from "../backend";

import type {
    CommentAnchor,
    CommentId,
    CommentMessage,
    CommentThread,
    ThreadId,
} from "@/schema/comments";

import {
    bumpEtag,
    newBranchId,
    newCommitId,
    newDraftId,
    newMessageId,
    newTemplateId,
    newTemplateKey,
    newThreadId,
} from "./ids";
import { ok, fail } from "./errors";
import { isoNow } from "./time";
import type {
    CreateMemoryWorkspaceBackendOptions,
    MemoryBackendSeed,
} from "./seed";
import {
    ensureThread,
    findMessageIndex,
    newBranchSnapshotState,
    newCommentsBranchState,
    type MemoryWorkspaceStore,
} from "./store";

function emptySnapshot(): ServiceSnapshot {
    // EditorSnapshot shape is host-defined; keep memory backend generic.
    return {
        schema_version: "1",
        data: {} as unknown as any,
    };
}

function permissivePermissions(): PermissionsMap {
    const handler: ProxyHandler<Record<string, boolean>> = {
        get: (
            _target: Record<string, boolean>,
            prop: string | symbol,
        ): boolean => {
            if (typeof prop === "symbol") return true;
            return true;
        },
        has: (): boolean => true,
        ownKeys: (): ArrayLike<string | symbol> => [],
        getOwnPropertyDescriptor: (): PropertyDescriptor | undefined =>
            undefined,
    };

    const p: PermissionsMap = new Proxy<Record<string, boolean>>(
        {},
        handler,
    ) as unknown as PermissionsMap;
    return p;
}

function normalizeInfo(
    workspaceId: string,
    seed?: Partial<WorkspaceInfo>,
): WorkspaceInfo {
    return {
        id: seed?.id ?? workspaceId,
        name: seed?.name ?? "Memory Workspace",
        description: seed?.description,
        createdAt: seed?.createdAt ?? isoNow(),
        updatedAt: seed?.updatedAt ?? isoNow(),
        meta: seed?.meta,
    };
}

function normalizeBranch(
    input: Partial<Branch> & Pick<Branch, "id" | "name">,
): Branch {
    const createdAt: string = input.createdAt ?? isoNow();
    const updatedAt: string = input.updatedAt ?? createdAt;

    return {
        id: input.id,
        name: input.name,
        isMain: Boolean(input.isMain),
        headVersionId: input.headVersionId,
        createdAt,
        updatedAt,
    };
}

function normalizeAuthor(
    input: Partial<Author> & Pick<Author, "id" | "name">,
): Author {
    return {
        id: input.id,
        name: input.name,
        handle: input.handle,
        avatarUrl: input.avatarUrl,
        meta: input.meta,
        createdAt: input.createdAt ?? isoNow(),
        updatedAt: input.updatedAt ?? isoNow(),
    };
}

function normalizeTemplate(input: any): FieldTemplate {
    const now: string = isoNow();

    const id: string = String(input?.id ?? newTemplateId());
    const key: string = String(input?.key ?? newTemplateKey());

    return {
        id,
        key,
        name: String(input?.name ?? "Template"),
        kind: String(input?.kind ?? "text"),
        branchId: input?.branchId ?? undefined,
        definition: (input?.definition ?? {}) as Readonly<
            Record<string, unknown>
        >,
        defaults: (input?.defaults ?? undefined) as
            | Readonly<Record<string, unknown>>
            | undefined,
        ui: (input?.ui ?? undefined) as
            | Readonly<Record<string, unknown>>
            | undefined,
        validators: (input?.validators ?? undefined) as
            | readonly any[]
            | undefined,
        tags: (input?.tags ?? undefined) as readonly string[] | undefined,
        category: (input?.category ?? undefined) as string | undefined,
        published: Boolean(input?.published ?? true),
        version: Number.isFinite(Number(input?.version))
            ? Number(input.version)
            : 1,
        createdAt: String(input?.createdAt ?? now),
        updatedAt: String(input?.updatedAt ?? now),
    };
}

function matchesSince(
    updatedAt: string | undefined,
    since?: string | number,
): boolean {
    if (!since) return true;
    if (!updatedAt) return false;

    const t: number = Date.parse(updatedAt);
    const s: number =
        typeof since === "number" ? since : Date.parse(String(since));
    if (!Number.isFinite(t) || !Number.isFinite(s)) return true;
    return t >= s;
}

function templateVisibleForBranch(
    tpl: FieldTemplate,
    branchId?: string,
): boolean {
    const tplBid: string | undefined = tpl.branchId ?? undefined;
    if (!branchId) return !tplBid;
    return !tplBid || tplBid === branchId;
}

function seedStore(
    opts: CreateMemoryWorkspaceBackendOptions,
): MemoryWorkspaceStore {
    const seed: MemoryBackendSeed | undefined = opts.seed;

    const store: MemoryWorkspaceStore = {
        info: normalizeInfo(opts.workspaceId, seed?.info),

        authors: new Map<string, Author>(),
        permissionsByActor: new Map<string, PermissionsMap>(),

        branches: new Map<string, Branch>(),
        participantsByBranch: new Map<string, readonly BranchParticipant[]>(),

        services: (seed?.services ?? null) as ServicesInput | null,

        templates: new Map<string, FieldTemplate>(),

        snapshotsByBranch: new Map<string, any>(),

        commentsByBranch: new Map<string, any>(),

        policies: seed?.policies
            ? { raw: seed.policies, updatedAt: isoNow() }
            : null,
        policiesByBranch: new Map<string, any>(),
    };

    if (seed?.policiesByBranch) {
        for (const [bid, raw] of Object.entries(seed.policiesByBranch)) {
            store.policiesByBranch.set(bid, { raw, updatedAt: isoNow() });
        }
    }

    // authors
    if (seed?.authors) {
        for (const a of seed.authors) {
            const na: Author = normalizeAuthor({ ...a });
            store.authors.set(na.id, na);
        }
    }

    // ensure actor-author
    const ensureActorAuthor: boolean = opts.ensureActorAuthor ?? true;
    const actorId: string | undefined = opts.actorId;
    if (ensureActorAuthor && actorId && !store.authors.has(actorId)) {
        store.authors.set(
            actorId,
            normalizeAuthor({
                id: actorId,
                name: seed?.actor?.name ?? "Actor",
                handle: seed?.actor?.meta ? undefined : undefined,
            }),
        );
    }

    // permissions
    if (seed?.permissions) {
        const p: unknown = seed.permissions as unknown;
        if (
            typeof p === "object" &&
            p !== null &&
            !Array.isArray(p) &&
            Object.values(p as Record<string, unknown>).every(
                (v: unknown) => typeof v === "object" && v !== null,
            )
        ) {
            const perActor: Record<string, PermissionsMap> = p as Record<
                string,
                PermissionsMap
            >;
            for (const [k, v] of Object.entries(perActor)) {
                store.permissionsByActor.set(k, v);
            }
        } else {
            store.permissionsByActor.set(
                "*",
                seed.permissions as PermissionsMap,
            );
        }
    }

    // branches
    if (seed?.branches) {
        for (const b of seed.branches) {
            const nb: Branch = normalizeBranch({ ...b });
            store.branches.set(nb.id, nb);
        }
    }

    const ensureMain: boolean = opts.ensureMain ?? true;
    if (ensureMain) {
        if (store.branches.size === 0) {
            const id: string = newBranchId();
            store.branches.set(
                id,
                normalizeBranch({
                    id,
                    name: "main",
                    isMain: true,
                }),
            );
        } else {
            const branches: Branch[] = Array.from(store.branches.values());
            const hasMain: boolean = branches.some((b: Branch) => b.isMain);
            if (!hasMain) {
                const first: Branch = branches[0];
                store.branches.set(first.id, { ...first, isMain: true });
            }
        }
    }

    // participants
    if (seed?.participants) {
        for (const [branchId, list] of Object.entries(seed.participants)) {
            store.participantsByBranch.set(branchId, list);
        }
    }

    // templates
    if (seed?.templates) {
        for (const t of seed.templates) {
            const nt: FieldTemplate = normalizeTemplate(t);
            store.templates.set(nt.id, nt);
        }
    }

    // snapshots
    for (const b of store.branches.values()) {
        store.snapshotsByBranch.set(b.id, newBranchSnapshotState());
    }
    if (seed?.snapshots) {
        for (const [branchId, snapSeed] of Object.entries(seed.snapshots)) {
            const state =
                store.snapshotsByBranch.get(branchId) ??
                newBranchSnapshotState();

            if (snapSeed.head) {
                state.head = { ...snapSeed.head };
                state.commits.set(snapSeed.head.id, {
                    commit: { ...snapSeed.head },
                    snapshot: snapSeed.snapshot ?? emptySnapshot(),
                });
                state.headSnapshot = snapSeed.snapshot ?? emptySnapshot();
            } else if (snapSeed.snapshot) {
                state.headSnapshot = snapSeed.snapshot;
            }

            if (snapSeed.draft) {
                const aId: string = opts.actorId ?? "actor";
                state.drafts.set(aId, {
                    draft: { ...snapSeed.draft },
                    snapshot: snapSeed.snapshot ?? emptySnapshot(),
                });
            }

            store.snapshotsByBranch.set(branchId, state);
        }
    }

    // comments
    for (const b of store.branches.values()) {
        store.commentsByBranch.set(b.id, newCommentsBranchState());
    }
    if (seed?.comments) {
        for (const [branchId, threads] of Object.entries(seed.comments)) {
            const st =
                store.commentsByBranch.get(branchId) ??
                newCommentsBranchState();
            st.threads.clear();
            for (const th of threads) {
                st.threads.set(th.id as ThreadId, th);
            }
            store.commentsByBranch.set(branchId, st);
        }
    }

    return store;
}

export function createMemoryWorkspaceBackend(
    opts: CreateMemoryWorkspaceBackendOptions,
): WorkspaceBackend {
    const store: MemoryWorkspaceStore = seedStore(opts);

    const info: WorkspaceInfo = store.info;

    const authors: AuthorsBackend = {
        list: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            return ok(Array.from(store.authors.values()));
        },
        get: async (authorId: string) => {
            const a: Author | undefined = store.authors.get(authorId);
            return ok(a ?? null);
        },
        refresh: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            return ok(Array.from(store.authors.values()));
        },
    };

    const permissions: PermissionsBackend = {
        get: async (workspaceId: string, actor: Actor) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const seeded: PermissionsMap | undefined =
                store.permissionsByActor.get(actor.id) ??
                store.permissionsByActor.get("*") ??
                undefined;

            return ok(seeded ?? permissivePermissions());
        },
        refresh: async (workspaceId: string, actor: Actor) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const seeded: PermissionsMap | undefined =
                store.permissionsByActor.get(actor.id) ??
                store.permissionsByActor.get("*") ??
                undefined;

            return ok(seeded ?? permissivePermissions());
        },
    };

    const branches: BranchesBackend = {
        list: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            return ok(Array.from(store.branches.values()));
        },

        create: async (
            workspaceId: string,
            name: string,
            opts2?: Readonly<{ fromId?: string }>,
        ) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const id: string = newBranchId();
            const b: Branch = normalizeBranch({
                id,
                name,
                isMain: false,
            });

            store.branches.set(id, b);
            store.snapshotsByBranch.set(id, newBranchSnapshotState());
            store.commentsByBranch.set(id, newCommentsBranchState());

            // optional: copy snapshot from fromId
            if (opts2?.fromId) {
                const from = store.snapshotsByBranch.get(opts2.fromId);
                const to = store.snapshotsByBranch.get(id);
                if (from && to) {
                    const snap: ServiceSnapshot =
                        from.headSnapshot ??
                        (from.head
                            ? from.commits.get(from.head.id)?.snapshot
                            : undefined) ??
                        emptySnapshot();

                    to.headSnapshot = snap;
                    const cmId: string = newCommitId();
                    const commit: Commit = {
                        id: cmId,
                        branchId: id,
                        createdAt: isoNow(),
                        versionId: cmId,
                    };
                    to.head = commit;
                    to.commits.set(cmId, { commit, snapshot: snap });
                    store.branches.set(id, {
                        ...b,
                        headVersionId: cmId,
                        updatedAt: isoNow(),
                    });
                }
            }

            return ok(store.branches.get(id)!);
        },

        setMain: async (workspaceId: string, branchId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const b: Branch | undefined = store.branches.get(branchId);
            if (!b) return fail("not_found", "Branch not found.");

            for (const br of store.branches.values()) {
                if (br.isMain && br.id !== branchId) {
                    store.branches.set(br.id, {
                        ...br,
                        isMain: false,
                        updatedAt: isoNow(),
                    });
                }
            }
            const next: Branch = { ...b, isMain: true, updatedAt: isoNow() };
            store.branches.set(branchId, next);
            return ok(next);
        },

        merge: async (
            workspaceId: string,
            sourceId: string,
            targetId: string,
        ) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const src: Branch | undefined = store.branches.get(sourceId);
            const tgt: Branch | undefined = store.branches.get(targetId);
            if (!src || !tgt) return fail("not_found", "Branch not found.");

            const srcState = store.snapshotsByBranch.get(sourceId);
            const tgtState = store.snapshotsByBranch.get(targetId);

            if (srcState && tgtState) {
                const snap: ServiceSnapshot =
                    srcState.headSnapshot ??
                    (srcState.head
                        ? srcState.commits.get(srcState.head.id)?.snapshot
                        : undefined) ??
                    emptySnapshot();

                const cmId: string = newCommitId();
                const commit: Commit = {
                    id: cmId,
                    branchId: targetId,
                    createdAt: isoNow(),
                    versionId: cmId,
                    message: `Merged ${sourceId} → ${targetId}`,
                };

                tgtState.head = commit;
                tgtState.headSnapshot = snap;
                tgtState.commits.set(cmId, { commit, snapshot: snap });

                const updated: Branch = {
                    ...tgt,
                    headVersionId: cmId,
                    updatedAt: isoNow(),
                };
                store.branches.set(targetId, updated);
            }

            const res: MergeResult = {
                sourceId,
                targetId,
                conflicts: 0,
                message: "Merged in memory",
            };
            return ok(res);
        },

        delete: async (workspaceId: string, branchId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            store.branches.delete(branchId);
            store.participantsByBranch.delete(branchId);
            store.snapshotsByBranch.delete(branchId);
            store.commentsByBranch.delete(branchId);
            store.policiesByBranch.delete(branchId);
            return ok(undefined);
        },

        refresh: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            return ok(Array.from(store.branches.values()));
        },
    };

    const access: BranchAccessBackend = {
        listParticipants: async (workspaceId: string, branchId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const list: readonly BranchParticipant[] =
                store.participantsByBranch.get(branchId) ?? [];
            return ok(list);
        },
        refreshParticipants: async (workspaceId: string, branchId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const list: readonly BranchParticipant[] =
                store.participantsByBranch.get(branchId) ?? [];
            return ok(list);
        },
    };

    const services: ServicesBackend = {
        get: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            if (!store.services) return ok([] as ServicesInput);
            return ok(store.services);
        },
        refresh: async (workspaceId: string) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            if (!store.services) return ok([] as ServicesInput);
            return ok(store.services);
        },
    };

    const templates: TemplatesBackend = {
        list: async (params: TemplatesListParams) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const all: FieldTemplate[] = Array.from(store.templates.values());
            const filtered: FieldTemplate[] = all.filter((t: FieldTemplate) => {
                if (!templateVisibleForBranch(t, params.branchId)) return false;
                if (params.q) {
                    const q: string = params.q.toLowerCase();
                    if (
                        !t.name.toLowerCase().includes(q) &&
                        !t.key.toLowerCase().includes(q)
                    ) {
                        return false;
                    }
                }
                if (params.category && t.category !== params.category)
                    return false;
                if (params.tags && params.tags.length) {
                    const tset: Set<string> = new Set(t.tags ?? []);
                    for (const tag of params.tags) {
                        if (!tset.has(tag)) return false;
                    }
                }
                return !(
                    params.since && !matchesSince(t.updatedAt, params.since)
                );
            });

            return ok(filtered);
        },

        get: async (id: string) => {
            const t: FieldTemplate | undefined = store.templates.get(id);
            return ok(t ?? null);
        },

        getByKey: async (
            workspaceId: string,
            key: string,
            branchId?: string,
        ) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            for (const t of store.templates.values()) {
                if (t.key !== key) continue;
                if (!templateVisibleForBranch(t, branchId)) continue;
                return ok(t);
            }
            return ok(null);
        },

        create: async (workspaceId: string, input: TemplateCreateInput) => {
            if (workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const now: string = isoNow();
            const id: string = newTemplateId();
            const key: string = input.key ?? newTemplateKey();

            const tpl: FieldTemplate = {
                id,
                key,
                name: input.name,
                kind: input.kind,
                branchId: input.branchId ?? undefined,
                definition: input.definition,
                defaults: input.defaults,
                ui: input.ui,
                validators: input.validators,
                tags: input.tags,
                category: input.category,
                published: Boolean(input.published ?? true),
                version: 1,
                createdAt: now,
                updatedAt: now,
            };

            store.templates.set(id, tpl);
            return ok(tpl);
        },

        update: async (id: string, patch: TemplateUpdatePatch) => {
            const prev: FieldTemplate | undefined = store.templates.get(id);
            if (!prev) return fail("not_found", "Template not found.");

            const now: string = isoNow();

            const next: FieldTemplate = {
                ...prev,
                name: patch.name ?? prev.name,
                kind: patch.kind ?? prev.kind,
                branchId:
                    patch.branchId === null
                        ? undefined
                        : (patch.branchId ?? prev.branchId),
                definition: patch.definition ?? prev.definition,
                defaults:
                    patch.defaults === null
                        ? undefined
                        : (patch.defaults ?? prev.defaults),
                ui: patch.ui === null ? undefined : (patch.ui ?? prev.ui),
                validators:
                    patch.validators === null
                        ? undefined
                        : (patch.validators ?? prev.validators),
                tags:
                    patch.tags === null ? undefined : (patch.tags ?? prev.tags),
                category:
                    patch.category === null
                        ? undefined
                        : (patch.category ?? prev.category),
                published: patch.published ?? prev.published,
                version: prev.version + 1,
                updatedAt: now,
            };

            store.templates.set(id, next);
            return ok(next);
        },

        clone: async (
            source: Readonly<{ id?: string; key?: string }>,
            opts2?: Readonly<{
                newKey?: string;
                name?: string;
                branchId?: string;
                asDraft?: boolean;
            }>,
        ) => {
            const src: FieldTemplate | undefined = source.id
                ? store.templates.get(source.id)
                : undefined;

            let byKey: FieldTemplate | undefined = undefined;
            if (!src && source.key) {
                for (const t of store.templates.values()) {
                    if (t.key === source.key) {
                        byKey = t;
                        break;
                    }
                }
            }

            const base: FieldTemplate | undefined = src ?? byKey;
            if (!base) return fail("not_found", "Template source not found.");

            const now: string = isoNow();
            const id: string = newTemplateId();
            const key: string = opts2?.newKey ?? newTemplateKey();

            const next: FieldTemplate = {
                ...base,
                id,
                key,
                name: opts2?.name ?? `${base.name} (copy)`,
                branchId: opts2?.branchId ?? base.branchId,
                version: 1,
                createdAt: now,
                updatedAt: now,
                published: opts2?.asDraft ? false : base.published,
            };

            store.templates.set(id, next);
            return ok(next);
        },

        publish: async (id: string) => {
            const t: FieldTemplate | undefined = store.templates.get(id);
            if (!t) return fail("not_found", "Template not found.");
            const next: FieldTemplate = {
                ...t,
                published: true,
                updatedAt: isoNow(),
            };
            store.templates.set(id, next);
            return ok(next);
        },

        unpublish: async (id: string) => {
            const t: FieldTemplate | undefined = store.templates.get(id);
            if (!t) return fail("not_found", "Template not found.");
            const next: FieldTemplate = {
                ...t,
                published: false,
                updatedAt: isoNow(),
            };
            store.templates.set(id, next);
            return ok(next);
        },

        delete: async (id: string) => {
            store.templates.delete(id);
            return ok(undefined);
        },

        refresh: async (
            params: Omit<TemplatesListParams, "q" | "tags" | "category">,
        ) => {
            return templates.list({ ...params });
        },
    };

    const snapshots: SnapshotsBackend = {
        load: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const st = store.snapshotsByBranch.get(params.branchId);
            if (!st) return fail("not_found", "Branch not found.");

            const draftEntry = st.drafts.get(params.actorId);
            const headEntry = st.head ? st.commits.get(st.head.id) : undefined;

            // if versionId requested, try commit map
            if (params.versionId) {
                const v = st.commits.get(params.versionId);
                if (v) {
                    const out: SnapshotsLoadResult = {
                        head: st.head,
                        draft: draftEntry?.draft,
                        snapshot: v.snapshot,
                    };
                    return ok(out);
                }
            }

            const snapshot: ServiceSnapshot = (draftEntry?.snapshot ??
                headEntry?.snapshot ??
                st.headSnapshot ??
                emptySnapshot()) as ServiceSnapshot;

            const out: SnapshotsLoadResult = {
                head: st.head,
                draft: draftEntry?.draft,
                snapshot,
            };
            return ok(out);
        },

        autosave: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const st = store.snapshotsByBranch.get(params.branchId);
            if (!st) return fail("not_found", "Branch not found.");

            const prev = st.drafts.get(params.actorId);
            if (
                params.etag &&
                prev?.draft.etag &&
                params.etag !== prev.draft.etag
            ) {
                return fail("etag_mismatch", "Draft etag mismatch.", {
                    meta: { expected: prev.draft.etag, got: params.etag },
                });
            }

            const now: string = isoNow();
            const draftId: string = prev?.draft.id ?? newDraftId();
            const nextEtag: string = bumpEtag(prev?.draft.etag);

            const draft: Draft = {
                id: draftId,
                branchId: params.branchId,
                status: "uncommitted",
                etag: nextEtag,
                meta: prev?.draft.meta,
                createdAt: prev?.draft.createdAt ?? now,
                updatedAt: now,
            };

            st.drafts.set(params.actorId, { draft, snapshot: params.snapshot });

            return ok({ draft });
        },

        save: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const st = store.snapshotsByBranch.get(params.branchId);
            if (!st) return fail("not_found", "Branch not found.");

            // optional etag check against draft if draftId provided
            if (params.draftId) {
                const entry = st.drafts.get(params.actorId);
                if (entry && entry.draft.id === params.draftId) {
                    if (
                        params.etag &&
                        entry.draft.etag &&
                        params.etag !== entry.draft.etag
                    ) {
                        return fail("etag_mismatch", "Draft etag mismatch.", {
                            meta: {
                                expected: entry.draft.etag,
                                got: params.etag,
                            },
                        });
                    }
                }
            }

            const id: string = newCommitId();
            const commit: Commit = {
                id,
                branchId: params.branchId,
                message: params.message,
                versionId: id,
                etag: bumpEtag(undefined),
                createdAt: isoNow(),
            };

            st.commits.set(id, { commit, snapshot: params.snapshot });
            st.head = commit;
            st.headSnapshot = params.snapshot;

            // update branch head pointer
            const b: Branch | undefined = store.branches.get(params.branchId);
            if (b) {
                store.branches.set(params.branchId, {
                    ...b,
                    headVersionId: id,
                    updatedAt: isoNow(),
                });
            }

            // if saving from a draft, keep draft (user may still publish) unless you want to clear:
            // We keep it for now to avoid surprise data loss.

            return ok({ commit });
        },

        publish: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            // locate draft by id across branches for this actor
            let foundBranchId: string | null = null;
            let foundEntry: { draft: Draft; snapshot: ServiceSnapshot } | null =
                null;

            for (const [bid, st] of store.snapshotsByBranch.entries()) {
                const entry = st.drafts.get(params.actorId);
                if (entry && entry.draft.id === params.draftId) {
                    foundBranchId = bid;
                    foundEntry = entry;
                    break;
                }
            }

            if (!foundBranchId || !foundEntry) {
                return fail("not_found", "Draft not found.");
            }

            const st = store.snapshotsByBranch.get(foundBranchId)!;

            const id: string = newCommitId();
            const commit: Commit = {
                id,
                branchId: foundBranchId,
                message: params.message,
                versionId: id,
                etag: bumpEtag(undefined),
                createdAt: isoNow(),
            };

            st.commits.set(id, { commit, snapshot: foundEntry.snapshot });
            st.head = commit;
            st.headSnapshot = foundEntry.snapshot;

            // clear that draft
            st.drafts.delete(params.actorId);

            // update branch
            const b: Branch | undefined = store.branches.get(foundBranchId);
            if (b) {
                store.branches.set(foundBranchId, {
                    ...b,
                    headVersionId: id,
                    updatedAt: isoNow(),
                });
            }

            return ok({ commit });
        },

        discard: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            // find branch containing the draft
            for (const st of store.snapshotsByBranch.values()) {
                const entry = st.drafts.get(params.actorId);
                if (entry && entry.draft.id === params.draftId) {
                    st.drafts.delete(params.actorId);
                    return ok(undefined);
                }
            }

            return fail("not_found", "Draft not found.");
        },

        refresh: async (params) => {
            if (params.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const st = store.snapshotsByBranch.get(params.branchId);
            if (!st) return fail("not_found", "Branch not found.");

            const draft = st.drafts.get(params.actorId)?.draft;
            const head = st.head;

            return ok({ head, draft });
        },
    };

    function ensureThreadContext(ctx: BackendScope, threadId: string) {
        if (ctx.workspaceId !== info.id)
            return fail("not_found", "Workspace not found.");
        const st =
            store.commentsByBranch.get(ctx.branchId) ??
            newCommentsBranchState();
        store.commentsByBranch.set(ctx.branchId, st);

        const th: CommentThread = ensureThread(st, threadId as ThreadId);
        const nowN: number = Date.now();
        return ok({ st, th, nowN });
    }

    const commentsImpl: CommentsBackend<
        CommentThread,
        CommentMessage,
        CommentAnchor
    > = {
        listThreads: async (ctx: BackendScope) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const st =
                store.commentsByBranch.get(ctx.branchId) ??
                newCommentsBranchState();
            store.commentsByBranch.set(ctx.branchId, st);

            const list: readonly CommentThread[] = Array.from(
                st.threads.values(),
            );
            return ok(list);
        },

        createThread: async (ctx: BackendScope, input) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const st =
                store.commentsByBranch.get(ctx.branchId) ??
                newCommentsBranchState();
            store.commentsByBranch.set(ctx.branchId, st);

            const nowN: number = Date.now();
            const threadId: ThreadId = newThreadId() as ThreadId;
            const msgId: CommentId = newMessageId() as CommentId;

            const th: CommentThread = {
                id: threadId,
                anchor: input.anchor,
                resolved: false,
                createdAt: nowN as any,
                updatedAt: nowN as any,
                messages: [
                    {
                        id: msgId,
                        body: input.body,
                        createdAt: nowN as any,
                        meta: input.meta,
                    } as CommentMessage,
                ],
                meta: input.meta,
            } as CommentThread;

            st.threads.set(threadId, th);
            return ok(th);
        },

        addMessage: async (ctx: BackendScope, input) => {
            const res = ensureThreadContext(ctx, input.threadId);
            if (!res.ok) return res;
            const { st, th, nowN } = res.value;

            const msg: CommentMessage = {
                id: newMessageId() as CommentId,
                body: input.body,
                createdAt: nowN as any,
                meta: input.meta,
            } as CommentMessage;

            const msgs: CommentMessage[] = [
                ...((th.messages ?? []) as CommentMessage[]),
                msg,
            ];
            const next: CommentThread = {
                ...(th as object),
                messages: msgs,
                updatedAt: nowN as any,
            } as CommentThread;

            st.threads.set(th.id as ThreadId, next);
            return ok(msg);
        },

        editMessage: async (ctx: BackendScope, input) => {
            const res = ensureThreadContext(ctx, input.threadId);
            if (!res.ok) return res;
            const { st, th, nowN } = res.value;

            const idx: number = findMessageIndex(
                th,
                input.messageId as CommentId,
            );
            if (idx < 0) return fail("not_found", "Message not found.");

            const msgs: CommentMessage[] = [
                ...((th.messages ?? []) as CommentMessage[]),
            ];
            const prev: CommentMessage = msgs[idx] as CommentMessage;

            const nextMsg: CommentMessage = {
                ...(prev as object),
                body: input.body,
                editedAt: nowN as any,
            } as CommentMessage;

            msgs[idx] = nextMsg;

            const next: CommentThread = {
                ...(th as object),
                messages: msgs,
                updatedAt: nowN as any,
            } as CommentThread;

            st.threads.set(th.id as ThreadId, next);
            return ok(nextMsg);
        },

        deleteMessage: async (ctx: BackendScope, input) => {
            const res = ensureThreadContext(ctx, input.threadId);
            if (!res.ok) return res;
            const { st, th, nowN } = res.value;

            const msgs: CommentMessage[] = (
                (th.messages ?? []) as CommentMessage[]
            ).filter(
                (m: CommentMessage) => m.id !== (input.messageId as CommentId),
            );

            const next: CommentThread = {
                ...(th as object),
                messages: msgs,
                updatedAt: nowN as any,
            } as CommentThread;

            st.threads.set(th.id as ThreadId, next);
            return ok(undefined);
        },

        moveThread: async (ctx: BackendScope, input) => {
            const res = ensureThreadContext(ctx, input.threadId);
            if (!res.ok) return res;
            const { st, th, nowN } = res.value;

            const next: CommentThread = {
                ...(th as object),
                anchor: input.anchor,
                updatedAt: nowN as any,
            } as CommentThread;

            st.threads.set(th.id as ThreadId, next);
            return ok(next);
        },

        resolveThread: async (ctx: BackendScope, input) => {
            const res = ensureThreadContext(ctx, input.threadId);
            if (!res.ok) return res;
            const { st, th, nowN } = res.value;

            const next: CommentThread = {
                ...(th as object),
                resolved: input.resolved,
                updatedAt: nowN as any,
            } as CommentThread;

            st.threads.set(th.id as ThreadId, next);
            return ok(next);
        },

        deleteThread: async (ctx: BackendScope, input) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");
            const st =
                store.commentsByBranch.get(ctx.branchId) ??
                newCommentsBranchState();
            store.commentsByBranch.set(ctx.branchId, st);

            st.threads.delete(input.threadId as ThreadId);
            return ok(undefined);
        },
    };

    // WorkspaceBackend.comments expects CommentsBackend (default unknown generics);
    // we return a structurally compatible implementation.
    const comments: WorkspaceBackend["comments"] = commentsImpl;

    const policies: PoliciesBackend = {
        load: async (ctx: PolicyScope) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const state = ctx.branchId
                ? store.policiesByBranch.get(ctx.branchId)
                : store.policies;

            if (!state) return ok(null);

            const out: PoliciesLoadResult = {
                raw: state.raw,
                updatedAt: state.updatedAt,
                etag: state.etag,
            };
            return ok(out);
        },

        save: async (ctx: PolicyScope, input) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const prev = ctx.branchId
                ? store.policiesByBranch.get(ctx.branchId)
                : store.policies;

            if (input.etag && prev?.etag && input.etag !== prev.etag) {
                return fail("etag_mismatch", "Policy etag mismatch.");
            }

            const updatedAt = isoNow();
            const etag = bumpEtag(prev?.etag);
            const next = { raw: input.raw, updatedAt, etag };

            if (ctx.branchId) {
                store.policiesByBranch.set(ctx.branchId, next);
            } else {
                store.policies = next;
            }

            return ok({ updatedAt, etag });
        },

        clear: async (ctx: PolicyScope) => {
            if (ctx.workspaceId !== info.id)
                return fail("not_found", "Workspace not found.");

            const updatedAt = isoNow();
            if (ctx.branchId) {
                store.policiesByBranch.delete(ctx.branchId);
            } else {
                store.policies = null;
            }

            return ok({ updatedAt });
        },
    };

    const backend: WorkspaceBackend = {
        info,
        authors,
        permissions,
        branches,
        access,
        services,
        templates,
        snapshots,
        policies,
        comments,
    };

    return backend;
}
```

---
#### 20


` File: src/react/workspace/context/memory/seed.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/seed.ts

import type {
    Actor,
    Author,
    Branch,
    BranchParticipant,
    Commit,
    Draft,
    PermissionsMap,
    ServiceSnapshot,
    ServicesInput,
    WorkspaceInfo,
} from "../backend";

import type { CommentThread } from "@/schema/comments";

export interface MemorySeedBranchSnapshots {
    readonly head?: Commit;
    readonly draft?: Draft;
    readonly snapshot?: ServiceSnapshot;
}

export type MemorySeedParticipants = Readonly<
    Record<string, readonly BranchParticipant[]>
>;

export type MemorySeedBranchSnapshotsMap = Readonly<
    Record<string, MemorySeedBranchSnapshots>
>;

export type MemorySeedComments = Readonly<
    Record<string, readonly CommentThread[]>
>;

export type SeededPermissions =
    | PermissionsMap
    | Readonly<Record<string, PermissionsMap>>;

export interface MemoryBackendSeed {
    readonly info?: Partial<WorkspaceInfo>;

    readonly actor?: Partial<Actor>;
    readonly authors?: readonly Author[];

    readonly permissions?: SeededPermissions;

    readonly branches?: readonly Branch[];

    /** participants keyed by branchId */
    readonly participants?: MemorySeedParticipants;

    readonly services?: ServicesInput;

    /** templates may be global (no branchId) or branch-scoped (branchId set) */
    readonly templates?: readonly any[]; // FieldTemplate lives in backend.ts; keep seed ergonomic

    /** snapshots keyed by branchId */
    readonly snapshots?: MemorySeedBranchSnapshotsMap;

    /** comments threads keyed by branchId */
    readonly comments?: MemorySeedComments;

    /** workspace policies */
    readonly policies?: unknown;

    /** branch policies keyed by branchId */
    readonly policiesByBranch?: Readonly<Record<string, unknown>>;
}

export interface CreateMemoryWorkspaceBackendOptions {
    readonly workspaceId: string;
    readonly actorId?: string;

    /**
     * If true (default), ensure a main branch exists.
     * If branches are seeded but none isMain=true, the first becomes main.
     */
    readonly ensureMain?: boolean;

    /**
     * If true (default), ensure at least one author exists.
     * If authors are not seeded, one author is created from actorId.
     */
    readonly ensureActorAuthor?: boolean;

    /** Seed data to preload the in-memory store */
    readonly seed?: MemoryBackendSeed;
}
```

---
#### 21


` File: src/react/workspace/context/memory/store.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/store.ts

import type {
    Author,
    Branch,
    BranchParticipant,
    Commit,
    Draft,
    FieldTemplate,
    PermissionsMap,
    ServiceSnapshot,
    ServicesInput,
    WorkspaceInfo,
} from "../backend";

import type {
    CommentAnchor,
    CommentId,
    CommentMessage,
    CommentThread,
    ThreadId,
} from "@/schema/comments";

export interface BranchSnapshotState {
    head?: Commit;
    headSnapshot?: ServiceSnapshot;

    /** drafts keyed by actorId */
    drafts: Map<string, { draft: Draft; snapshot: ServiceSnapshot }>;

    /** commits keyed by commitId (versionId) */
    commits: Map<string, { commit: Commit; snapshot: ServiceSnapshot }>;
}

export interface CommentsBranchState {
    threads: Map<ThreadId, CommentThread>;
    // message index is derived; no separate store needed
}

export interface PolicyState {
    raw: unknown;
    updatedAt?: string;
    etag?: string;
}

export interface MemoryWorkspaceStore {
    info: WorkspaceInfo;

    authors: Map<string, Author>;

    /** permissions by actorId */
    permissionsByActor: Map<string, PermissionsMap>;

    branches: Map<string, Branch>;
    participantsByBranch: Map<string, readonly BranchParticipant[]>;

    services: ServicesInput | null;

    templates: Map<string, FieldTemplate>;

    snapshotsByBranch: Map<string, BranchSnapshotState>;

    commentsByBranch: Map<string, CommentsBranchState>;

    /** workspace-scoped policies */
    policies: PolicyState | null;

    /** branch-scoped policies */
    policiesByBranch: Map<string, PolicyState>;
}

export function newBranchSnapshotState(): BranchSnapshotState {
    return {
        drafts: new Map<string, { draft: Draft; snapshot: ServiceSnapshot }>(),
        commits: new Map<
            string,
            { commit: Commit; snapshot: ServiceSnapshot }
        >(),
    };
}

export function newCommentsBranchState(): CommentsBranchState {
    return {
        threads: new Map<ThreadId, CommentThread>(),
    };
}

// helpers that don’t need to know about backend.ts shapes beyond comment schemas
export function findMessageIndex(
    thread: CommentThread,
    messageId: CommentId,
): number {
    const msgs: readonly CommentMessage[] = (thread.messages ??
        []) as readonly CommentMessage[];
    for (let i: number = 0; i < msgs.length; i += 1) {
        if (msgs[i].id === messageId) return i;
    }
    return -1;
}

export function ensureThread(
    state: CommentsBranchState,
    threadId: ThreadId,
): CommentThread {
    const th: CommentThread | undefined = state.threads.get(threadId);
    if (!th) {
        throw new Error(`Comment thread not found: ${String(threadId)}`);
    }
    return th;
}

export function setThreadAnchor(
    thread: CommentThread,
    anchor: CommentAnchor,
): CommentThread {
    return { ...(thread as object), anchor } as CommentThread;
}
```

---
#### 22


` File: src/react/workspace/context/memory/time.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/backend/memory/time.ts

export function nowMs(): number {
    return Date.now();
}

export function isoNow(): string {
    return new Date().toISOString();
}

export function toIso(input?: string | number | Date): string {
    if (!input) return isoNow();
    if (typeof input === "string") return input;
    if (typeof input === "number") return new Date(input).toISOString();
    return input.toISOString();
}
```

---
#### 23


` File: src/react/workspace/context/provider/compose/use-branch-cache.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-branch-cache.ts
import * as React from "react";
import type { BranchCacheEntry, Loadable, SnapshotSlice } from "../types";
import type { FieldTemplate, BranchParticipant } from "../../backend";

import { createCache, createIndexedDBDriver } from "@timeax/cache-store";
import type { CacheStore } from "@timeax/cache-store";

export interface BranchCacheApi {
    /**
     * Clear cached branch scopes for THIS workspace.
     */
    readonly clear: () => void;

    readonly switchBranch: (
        args: Readonly<{
            /**
             * Redundant on purpose: call-sites must pass workspaceId explicitly,
             * and the hook is also workspace-scoped.
             *
             * This allows us to detect wiring bugs (mismatched workspace scopes).
             */
            workspaceId: string;

            nextId: string;
            prevId?: string;

            templates: Loadable<readonly FieldTemplate[]>;
            participants: Loadable<readonly BranchParticipant[]>;
            snapshot: SnapshotSlice;

            setTemplates: React.Dispatch<
                React.SetStateAction<Loadable<readonly FieldTemplate[]>>
            >;
            setParticipants: React.Dispatch<
                React.SetStateAction<Loadable<readonly BranchParticipant[]>>
            >;
            setSnapshot: React.Dispatch<React.SetStateAction<SnapshotSlice>>;

            resetTemplates: () => void;
            resetParticipants: () => void;
            resetSnapshot: () => void;

            setCurrentBranchId: (id: string) => void;

            hasInitialSnapshot: boolean;

            loadSnapshotForBranch: (branchId: string) => void;
        }>,
    ) => void;
}

const DB_NAME = "dgp-cache";
const STORE_NAME = "kv";
const NS = "workspace";

// Key scheme (per workspace):
//   ws:<workspaceId>:branch:<branchId>
const WS_PREFIX = "ws:";
const keyOf = (workspaceId: string, branchId: string): string =>
    `${WS_PREFIX}${workspaceId}:branch:${branchId}`;

const branchPrefixOf = (workspaceId: string): string =>
    `${WS_PREFIX}${workspaceId}:branch:`;

type PendingSwitch = Readonly<{
    workspaceId: string;
    nextId: string;
    hasInitialSnapshot: boolean;

    setTemplates: React.Dispatch<
        React.SetStateAction<Loadable<readonly FieldTemplate[]>>
    >;
    setParticipants: React.Dispatch<
        React.SetStateAction<Loadable<readonly BranchParticipant[]>>
    >;
    setSnapshot: React.Dispatch<React.SetStateAction<SnapshotSlice>>;

    loadSnapshotForBranch: (branchId: string) => void;
}>;

export function useBranchCache(workspaceId: string): BranchCacheApi {
    // IndexedDB-backed cache instance (scoped by ns + key prefixing).
    const cache: CacheStore = React.useMemo(() => {
        return createCache({
            driver: createIndexedDBDriver({
                dbName: DB_NAME,
                storeName: STORE_NAME,
                ns: NS,
            }),
            hydrate: true,
            cleanupExpiredOnHydrate: true,
        });
    }, []);

    const wsIdRef = React.useRef<string>(workspaceId);
    React.useEffect(() => {
        wsIdRef.current = workspaceId;
    }, [workspaceId]);

    // IDB hydration is async. We keep it internal to preserve the hook API.
    const readyRef = React.useRef<boolean>(cache.isReady());

    // If switchBranch runs before hydration completes, we defer the “load snapshot” decision.
    const pendingRef = React.useRef<PendingSwitch | null>(null);

    const applyCached = React.useCallback(
        (
            wsId: string,
            nextId: string,
            p: PendingSwitch,
        ): { cached?: BranchCacheEntry; hasCachedSnapshot: boolean } => {
            const cached = cache.get<BranchCacheEntry>(keyOf(wsId, nextId));

            if (cached) {
                p.setTemplates(cached.templates);
                p.setParticipants(cached.participants);
                p.setSnapshot(cached.snapshot);
            }

            const hasCachedSnapshot = Boolean(
                cached?.snapshot?.data && cached?.snapshot?.schemaVersion,
            );

            return { cached, hasCachedSnapshot };
        },
        [cache],
    );

    React.useEffect(() => {
        if (cache.isReady()) {
            readyRef.current = true;
            return;
        }

        const unsub = cache.subscribeReady(() => {
            readyRef.current = true;

            const p = pendingRef.current;
            if (!p) return;

            const { hasCachedSnapshot } = applyCached(
                p.workspaceId,
                p.nextId,
                p,
            );

            if (!hasCachedSnapshot && !p.hasInitialSnapshot) {
                p.loadSnapshotForBranch(p.nextId);
            }

            pendingRef.current = null;
        });

        return () => unsub();
    }, [cache, applyCached]);

    const clear = React.useCallback((): void => {
        pendingRef.current = null;

        // Clear ONLY this workspace scope.
        cache.clear(branchPrefixOf(wsIdRef.current));
    }, [cache]);

    const switchBranch = React.useCallback(
        (
            args: Readonly<{
                workspaceId: string;

                nextId: string;
                prevId?: string;

                templates: Loadable<readonly FieldTemplate[]>;
                participants: Loadable<readonly BranchParticipant[]>;
                snapshot: SnapshotSlice;

                setTemplates: React.Dispatch<
                    React.SetStateAction<Loadable<readonly FieldTemplate[]>>
                >;
                setParticipants: React.Dispatch<
                    React.SetStateAction<Loadable<readonly BranchParticipant[]>>
                >;
                setSnapshot: React.Dispatch<
                    React.SetStateAction<SnapshotSlice>
                >;

                resetTemplates: () => void;
                resetParticipants: () => void;
                resetSnapshot: () => void;

                setCurrentBranchId: (id: string) => void;

                hasInitialSnapshot: boolean;

                loadSnapshotForBranch: (branchId: string) => void;
            }>,
        ): void => {
            const hookWsId: string = wsIdRef.current;
            const callWsId: string = args.workspaceId;

            // Redundant-by-design safety check (catch wiring mistakes).
            if (callWsId !== hookWsId) {
                // Keep it non-fatal (warn) to avoid breaking UX in production.
                // If you want strict behavior later, we can throw in dev only.
                // eslint-disable-next-line no-console
                console.warn(
                    `[useBranchCache] workspaceId mismatch: hook="${hookWsId}" vs switchBranch="${callWsId}". Using switchBranch workspaceId.`,
                );
            }

            const wsId: string = callWsId;
            const prevId: string | undefined = args.prevId;

            // Cache previous branch scope (per workspace).
            if (prevId && prevId !== args.nextId) {
                cache.set<BranchCacheEntry>(keyOf(wsId, prevId), {
                    templates: args.templates,
                    participants: args.participants,
                    snapshot: args.snapshot,
                });
            }

            // Try to read cached next branch from mirror (may be empty before hydration).
            const cached = cache.get<BranchCacheEntry>(
                keyOf(wsId, args.nextId),
            );

            if (cached) {
                args.setTemplates(cached.templates);
                args.setParticipants(cached.participants);
                args.setSnapshot(cached.snapshot);
            } else {
                args.resetTemplates();
                args.resetParticipants();
                args.resetSnapshot();
            }

            args.setCurrentBranchId(args.nextId);

            const hasCachedSnapshot: boolean = Boolean(
                cached?.snapshot?.data && cached?.snapshot?.schemaVersion,
            );

            // If not hydrated yet, defer the “no cache → load snapshot” decision because hydration
            // might bring in a cached snapshot for this workspace+branch.
            if (!readyRef.current && !hasCachedSnapshot) {
                pendingRef.current = {
                    workspaceId: wsId,
                    nextId: args.nextId,
                    hasInitialSnapshot: args.hasInitialSnapshot,
                    setTemplates: args.setTemplates,
                    setParticipants: args.setParticipants,
                    setSnapshot: args.setSnapshot,
                    loadSnapshotForBranch: args.loadSnapshotForBranch,
                };
                return;
            }

            // Normal behavior once ready (or when already has cached snapshot).
            if (!hasCachedSnapshot && !args.hasInitialSnapshot) {
                args.loadSnapshotForBranch(args.nextId);
            } else {
                pendingRef.current = null;
            }
        },
        [cache],
    );

    return React.useMemo<BranchCacheApi>(
        () => ({ clear, switchBranch }),
        [clear, switchBranch],
    );
}
```

---
#### 24


` File: src/react/workspace/context/provider/compose/use-live-polling.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-live-polling.ts
import * as React from "react";
import type { Actor, BackendError, LiveOptions } from "../../backend";
import type { RunResult } from "../types";
import type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterRegistry,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "../live/types";
import { createPollAdapter } from "../live/adapters/poll";

export interface LiveControl {
    readonly connected: boolean;
    readonly lastEventAt?: number;
    readonly lastError?: BackendError;
    readonly connect: () => void;
    readonly disconnect: () => void;
}

export interface UseLivePollingParams {
    readonly live: LiveOptions;
    readonly workspaceId: string;
    readonly actor: Actor;

    readonly hasAnyData: boolean;

    readonly getCurrentBranchId: () => string | undefined;

    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;
    readonly refreshBranchContext?: () => Promise<void>;
    readonly refreshSnapshotPointers?: () => Promise<void>;

    /**
     * Host can provide adapters for modes like "ws" / "sse"
     * (and even custom strings later).
     */
    readonly adapters?: WorkspaceLiveAdapterRegistry;

    /**
     * Simple debounce to avoid refresh storms (WS bursts etc).
     * Default: 250ms
     */
    readonly debounceMs?: number;
}

function toError(e: unknown): BackendError {
    if (
        typeof e === "object" &&
        e &&
        "code" in (e as Record<string, unknown>) &&
        "message" in (e as Record<string, unknown>)
    ) {
        return e as BackendError;
    }
    if (e instanceof Error) {
        return { code: "runtime_error", message: `${e.name}: ${e.message}` };
    }
    return { code: "unknown_error", message: String(e ?? "Unknown error") };
}

export function useLivePolling(params: UseLivePollingParams): LiveControl {
    const {
        live,
        workspaceId,
        actor,
        hasAnyData,
        getCurrentBranchId,
        refreshAll,
        refreshBranchContext,
        refreshSnapshotPointers,
        adapters,
        debounceMs,
    } = params;

    const [status, setStatus] = React.useState<WorkspaceLiveStatus>(() => ({
        connected: false,
    }));

    const adapterRef = React.useRef<WorkspaceLiveAdapter | null>(null);
    const inflightRef = React.useRef<boolean>(false);
    const debounceTimerRef = React.useRef<number | null>(null);
    const lastTickRef = React.useRef<WorkspaceLiveTick | null>(null);

    const debounceWindowMs: number = debounceMs ?? 250;

    const disconnect = React.useCallback((): void => {
        if (debounceTimerRef.current != null) {
            window.clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = null;
        }
        adapterRef.current?.disconnect();
        adapterRef.current = null;
        inflightRef.current = false;
        lastTickRef.current = null;
        setStatus({ connected: false });
    }, []);

    const resolveAdapter =
        React.useCallback((): WorkspaceLiveAdapter | null => {
            if (live.mode === "off") return null;

            if (live.mode === "poll") {
                return createPollAdapter({ defaultIntervalMs: 15000 });
            }

            // ws/sse (or future modes) must be provided by host registry
            const reg: WorkspaceLiveAdapterRegistry | undefined = adapters;
            const factory = reg ? reg[live.mode] : undefined;

            return factory ? factory() : null;
        }, [live.mode, adapters]);

    const ctx = React.useMemo<WorkspaceLiveAdapterContext>(
        () => ({
            workspaceId,
            actorId: actor.id,
            live,
            getCurrentBranchId,
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers,
        }),
        [
            workspaceId,
            actor.id,
            live,
            getCurrentBranchId,
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers,
        ],
    );

    const scheduleRefresh = React.useCallback(
        (tick: WorkspaceLiveTick): void => {
            lastTickRef.current = tick;

            if (debounceTimerRef.current != null) {
                window.clearTimeout(debounceTimerRef.current);
                debounceTimerRef.current = null;
            }

            debounceTimerRef.current = window.setTimeout(() => {
                debounceTimerRef.current = null;

                if (inflightRef.current) return;
                inflightRef.current = true;

                void (async () => {
                    try {
                        const res: RunResult = await refreshAll({
                            strict: false,
                        });

                        if (!res.ok) {
                            setStatus((s) => ({
                                ...s,
                                connected: true,
                                lastEventAt: tick.at,
                                lastError: res.errors[0],
                            }));
                        } else {
                            setStatus((s) => ({
                                ...s,
                                connected: true,
                                lastEventAt: tick.at,
                                lastError: undefined,
                            }));
                        }
                    } catch (e: unknown) {
                        setStatus((s) => ({
                            ...s,
                            connected: true,
                            lastEventAt: tick.at,
                            lastError: toError(e),
                        }));
                    } finally {
                        inflightRef.current = false;
                    }
                })();
            }, debounceWindowMs) as unknown as number;
        },
        [refreshAll, debounceWindowMs],
    );

    const connect = React.useCallback((): void => {
        // idempotent: disconnect current first
        disconnect();

        if (live.mode === "off") {
            setStatus({ connected: false });

            // parity with old behavior: if nothing loaded yet, do an initial refresh
            if (!hasAnyData) {
                void (async () => {
                    await refreshAll({ strict: false });
                })();
            }

            return;
        }

        const adapter: WorkspaceLiveAdapter | null = resolveAdapter();

        if (!adapter) {
            setStatus({
                connected: false,
                lastError: {
                    code: "live_adapter_missing",
                    message: `No live adapter registered for mode "${live.mode}".`,
                },
            });
            return;
        }

        adapterRef.current = adapter;

        void Promise.resolve(
            adapter.connect(ctx, {
                onTick: (tick: WorkspaceLiveTick) => {
                    // treat any tick as “refresh now”
                    scheduleRefresh(tick);
                },
                onStatus: (s: WorkspaceLiveStatus) => {
                    setStatus((prev) => ({
                        ...prev,
                        ...s,
                    }));
                },
            }),
        ).catch((e: unknown) => {
            setStatus({
                connected: false,
                lastError: toError(e),
            });
        });
    }, [
        disconnect,
        live.mode,
        hasAnyData,
        refreshAll,
        resolveAdapter,
        ctx,
        scheduleRefresh,
    ]);

    // Auto-connect/disconnect based on (workspaceId + live.mode + key options)
    const liveKey: string = React.useMemo(() => {
        if (live.mode === "poll") return `poll:${live.intervalMs ?? 15000}`;
        if (live.mode === "ws") return `ws:${live.url}`;
        if (live.mode === "sse") return `sse:${live.url}`;
        return String(live.mode);
    }, [live]);

    React.useEffect(() => {
        connect();
        return () => disconnect();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [workspaceId, liveKey]);

    return React.useMemo<LiveControl>(
        () => ({
            connected: status.connected,
            lastEventAt: status.lastEventAt,
            lastError: status.lastError,
            connect,
            disconnect,
        }),
        [
            status.connected,
            status.lastEventAt,
            status.lastError,
            connect,
            disconnect,
        ],
    );
}
```

---
#### 25


` File: src/react/workspace/context/provider/compose/use-workspace-refresh.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-workspace-refresh.ts
import * as React from "react";
import type { RunResult } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";
import { PoliciesSlice } from "@/react/workspace/context/provider/slices/use-policies-slice";
import { CommentsSliceApi } from "@/react/workspace/context/provider/slices/use-comments-slice";

export interface WorkspaceRefreshApi {
    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;

    // NOTE: still callable as refreshBranchContext() — we just allow optional params.
    readonly refreshBranchContext: (
        opts?: Readonly<{
            branchId?: string;

            /**
             * When true, errors stop the chain (same meaning as refreshAll strict).
             * Defaults to false (tolerant).
             */
            strict?: boolean;

            /**
             * Include workspace-scoped refreshes that are often “branch-relevant” in practice
             * (services, permissions, authors). Defaults to true.
             */
            includeWorkspaceData?: boolean;
        }>,
    ) => Promise<void>;

    // NOTE: still callable as refreshSnapshotPointers() — optional params allowed.
    readonly refreshSnapshotPointers: (
        opts?: Readonly<{
            branchId?: string;
            strict?: boolean;
        }>,
    ) => Promise<void>;
}

export interface UseWorkspaceRefreshParams {
    readonly runtime: BackendRuntime;

    readonly refreshAuthors: () => Promise<void>;
    readonly refreshPermissions: () => Promise<void>;
    readonly refreshBranches: () => Promise<void>;
    readonly refreshServices: () => Promise<void>;
    readonly refreshPolicies: PoliciesSlice["refreshPolicies"];
    readonly refreshComments: CommentsSliceApi["refreshThreads"];

    readonly getCurrentBranchId: () => string | undefined;

    readonly refreshTemplates: (
        params?: Partial<{ branchId: string }>,
    ) => Promise<void>;
    readonly refreshParticipants: (
        params?: Partial<{ branchId: string }>,
    ) => Promise<void>;

    readonly refreshSnapshotPointersForBranch: (
        branchId: string,
    ) => Promise<void>;
    readonly refreshSnapshotPointers: () => Promise<void>;
}

export function useWorkspaceRefresh(
    params: UseWorkspaceRefreshParams,
): WorkspaceRefreshApi {
    const {
        runtime,
        refreshAuthors,
        refreshPermissions,
        refreshBranches,
        refreshServices,
        refreshComments,
        refreshPolicies,
        getCurrentBranchId,
        refreshTemplates,
        refreshParticipants,
        refreshSnapshotPointersForBranch,
        refreshSnapshotPointers,
    } = params;

    const refreshBranchLocalContext = React.useCallback(
        async (branchId: string, tolerant: boolean): Promise<RunResult> => {
            return runtime.runTasks(
                [
                    () => refreshParticipants({ branchId }),
                    () => refreshTemplates({ branchId }),
                    () => refreshSnapshotPointersForBranch(branchId),
                    () => refreshComments(),
                    () => refreshPolicies({ branchId }),
                ],
                tolerant,
            );
        },
        [
            runtime,
            refreshParticipants,
            refreshTemplates,
            refreshSnapshotPointersForBranch,
        ],
    );

    const refreshBranchContext = React.useCallback(
        async (
            opts?: Readonly<{
                branchId?: string;
                strict?: boolean;
                includeWorkspaceData?: boolean;
            }>,
        ): Promise<void> => {
            const branchId: string | undefined =
                opts?.branchId ?? getCurrentBranchId();

            if (!branchId) return;

            const tolerant: boolean = !(opts?.strict ?? false);
            const includeWorkspaceData: boolean =
                opts?.includeWorkspaceData ?? true;

            // The “practical” expectation: branch refresh should refresh branch-local data
            // AND other workspace data that impacts the branch experience.
            // (Services, authors/permissions often impact what a branch can do/render.)
            const tasks: Array<() => Promise<unknown>> = [];

            if (includeWorkspaceData) {
                tasks.push(() => refreshAuthors());
                tasks.push(() => refreshPermissions());
                tasks.push(() => refreshServices());
            }

            tasks.push(() => refreshBranchLocalContext(branchId, tolerant));

            await runtime.runTasks(tasks, tolerant);
        },
        [
            getCurrentBranchId,
            runtime,
            refreshAuthors,
            refreshPermissions,
            refreshServices,
            refreshBranchLocalContext,
        ],
    );

    const refreshAll = React.useCallback(
        async (opts?: { strict?: boolean }): Promise<RunResult> => {
            const tolerant: boolean = !(opts?.strict ?? false);

            // Avoid duplicate workspace refresh work:
            // refreshAll() does workspace-wide first, then branch-local only.
            const branchId: string | undefined = getCurrentBranchId();

            const tasks: Array<() => Promise<unknown>> = [
                () => refreshAuthors(),
                () => refreshPermissions(),
                () => refreshBranches(),
                () => refreshServices(),
            ];

            if (branchId) {
                tasks.push(() => refreshBranchLocalContext(branchId, tolerant));
            }

            return runtime.runTasks(tasks, tolerant);
        },
        [
            runtime,
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshServices,
            getCurrentBranchId,
            refreshBranchLocalContext,
            refreshComments,
            refreshPolicies,
        ],
    );

    const refreshSnapshotPointersWrapped = React.useCallback(
        async (
            opts?: Readonly<{ branchId?: string; strict?: boolean }>,
        ): Promise<void> => {
            const tolerant: boolean = !(opts?.strict ?? false);

            if (opts?.branchId) {
                await runtime.runTasks(
                    [
                        () =>
                            refreshSnapshotPointersForBranch(
                                opts.branchId as string,
                            ),
                    ],
                    tolerant,
                );
                return;
            }

            await runtime.runTasks([() => refreshSnapshotPointers()], tolerant);
        },
        [runtime, refreshSnapshotPointers, refreshSnapshotPointersForBranch],
    );

    return React.useMemo<WorkspaceRefreshApi>(
        () => ({
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers: refreshSnapshotPointersWrapped,
        }),
        [refreshAll, refreshBranchContext, refreshSnapshotPointersWrapped],
    );
}
```

---
#### 26


` File: src/react/workspace/context/provider/context.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/context.ts
import * as React from "react";
import type { WorkspaceAPI } from "./types";

export const WorkspaceContext = React.createContext<WorkspaceAPI | null>(null);

export function useWorkspace(): WorkspaceAPI {
    const ctx = React.useContext(WorkspaceContext);
    if (!ctx) {
        throw new Error(
            "useWorkspace() must be used under <WorkspaceProvider/>",
        );
    }
    return ctx;
}

export function useWorkspaceMaybe(): WorkspaceAPI | null {
    return React.useContext(WorkspaceContext);
}
```

---
#### 27


` File: src/react/workspace/context/provider/helpers.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/helpers.ts
import type { BackendError, LiveOptions } from "../backend";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import type { RunResult } from "./types";

// Stable default — avoids a new object per render
export const LIVE_OFF: LiveOptions = Object.freeze({ mode: "off" as const });

function isBackendErrorLike(e: unknown): e is BackendError {
    if (!e || typeof e !== "object") return false;
    const obj: Record<string, unknown> = e as Record<string, unknown>;
    return typeof obj.code === "string" && typeof obj.message === "string";
}

export function toBackendError(e: unknown): BackendError {
    if (isBackendErrorLike(e)) return e;

    // Preserve real Error information (without assuming BackendError supports extra fields)
    if (e instanceof Error) {
        const name: string = e.name || "Error";
        const msg: string = e.message || String(e);
        return {
            code: "runtime_error",
            message: `${name}: ${msg}`,
        };
    }

    if (typeof e === "string") {
        return { code: "unknown_error", message: e };
    }

    try {
        return { code: "unknown_error", message: JSON.stringify(e) };
    } catch {
        return { code: "unknown_error", message: String(e ?? "Unknown error") };
    }
}

/**
 * Sequential task runner (ordering preserved).
 * - tolerant=true: collects errors and continues
 * - tolerant=false: throws on first failure
 */
export async function runTasks(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    const errors: BackendError[] = [];
    for (const t of tasks) {
        try {
            await t();
        } catch (e) {
            if (!tolerant) throw e;
            errors.push(toBackendError(e));
        }
    }
    return errors.length ? { ok: false, errors } : { ok: true };
}

/**
 * Parallel task runner (ordering not guaranteed).
 * Kept separate so callers can choose intentionally.
 */
export async function runTasksParallel(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    if (tasks.length === 0) return { ok: true };

    const results: Array<{ ok: true } | { ok: false; error: BackendError }> =
        await Promise.all(
            tasks.map(async (t) => {
                try {
                    await t();
                    return { ok: true } as const;
                } catch (e) {
                    if (!tolerant) throw e;
                    return { ok: false, error: toBackendError(e) } as const;
                }
            }),
        );

    const errors: BackendError[] = results
        .filter((r) => !r.ok)
        .map((r) => (r as { ok: false; error: BackendError }).error);

    return errors.length ? { ok: false, errors } : { ok: true };
}

export function toServiceMap(
    input?: readonly DgpServiceCapability[] | DgpServiceMap | null,
): DgpServiceMap | null {
    if (!input) return null;

    if (Array.isArray(input)) {
        const out: Record<string, DgpServiceCapability> = Object.create(null);
        for (const s of input) out[s.id] = s;
        return out as unknown as DgpServiceMap;
    }

    return input as DgpServiceMap;
}
```

---
#### 28


` File: src/react/workspace/context/provider/live/adapters/manual.ts`  [↑ Back to top](#index)

```ts

```

---
#### 29


` File: src/react/workspace/context/provider/live/adapters/poll.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/live/adapters/poll.ts
import type { LiveOptions } from "../../../backend";
import type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterHandlers,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "../types";

export interface PollAdapterOptions {
    readonly defaultIntervalMs: number; // e.g. 15000
}

export function createPollAdapter(
    opts?: Partial<PollAdapterOptions>,
): WorkspaceLiveAdapter {
    const defaultIntervalMs: number = opts?.defaultIntervalMs ?? 15000;

    let intervalId: number | undefined;
    let connected: boolean = false;

    const disconnect = (): void => {
        if (typeof intervalId === "number") {
            window.clearInterval(intervalId);
        }
        intervalId = undefined;
        connected = false;
    };

    const connect = async (
        ctx: WorkspaceLiveAdapterContext,
        handlers: WorkspaceLiveAdapterHandlers,
    ): Promise<void> => {
        disconnect();

        const live: LiveOptions = ctx.live;

        if (live.mode !== "poll") {
            handlers.onStatus({ connected: false } as WorkspaceLiveStatus);
            return;
        }

        const intervalMs: number = live.intervalMs ?? defaultIntervalMs;

        connected = true;
        handlers.onStatus({ connected: true } as WorkspaceLiveStatus);

        const tickOnce = async (
            reason: WorkspaceLiveTick["reason"],
        ): Promise<void> => {
            const tick: WorkspaceLiveTick = {
                at: Date.now(),
                reason,
            };
            handlers.onTick(tick);
        };

        // immediate tick
        await tickOnce("init");

        intervalId = window.setInterval(() => {
            void tickOnce("timer");
        }, intervalMs) as unknown as number;
    };

    return {
        id: "poll",
        connect,
        disconnect,
    };
}
```

---
#### 30


` File: src/react/workspace/context/provider/live/adapters/sse.ts`  [↑ Back to top](#index)

```ts

```

---
#### 31


` File: src/react/workspace/context/provider/live/adapters/ws.ts`  [↑ Back to top](#index)

```ts

```

---
#### 32


` File: src/react/workspace/context/provider/live/types.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/live/types.ts
import type { BackendError, LiveOptions } from "../../backend";
import type { RunResult } from "../types";

/**
 * The “tick” is the only thing the adapter *must* emit.
 * You can treat any WS/SSE message as a tick initially,
 * and later introduce selective refresh events.
 */
export interface WorkspaceLiveTick {
    readonly at: number;
    readonly reason:
        | "init"
        | "timer"
        | "message"
        | "manual"
        | "reconnect"
        | "unknown";
}

export interface WorkspaceLiveStatus {
    readonly connected: boolean;
    readonly lastEventAt?: number;
    readonly lastError?: BackendError;
}

export interface WorkspaceLiveAdapterContext {
    readonly workspaceId: string;
    readonly actorId: string;

    readonly live: LiveOptions;

    /** current branch (if any) */
    readonly getCurrentBranchId: () => string | undefined;

    /**
     * “What to do” is owned by the provider (refresh semantics).
     * “When to do it” is owned by the adapter (poll/ws/sse/etc).
     */
    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;

    /** Optional: adapters can use these for lighter refresh policies later */
    readonly refreshBranchContext?: () => Promise<void>;
    readonly refreshSnapshotPointers?: () => Promise<void>;
}

export interface WorkspaceLiveAdapterHandlers {
    readonly onTick: (tick: WorkspaceLiveTick) => void;
    readonly onStatus: (status: WorkspaceLiveStatus) => void;
}

export interface WorkspaceLiveAdapter {
    /** A stable id (e.g. "poll", "ws", "sse") */
    readonly id: string;

    connect(
        ctx: WorkspaceLiveAdapterContext,
        handlers: WorkspaceLiveAdapterHandlers,
    ): void | Promise<void>;

    disconnect(): void;

    /**
     * Optional: allow branch changes / live option changes without reconnect.
     * If not implemented, the runner will disconnect+connect when key changes.
     */
    update?(ctx: WorkspaceLiveAdapterContext): void;
}

export type WorkspaceLiveAdapterFactory = () => WorkspaceLiveAdapter;

export type WorkspaceLiveAdapterRegistry = Readonly<
    Record<string, WorkspaceLiveAdapterFactory>
>;
```

---
#### 33


` File: src/react/workspace/context/provider/provider.tsx`  [↑ Back to top](#index)

```tsx
// src/react/workspace/context/provider/provider.tsx
import * as React from "react";
import type {
    LiveOptions,
    MergeResult,
    Result,
    TemplatesListParams,
} from "../backend";
import type { DgpServiceMap } from "@/schema/provider";

import { WorkspaceContext } from "@/react";
import type { WorkspaceAPI, WorkspaceProviderProps } from "./types";
import { LIVE_OFF } from "./helpers";

import { useBackendRuntime } from "./runtime/use-backend-runtime";

import { useAuthorsSlice } from "./slices/use-authors-slice";
import { usePermissionsSlice } from "./slices/use-permissions-slice";
import { useBranchesSlice } from "./slices/use-branches-slice";
import { useTemplatesSlice } from "./slices/use-templates-slice";
import { useServicesSlice } from "./slices/use-services-slice";
import { useSnapshotsSlice } from "./slices/use-snapshots-slice";
import { useCommentsSlice } from "./slices/use-comments-slice";
import { useBranchCache } from "./compose/use-branch-cache";
import { useWorkspaceRefresh } from "./compose/use-workspace-refresh";
import { useLivePolling } from "./compose/use-live-polling";
import { usePoliciesSlice } from "@/react/workspace/context/provider/slices/use-policies-slice";

/* ---------------- provider (thin composition root) ---------------- */

export function WorkspaceProvider(
    props: WorkspaceProviderProps,
): React.JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain = true,
        live: liveProp,
        autosaveMs = 9000,
        autoAutosave = true,
        children,
        liveAdapters,
        liveDebounceMs = 250,
    } = props;

    const runtime = useBackendRuntime();

    const workspaceId: string = backend.info.id;
    const live: LiveOptions = liveProp ?? LIVE_OFF;

    const authorsSlice = useAuthorsSlice({
        backend,
        workspaceId,
        initialAuthors: initial?.authors ?? null,
        runtime,
    });

    const permissionsSlice = usePermissionsSlice({
        backend,
        workspaceId,
        actor,
        initialPermissions: initial?.permissions ?? null,
        runtime,
    });

    const branchesSlice = useBranchesSlice({
        backend,
        workspaceId,
        ensureMain,
        initialBranches: initial?.branches ?? [],
        initialMainId: initial?.mainId,
        initialCurrentId: initial?.currentBranchId ?? initial?.mainId,
        initialParticipants: initial?.participants ?? null,
        runtime,
    });

    const getCurrentBranchId = React.useCallback(
        (): string | undefined => branchesSlice.branches.currentId,
        [branchesSlice.branches.currentId],
    );

    const templatesSlice = useTemplatesSlice({
        backend,
        workspaceId,
        getCurrentBranchId,
        initialTemplates: initial?.templates ?? null,
        runtime,
    });

    const servicesSlice = useServicesSlice({
        backend,
        workspaceId,
        initialServices: (initial?.services as DgpServiceMap | null) ?? null,
        runtime,
    });

    const snapshotsSlice = useSnapshotsSlice({
        backend,
        workspaceId,
        actor,
        getCurrentBranchId,
        initialSnapshot: initial?.snapshot
            ? {
                  schema_version: initial.snapshot.schema_version,
                  data: initial.snapshot.data as any,
              }
            : null,
        initialHead: initial?.head,
        initialDraft: initial?.draft,
        autosaveMs,
        autoAutosave,
        runtime,
    });

    const branchCache = useBranchCache(workspaceId);

    const comments = useCommentsSlice({
        backend: backend.comments,
        workspaceId,
        actorId: actor.id,
        getCurrentBranchId,
        initialThreads: initial?.comments,
    });

    const policiesSlice = usePoliciesSlice({
        backend,
        workspaceId,
        actorId: actor.id,
        getCurrentBranchId,
        initialPolicies: initial?.policies ?? null, // if you add it to initial
        runtime,
    });

    const refresh = useWorkspaceRefresh({
        runtime,
        refreshAuthors: authorsSlice.refreshAuthors,
        refreshPermissions: permissionsSlice.refreshPermissions,
        refreshBranches: branchesSlice.refreshBranches,
        refreshServices: servicesSlice.refreshServices,
        refreshPolicies: policiesSlice.refreshPolicies,
        refreshComments: comments.refreshThreads,
        getCurrentBranchId,
        refreshTemplates: async (p?: Partial<{ branchId: string }>) => {
            await templatesSlice.refreshTemplates(
                p?.branchId
                    ? ({ branchId: p.branchId } as Partial<
                          Pick<TemplatesListParams, "branchId">
                      >)
                    : undefined,
            );
        },
        refreshParticipants: async (p?: Partial<{ branchId: string }>) => {
            await branchesSlice.refreshParticipants(
                p?.branchId
                    ? ({ branchId: p.branchId } as Partial<{
                          branchId: string;
                      }>)
                    : undefined,
            );
        },
        refreshSnapshotPointersForBranch:
            snapshotsSlice.refreshSnapshotPointersForBranch,
        refreshSnapshotPointers: snapshotsSlice.refreshSnapshotPointers,
    });

    const hasAnyData: boolean = Boolean(
        (authorsSlice.authors.data && authorsSlice.authors.data.length) ||
            (branchesSlice.branches.data &&
                branchesSlice.branches.data.length) ||
            (templatesSlice.templates.data &&
                templatesSlice.templates.data.length) ||
            (branchesSlice.participants.data &&
                branchesSlice.participants.data.length) ||
            snapshotsSlice.snapshot.data?.props,
    );

    const liveCtl = useLivePolling({
        live,
        workspaceId,
        actor,
        hasAnyData,
        getCurrentBranchId: () => branchesSlice.branches.currentId,
        refreshAll: refresh.refreshAll,
        refreshBranchContext: refresh.refreshBranchContext,
        refreshSnapshotPointers: refresh.refreshSnapshotPointers,
        adapters: liveAdapters,
        debounceMs: liveDebounceMs,
    });

    /* ---------------- branch ops ---------------- */

    const createBranch = React.useCallback<WorkspaceAPI["createBranch"]>(
        async (name: string, opts?: Readonly<{ fromId?: string }>) => {
            const res = await backend.branches.create(workspaceId, name, opts);
            if (res.ok) {
                await branchesSlice.refreshBranches();
                setCurrentBranch(res.value.id);
            }
            return res;
        },
        [backend.branches, workspaceId, branchesSlice /* setCurrentBranch */],
    );

    const setMain = React.useCallback<WorkspaceAPI["setMain"]>(
        async (branchId: string) => {
            const res = await backend.branches.setMain(workspaceId, branchId);
            if (res.ok) await branchesSlice.refreshBranches();
            return res;
        },
        [backend.branches, workspaceId, branchesSlice],
    );

    const mergeBranch = React.useCallback<WorkspaceAPI["mergeBranch"]>(
        async (sourceId: string, targetId: string): Result<MergeResult> => {
            const res = await backend.branches.merge(
                workspaceId,
                sourceId,
                targetId,
            );
            if (res.ok) {
                await runtime.runTasks(
                    [
                        () => branchesSlice.refreshBranches(),
                        () => refresh.refreshBranchContext(),
                    ],
                    true,
                );
            }
            return res;
        },
        [backend.branches, workspaceId, runtime, branchesSlice, refresh],
    );

    const deleteBranch = React.useCallback<WorkspaceAPI["deleteBranch"]>(
        async (branchId: string) => {
            const res = await backend.branches.delete(workspaceId, branchId);
            if (res.ok) {
                await branchesSlice.refreshBranches();

                if (branchesSlice.branches.currentId === branchId) {
                    const fallback: string | undefined =
                        branchesSlice.branches.data.find(
                            (b) => b.id !== branchId,
                        )?.id;

                    if (fallback) setCurrentBranch(fallback);
                }
            }
            return res;
        },
        [backend.branches, workspaceId, branchesSlice /* setCurrentBranch */],
    );

    /* ---------------- branch switching (cache-first) ---------------- */

    const hasInitialSnapshot: boolean = Boolean(initial?.snapshot);

    const setCurrentBranch = React.useCallback(
        (id: string): void => {
            const prevId: string | undefined = branchesSlice.branches.currentId;

            branchCache.switchBranch({
                workspaceId: workspaceId,
                nextId: id,
                prevId,

                templates: templatesSlice.templates,
                participants: branchesSlice.participants,
                snapshot: snapshotsSlice.snapshot,

                setTemplates: templatesSlice.__setTemplatesState,
                setParticipants: branchesSlice.__setParticipantsState,
                setSnapshot: snapshotsSlice.__setSnapshotState,

                resetTemplates: templatesSlice.resetTemplatesForBranch,
                resetParticipants: () => {
                    branchesSlice.__setParticipantsState((s) => ({
                        ...s,
                        data: null,
                        error: undefined,
                    }));
                },
                resetSnapshot: snapshotsSlice.resetSnapshotForBranch,

                setCurrentBranchId: branchesSlice.setCurrentBranchId,

                hasInitialSnapshot,

                loadSnapshotForBranch: (branchId: string) => {
                    void snapshotsSlice.loadSnapshotForBranch(branchId);
                },
            });
        },
        [
            branchesSlice.branches.currentId,
            branchesSlice.participants,
            branchesSlice.setCurrentBranchId,
            branchesSlice.__setParticipantsState,
            templatesSlice.templates,
            templatesSlice.__setTemplatesState,
            templatesSlice.resetTemplatesForBranch,
            snapshotsSlice.snapshot,
            snapshotsSlice.__setSnapshotState,
            snapshotsSlice.resetSnapshotForBranch,
            snapshotsSlice.loadSnapshotForBranch,
            branchCache,
            hasInitialSnapshot,
        ],
    );

    /* ---------------- cache invalidation ---------------- */

    const invalidate = React.useCallback<WorkspaceAPI["invalidate"]>(
        (keys) => {
            const setAll: boolean = !keys || keys.length === 0;

            if (setAll || keys?.includes("authors"))
                authorsSlice.invalidateAuthors();
            if (setAll || keys?.includes("permissions"))
                permissionsSlice.invalidatePermissions();
            if (setAll || keys?.includes("branches"))
                branchesSlice.invalidateBranches();
            if (setAll || keys?.includes("services"))
                servicesSlice.invalidateServices();

            if (setAll || keys?.includes("templates"))
                templatesSlice.invalidateTemplates();
            if (setAll || keys?.includes("participants"))
                branchesSlice.invalidateParticipants();

            if (
                setAll ||
                keys?.includes("templates") ||
                keys?.includes("participants")
            ) {
                branchCache.clear();
            }
            if (setAll || keys?.includes("policies"))
                policiesSlice.invalidatePolicies();

        },
        [
            authorsSlice,
            permissionsSlice,
            branchesSlice,
            servicesSlice,
            templatesSlice,
            branchCache,
        ],
    );

    /* ---------------- memo API ---------------- */

    const api: WorkspaceAPI = React.useMemo<WorkspaceAPI>(
        () => ({
            info: backend.info,
            actor,

            authors: authorsSlice.authors,
            permissions: permissionsSlice.permissions,
            branches: branchesSlice.branches,

            templates: templatesSlice.templates,
            participants: branchesSlice.participants,
            services: servicesSlice.services,

            refresh: {
                all: refresh.refreshAll,

                authors: authorsSlice.refreshAuthors,
                permissions: permissionsSlice.refreshPermissions,
                branches: branchesSlice.refreshBranches,
                services: servicesSlice.refreshServices,

                branchContext: refresh.refreshBranchContext,

                templates: async (
                    params?: Partial<
                        Pick<TemplatesListParams, "branchId" | "since">
                    >,
                ) => templatesSlice.refreshTemplates(params),

                participants: async (
                    params?: Partial<{
                        branchId: string;
                        since?: number | string;
                    }>,
                ) => branchesSlice.refreshParticipants(params),

                snapshotPointers: refresh.refreshSnapshotPointers,
                policies: () => policiesSlice.refreshPolicies(),
            },

            setCurrentBranch,

            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            createTemplate: templatesSlice.createTemplate,
            updateTemplate: templatesSlice.updateTemplate,
            cloneTemplate: templatesSlice.cloneTemplate,
            publishTemplate: templatesSlice.publishTemplate,
            unpublishTemplate: templatesSlice.unpublishTemplate,
            deleteTemplate: templatesSlice.deleteTemplate,

            invalidate,

            live: {
                connected: liveCtl.connected,
                lastEventAt: liveCtl.lastEventAt,
                connect: liveCtl.connect,
                disconnect: liveCtl.disconnect,
            },

            snapshot: {
                state: snapshotsSlice.snapshot.state,
                saving: snapshotsSlice.snapshot.saving,
                dirty: snapshotsSlice.snapshot.dirty,
                head: snapshotsSlice.snapshot.head,
                draft: snapshotsSlice.snapshot.draft,
                schemaVersion: snapshotsSlice.snapshot.schemaVersion,
                data: snapshotsSlice.snapshot.data,
                lastSavedAt: snapshotsSlice.snapshot.lastSavedAt,
                lastDraftAt: snapshotsSlice.snapshot.lastDraftAt,

                set: snapshotsSlice.setSnapshotData,
                load: snapshotsSlice.loadSnapshot,
                refresh: snapshotsSlice.refreshSnapshotPointers,

                autosave: snapshotsSlice.autosave,
                save: snapshotsSlice.save,
                publish: snapshotsSlice.publish,
                discardDraft: snapshotsSlice.discardDraft,
            },
            comments: {
                threads: comments.threads,
                refreshThreads: comments.refreshThreads,
                createThread: comments.createThread,
                addMessage: comments.addMessage,
                editMessage: comments.editMessage,
                deleteMessage: comments.deleteMessage,
                moveThread: comments.moveThread,
                resolveThread: comments.resolveThread,
                deleteThread: comments.deleteThread,
            },
            policies: policiesSlice,
        }),
        [
            backend.info,
            actor,

            authorsSlice.authors,
            authorsSlice.refreshAuthors,

            permissionsSlice.permissions,
            permissionsSlice.refreshPermissions,

            branchesSlice.branches,
            branchesSlice.participants,
            branchesSlice.refreshBranches,
            branchesSlice.refreshParticipants,

            templatesSlice.templates,
            templatesSlice.refreshTemplates,
            templatesSlice.createTemplate,
            templatesSlice.updateTemplate,
            templatesSlice.cloneTemplate,
            templatesSlice.publishTemplate,
            templatesSlice.unpublishTemplate,
            templatesSlice.deleteTemplate,

            servicesSlice.services,
            servicesSlice.refreshServices,

            refresh.refreshAll,
            refresh.refreshBranchContext,
            refresh.refreshSnapshotPointers,

            setCurrentBranch,

            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            invalidate,

            liveCtl.connected,
            liveCtl.lastEventAt,

            snapshotsSlice.snapshot,
            snapshotsSlice.setSnapshotData,
            snapshotsSlice.loadSnapshot,
            snapshotsSlice.refreshSnapshotPointers,
            snapshotsSlice.autosave,
            snapshotsSlice.save,
            snapshotsSlice.publish,
            snapshotsSlice.discardDraft,
        ],
    );

    return (
        <WorkspaceContext.Provider value={api}>
            {children}
        </WorkspaceContext.Provider>
    );
}
```

---
#### 34


` File: src/react/workspace/context/provider/runtime/use-backend-runtime.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/runtime/use-backend-runtime.ts
import * as React from "react";
import type { BackendError } from "../../backend";
import type { RunResult } from "../types";
import {
    runTasks as runTasksBase,
    toBackendError as toBackendErrorBase,
} from "../helpers";

export interface BackendRuntime {
    readonly now: () => number;
    readonly toBackendError: (e: unknown) => BackendError;
    readonly runTasks: (
        tasks: Array<() => Promise<unknown>>,
        tolerant: boolean,
    ) => Promise<RunResult>;
}

export function useBackendRuntime(): BackendRuntime {
    const now = React.useCallback((): number => Date.now(), []);

    const toBackendError = React.useCallback(
        (e: unknown): BackendError => toBackendErrorBase(e),
        [],
    );

    const runTasks = React.useCallback(
        async (
            tasks: Array<() => Promise<unknown>>,
            tolerant: boolean,
        ): Promise<RunResult> => runTasksBase(tasks, tolerant),
        [],
    );

    return React.useMemo<BackendRuntime>(
        () => ({ now, toBackendError, runTasks }),
        [now, toBackendError, runTasks],
    );
}
```

---
#### 35


` File: src/react/workspace/context/provider/slices/use-authors-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-authors-slice.ts
import * as React from "react";
import type { Author, BackendError, WorkspaceBackend } from "../../backend";
import type { Loadable } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface AuthorsSliceApi {
    readonly authors: Loadable<readonly Author[]>;
    readonly refreshAuthors: () => Promise<void>;
    readonly invalidateAuthors: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseAuthorsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly initialAuthors?: readonly Author[] | null;
    readonly runtime: BackendRuntime;
}

export function useAuthorsSlice(
    params: UseAuthorsSliceParams,
): AuthorsSliceApi {
    const { backend, workspaceId, initialAuthors, runtime } = params;

    const [authors, setAuthors] = React.useState<Loadable<readonly Author[]>>({
        data: initialAuthors ?? null,
        loading: false,
        updatedAt: initialAuthors ? runtime.now() : undefined,
    });

    const refreshAuthors = React.useCallback(async (): Promise<void> => {
        setAuthors((s) => ({ ...s, loading: true }));
        const res = await backend.authors.refresh(workspaceId);

        if (res.ok) {
            setAuthors({
                data: res.value,
                loading: false,
                updatedAt: runtime.now(),
            });
        } else {
            setLoadableError(setAuthors, res.error);
        }
    }, [backend.authors, workspaceId, runtime]);

    const invalidateAuthors = React.useCallback((): void => {
        setAuthors((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<AuthorsSliceApi>(
        () => ({ authors, refreshAuthors, invalidateAuthors }),
        [authors, refreshAuthors, invalidateAuthors],
    );
}
```

---
#### 36


` File: src/react/workspace/context/provider/slices/use-branches-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-branches-slice.ts
import * as React from "react";
import type {
    BackendError,
    Branch,
    BranchParticipant,
    WorkspaceBackend,
} from "../../backend";
import type { BranchesSlice, Loadable } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface BranchesSliceApi {
    readonly branches: BranchesSlice;
    readonly participants: Loadable<readonly BranchParticipant[]>;

    readonly setCurrentBranchId: (id: string) => void;

    readonly refreshBranches: () => Promise<void>;
    readonly refreshParticipants: (
        params?: Partial<{ branchId: string; since?: number | string }>,
    ) => Promise<void>;

    readonly invalidateBranches: () => void;
    readonly invalidateParticipants: () => void;

    /** internal setters for branch-cache composition */
    readonly __setParticipantsState: React.Dispatch<
        React.SetStateAction<Loadable<readonly BranchParticipant[]>>
    >;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseBranchesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;

    readonly ensureMain: boolean;

    readonly initialBranches?: readonly Branch[];
    readonly initialMainId?: string;
    readonly initialCurrentId?: string;
    readonly initialParticipants?: readonly BranchParticipant[] | null;

    readonly runtime: BackendRuntime;
}

export function useBranchesSlice(
    params: UseBranchesSliceParams,
): BranchesSliceApi {
    const {
        backend,
        workspaceId,
        ensureMain,
        initialBranches,
        initialMainId,
        initialCurrentId,
        initialParticipants,
        runtime,
    } = params;

    const [branches, setBranches] = React.useState<BranchesSlice>({
        data: initialBranches ?? [],
        mainId: initialMainId,
        currentId: initialCurrentId ?? initialMainId,
        loading: false,
        updatedAt: initialBranches ? runtime.now() : undefined,
    });

    const [participants, setParticipants] = React.useState<
        Loadable<readonly BranchParticipant[]>
    >({
        data: initialParticipants ?? null,
        loading: false,
        updatedAt: initialParticipants ? runtime.now() : undefined,
    });

    // Ensure main branch pointer is stable (same behavior as old provider)
    React.useEffect((): void => {
        if (!ensureMain) return;
        if (branches.data.length === 0) return;

        const existingMain: string | undefined = branches.data.find(
            (b) => b.isMain,
        )?.id;

        if (existingMain && branches.mainId !== existingMain) {
            setBranches((s) => ({
                ...s,
                mainId: existingMain,
                currentId: s.currentId ?? existingMain,
            }));
            return;
        }

        if (!existingMain) {
            const first: string | undefined = branches.data[0]?.id;
            if (first && !branches.currentId) {
                setBranches((s) => ({ ...s, currentId: first }));
            }
        }
    }, [branches.data, branches.mainId, branches.currentId, ensureMain]);

    const setCurrentBranchId = React.useCallback((id: string): void => {
        setBranches((s) => ({ ...s, currentId: id }));
    }, []);

    const refreshBranches = React.useCallback(async (): Promise<void> => {
        setBranches((s) => ({ ...s, loading: true }));
        const res = await backend.branches.refresh(workspaceId);

        if (!res.ok) {
            setBranches((s) => ({ ...s, loading: false, error: res.error }));
            return;
        }

        const data: readonly Branch[] = res.value;
        const main: string | undefined = data.find((b) => b.isMain)?.id;

        setBranches((s) => {
            const currentStillExists: boolean =
                Boolean(s.currentId) && data.some((b) => b.id === s.currentId);

            const nextCurrent: string | undefined = currentStillExists
                ? s.currentId
                : (main ?? data[0]?.id);

            return {
                data,
                mainId: main ?? s.mainId,
                currentId: nextCurrent,
                loading: false,
                updatedAt: runtime.now(),
            };
        });
    }, [backend.branches, workspaceId, runtime]);

    const refreshParticipants = React.useCallback(
        async (
            params?: Partial<{ branchId: string; since?: number | string }>,
        ): Promise<void> => {
            const branchId: string | undefined =
                params?.branchId ?? branches.currentId;
            if (!branchId) return;

            setParticipants((s) => ({ ...s, loading: true }));

            const res = await backend.access.refreshParticipants(
                workspaceId,
                branchId,
                { since: params?.since ?? participants.updatedAt },
            );

            if (res.ok) {
                setParticipants({
                    data: res.value,
                    loading: false,
                    updatedAt: runtime.now(),
                });
            } else {
                setLoadableError(setParticipants, res.error);
            }
        },
        [
            backend.access,
            workspaceId,
            branches.currentId,
            participants.updatedAt,
            runtime,
        ],
    );

    const invalidateBranches = React.useCallback((): void => {
        setBranches((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    const invalidateParticipants = React.useCallback((): void => {
        setParticipants((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<BranchesSliceApi>(
        () => ({
            branches,
            participants,
            setCurrentBranchId,
            refreshBranches,
            refreshParticipants,
            invalidateBranches,
            invalidateParticipants,
            __setParticipantsState: setParticipants,
        }),
        [
            branches,
            participants,
            setCurrentBranchId,
            refreshBranches,
            refreshParticipants,
            invalidateBranches,
            invalidateParticipants,
        ],
    );
}
```

---
#### 37


` File: src/react/workspace/context/provider/slices/use-comments-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-comments-slice.ts

import * as React from "react";

import type {
    BackendError,
    BackendScope,
    Result,
    WorkspaceBackend,
} from "../../backend";
import type { Loadable } from "@/react";

import type {
    CommentAnchor,
    CommentMessage,
    CommentThread,
} from "@/schema/comments";

export interface CommentsSliceApi {
    readonly threads: Loadable<readonly CommentThread[]>;

    readonly refreshThreads: (
        params?: Readonly<{ branchId?: string }>,
    ) => Promise<void>;

    readonly createThread: (
        input: Readonly<{
            anchor: CommentAnchor;
            body: string;
            meta?: Readonly<Record<string, unknown>>;
            branchId?: string;
        }>,
    ) => Result<CommentThread>;

    readonly addMessage: (
        input: Readonly<{
            threadId: string;
            body: string;
            meta?: Readonly<Record<string, unknown>>;
            branchId?: string;
        }>,
    ) => Result<CommentMessage>;

    readonly editMessage: (
        input: Readonly<{
            threadId: string;
            messageId: string;
            body: string;
            branchId?: string;
        }>,
    ) => Result<CommentMessage>;

    readonly deleteMessage: (
        input: Readonly<{
            threadId: string;
            messageId: string;
            branchId?: string;
        }>,
    ) => Result<void>;

    readonly moveThread: (
        input: Readonly<{
            threadId: string;
            anchor: CommentAnchor;
            branchId?: string;
        }>,
    ) => Result<CommentThread>;

    readonly resolveThread: (
        input: Readonly<{
            threadId: string;
            resolved: boolean;
            branchId?: string;
        }>,
    ) => Result<CommentThread>;

    readonly deleteThread: (
        input: Readonly<{
            threadId: string;
            branchId?: string;
        }>,
    ) => Result<void>;
}

export interface UseCommentsSliceParams {
    readonly actorId: string;
    readonly workspaceId: string;

    /** backend.comments */
    readonly backend: WorkspaceBackend["comments"];

    /** Current branch resolver (provider owns currentId) */
    readonly getCurrentBranchId: () => string | undefined;

    /** Optional initial preload */
    readonly initialThreads?: readonly CommentThread[] | null;
}

function missingScopeError<T>(): Result<T> {
    return Promise.resolve({
        ok: false,
        error: {
            code: "missing_scope",
            message:
                "Workspace comments require workspaceId, actorId, and branchId.",
        },
    });
}

function setLoadableError<T>(
    set: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    err: BackendError,
): void {
    set((s: Loadable<T>) => ({ ...s, loading: false, error: err }));
}

export function useCommentsSlice(
    params: UseCommentsSliceParams,
): CommentsSliceApi {
    const {
        backend,
        workspaceId,
        actorId,
        getCurrentBranchId,
        initialThreads,
    } = params;

    const now = (): number => Date.now();

    const [threads, setThreads] = React.useState<
        Loadable<readonly CommentThread[]>
    >({
        data: initialThreads ?? null,
        loading: false,
        updatedAt: initialThreads ? now() : undefined,
    });

    const resolveScope = React.useCallback(
        (branchId?: string): BackendScope | null => {
            const bid: string | undefined = branchId ?? getCurrentBranchId();
            if (!workspaceId || !actorId || !bid) return null;
            return { workspaceId, actorId, branchId: bid };
        },
        [workspaceId, actorId, getCurrentBranchId],
    );

    const refreshThreads = React.useCallback(
        async (p?: Readonly<{ branchId?: string }>): Promise<void> => {
            const scope: BackendScope | null = resolveScope(p?.branchId);
            if (!scope) return;

            setThreads((s) => ({ ...s, loading: true }));
            const res = await backend.listThreads(scope);

            if (res.ok) {
                setThreads({
                    data: res.value as readonly CommentThread[],
                    loading: false,
                    updatedAt: now(),
                });
            } else {
                setLoadableError(setThreads, res.error);
            }
        },
        [backend, resolveScope],
    );

    const createThread = React.useCallback(
        async (
            input: Readonly<{
                anchor: CommentAnchor;
                body: string;
                meta?: Readonly<Record<string, unknown>>;
                branchId?: string;
            }>,
        ): Result<CommentThread> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<CommentThread>();

            const res = await backend.createThread(scope, {
                anchor: input.anchor,
                body: input.body,
                meta: input.meta ? { ...input.meta } : undefined,
            });

            if (res.ok) {
                setThreads((s) => {
                    const prev: readonly CommentThread[] = s.data ?? [];
                    return {
                        ...s,
                        data: [res.value as CommentThread, ...prev],
                        loading: false,
                        updatedAt: now(),
                    };
                });
            }

            return res as unknown as Result<CommentThread>;
        },
        [backend, resolveScope],
    );

    const addMessage = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                body: string;
                meta?: Readonly<Record<string, unknown>>;
                branchId?: string;
            }>,
        ): Result<CommentMessage> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<CommentMessage>();

            const res = await backend.addMessage(scope, {
                threadId: input.threadId,
                body: input.body,
                meta: input.meta ? { ...input.meta } : undefined,
            });

            if (res.ok) {
                const msg: CommentMessage = res.value as CommentMessage;

                setThreads((s) => {
                    if (!s.data) return s;

                    const next: readonly CommentThread[] = s.data.map((t) => {
                        if (t.id !== input.threadId) return t;
                        const msgs: readonly CommentMessage[] = (t.messages ??
                            []) as readonly CommentMessage[];
                        return { ...t, messages: [...msgs, msg] };
                    });

                    return { ...s, data: next, updatedAt: now() };
                });
            }

            return res as unknown as Result<CommentMessage>;
        },
        [backend, resolveScope],
    );

    const editMessage = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                messageId: string;
                body: string;
                branchId?: string;
            }>,
        ): Result<CommentMessage> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<CommentMessage>();

            const res = await backend.editMessage(scope, {
                threadId: input.threadId,
                messageId: input.messageId,
                body: input.body,
            });

            if (res.ok) {
                const msg: CommentMessage = res.value as CommentMessage;

                setThreads((s) => {
                    if (!s.data) return s;
                    const next: readonly CommentThread[] = s.data.map((t) => {
                        if (t.id !== input.threadId) return t;
                        const msgs: readonly CommentMessage[] = (t.messages ??
                            []) as readonly CommentMessage[];
                        const updated: readonly CommentMessage[] = msgs.map(
                            (m) => (m.id === input.messageId ? msg : m),
                        );
                        return { ...t, messages: updated } as CommentThread;
                    });

                    return { ...s, data: next, updatedAt: now() };
                });
            }

            return res as unknown as Result<CommentMessage>;
        },
        [backend, resolveScope],
    );

    const deleteMessage = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                messageId: string;
                branchId?: string;
            }>,
        ): Result<void> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<void>();

            const res = await backend.deleteMessage(scope, {
                threadId: input.threadId,
                messageId: input.messageId,
            });

            if (res.ok) {
                setThreads((s) => {
                    if (!s.data) return s;

                    const next: readonly CommentThread[] = s.data.map((t) => {
                        if (t.id !== input.threadId) return t;
                        const msgs: readonly CommentMessage[] = (t.messages ??
                            []) as readonly CommentMessage[];
                        return {
                            ...t,
                            messages: msgs.filter(
                                (m) => m.id !== input.messageId,
                            ),
                        };
                    });

                    return { ...s, data: next, updatedAt: now() };
                });
            }

            return res as unknown as Result<void>;
        },
        [backend, resolveScope],
    );

    const updateThread = React.useCallback((thread: CommentThread) => {
        setThreads((s) => {
            if (!s.data) return s;
            return {
                ...s,
                data: s.data.map((t) => (t.id === thread.id ? thread : t)),
                updatedAt: now(),
            };
        });
    }, []);

    const moveThread = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                anchor: CommentAnchor;
                branchId?: string;
            }>,
        ): Result<CommentThread> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<CommentThread>();

            const res = await backend.moveThread(scope, {
                threadId: input.threadId,
                anchor: input.anchor,
            });

            if (res.ok) {
                updateThread(res.value as CommentThread);
            }

            return res as unknown as Result<CommentThread>;
        },
        [backend, resolveScope, updateThread],
    );

    const resolveThread = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                resolved: boolean;
                branchId?: string;
            }>,
        ): Result<CommentThread> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<CommentThread>();

            const res = await backend.resolveThread(scope, {
                threadId: input.threadId,
                resolved: input.resolved,
            });

            if (res.ok) {
                updateThread(res.value as CommentThread);
            }

            return res as unknown as Result<CommentThread>;
        },
        [backend, resolveScope, updateThread],
    );

    const deleteThread = React.useCallback(
        async (
            input: Readonly<{
                threadId: string;
                branchId?: string;
            }>,
        ): Result<void> => {
            const scope: BackendScope | null = resolveScope(input.branchId);
            if (!scope) return missingScopeError<void>();

            const res = await backend.deleteThread(scope, {
                threadId: input.threadId,
            });

            if (res.ok) {
                setThreads((s) => {
                    if (!s.data) return s;
                    return {
                        ...s,
                        data: s.data.filter((t) => t.id !== input.threadId),
                        updatedAt: now(),
                    };
                });
            }

            return res as unknown as Result<void>;
        },
        [backend, resolveScope],
    );

    return React.useMemo(
        () => ({
            threads,
            refreshThreads,
            createThread,
            addMessage,
            editMessage,
            deleteMessage,
            moveThread,
            resolveThread,
            deleteThread,
        }),
        [
            threads,
            refreshThreads,
            createThread,
            addMessage,
            editMessage,
            deleteMessage,
            moveThread,
            resolveThread,
            deleteThread,
        ],
    );
}
```

---
#### 38


` File: src/react/workspace/context/provider/slices/use-permissions-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-permissions-slice.ts
import * as React from "react";
import type {
    Actor,
    BackendError,
    PermissionsMap,
    WorkspaceBackend,
} from "../../backend";
import type { Loadable } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface PermissionsSliceApi {
    readonly permissions: Loadable<PermissionsMap>;
    readonly refreshPermissions: () => Promise<void>;
    readonly invalidatePermissions: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UsePermissionsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly actor: Actor;
    readonly initialPermissions?: PermissionsMap | null;
    readonly runtime: BackendRuntime;
}

export function usePermissionsSlice(
    params: UsePermissionsSliceParams,
): PermissionsSliceApi {
    const { backend, workspaceId, actor, initialPermissions, runtime } = params;

    const [permissions, setPermissions] = React.useState<
        Loadable<PermissionsMap>
    >({
        data: initialPermissions ?? null,
        loading: false,
        updatedAt: initialPermissions ? runtime.now() : undefined,
    });

    const refreshPermissions = React.useCallback(async (): Promise<void> => {
        setPermissions((s) => ({ ...s, loading: true }));
        const res = await backend.permissions.refresh(workspaceId, actor);

        if (res.ok) {
            setPermissions({
                data: res.value,
                loading: false,
                updatedAt: runtime.now(),
            });
        } else {
            setLoadableError(setPermissions, res.error);
        }
    }, [backend.permissions, workspaceId, actor, runtime]);

    const invalidatePermissions = React.useCallback((): void => {
        setPermissions((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<PermissionsSliceApi>(
        () => ({ permissions, refreshPermissions, invalidatePermissions }),
        [permissions, refreshPermissions, invalidatePermissions],
    );
}
```

---
#### 39


` File: src/react/workspace/context/provider/slices/use-policies-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-policies-slice.ts
import * as React from "react";

import type { WorkspaceBackend, Result, BackendError } from "../../backend";
import type { Loadable } from "@/react";

import type { DynamicRule } from "@/schema/validation";
import { compilePolicies, type PolicyDiagnostic } from "@/core/policy";

/* ---------------- helpers ---------------- */

function idle<T>(data: T | null = null): Loadable<T> {
    return { state: "idle", data } as any;
}
function loading<T>(prev: Loadable<T>): Loadable<T> {
    return { ...prev, state: "loading", error: undefined } as any;
}
function ready<T>(data: T): Loadable<T> {
    return { state: "ready", data, error: undefined } as any;
}
function failed<T>(prev: Loadable<T>, error: BackendError): Loadable<T> {
    return { ...prev, state: "error", error } as any;
}

function missingBackendError(key: string): BackendError {
    return {
        code: "backend_missing",
        message: `WorkspaceBackend.policies.${key} is not implemented.`,
    };
}

/* ---------------- slice ---------------- */

export type PoliciesSlice = {
    readonly policies: Loadable<readonly DynamicRule[]>;
    readonly policyDiagnostics: Loadable<readonly PolicyDiagnostic[]>;

    /** internal state setters (for cache switching parity) */
    readonly __setPoliciesState: React.Dispatch<
        React.SetStateAction<Loadable<readonly DynamicRule[]>>
    >;
    readonly __setPolicyDiagnosticsState: React.Dispatch<
        React.SetStateAction<Loadable<readonly PolicyDiagnostic[]>>
    >;

    readonly invalidatePolicies: () => void;

    readonly refreshPolicies: (
        params?: Readonly<{ since?: number | string; branchId?: string }>,
    ) => Promise<void>;

    readonly savePolicies: (
        rules: readonly DynamicRule[],
        params?: Readonly<{ branchId?: string }>,
    ) => Result<Readonly<{ policies: readonly DynamicRule[] }>>;

    /** local-only compile helper for editor UIs */
    readonly compilePoliciesFromRaw: (raw: unknown) => Readonly<{
        policies: DynamicRule[];
        diagnostics: PolicyDiagnostic[];
    }>;
};

export function usePoliciesSlice(
    args: Readonly<{
        backend: WorkspaceBackend;
        workspaceId: string;
        actorId: string;
        getCurrentBranchId: () => string | undefined;

        /** optional hydration */
        initialPolicies?: readonly DynamicRule[] | null;

        /** runtime is accepted for parity with other slices (not required here) */
        runtime?: unknown;
    }>,
): PoliciesSlice {
    const {
        backend,
        workspaceId,
        actorId,
        getCurrentBranchId,
        initialPolicies = null,
    } = args;

    const [policies, __setPoliciesState] = React.useState<
        Loadable<readonly DynamicRule[]>
    >(() => (initialPolicies ? ready(initialPolicies) : idle(null)) as any);

    const [policyDiagnostics, __setPolicyDiagnosticsState] = React.useState<
        Loadable<readonly PolicyDiagnostic[]>
    >(() => idle([]));

    const invalidatePolicies = React.useCallback((): void => {
        __setPoliciesState((s) => idle(s.data ?? null));
        __setPolicyDiagnosticsState(() => idle([]));
    }, []);

    const refreshPolicies = React.useCallback(
        async (
            params?: Readonly<{ since?: number | string; branchId?: string }>,
        ): Promise<void> => {
            const branchId: string | undefined =
                params?.branchId ?? getCurrentBranchId();

            const api: any = (backend as any).policies;

            // Prefer refresh(); fallback to get()
            const fn: any = api?.refresh ?? api?.get;
            const fnKey: string = api?.refresh ? "refresh" : "get";

            if (!fn) {
                __setPoliciesState((s) =>
                    failed(s, missingBackendError(fnKey)),
                );
                return;
            }

            __setPoliciesState((s) => loading(s));

            const res = await fn({
                workspaceId,
                branchId,
                actorId,
                since: params?.since,
            });

            if (!res?.ok) {
                __setPoliciesState((s) =>
                    failed(s, res?.error ?? missingBackendError(fnKey)),
                );
                return;
            }

            const list: readonly DynamicRule[] = (res.value?.policies ??
                res.value ??
                []) as readonly DynamicRule[];

            __setPoliciesState(() => ready(list));
        },
        [backend, workspaceId, actorId, getCurrentBranchId],
    );

    const savePolicies = React.useCallback<PoliciesSlice["savePolicies"]>(
        async (rules, params) => {
            const branchId: string | undefined =
                params?.branchId ?? getCurrentBranchId();

            const api: any = (backend as any).policies;
            if (!api?.save) {
                const err = missingBackendError("save");
                __setPoliciesState((s) => failed(s, err));
                return { ok: false, error: err };
            }

            __setPoliciesState((s) => loading(s));

            const res = await api.save({
                workspaceId,
                branchId,
                actorId,
                policies: rules,
            });

            if (!res?.ok) {
                __setPoliciesState((s) =>
                    failed(s, res?.error ?? missingBackendError("save")),
                );
                return res;
            }

            const list: readonly DynamicRule[] = (res.value?.policies ??
                res.value ??
                rules) as readonly DynamicRule[];

            __setPoliciesState(() => ready(list));

            return {
                ok: true,
                value: { policies: list },
            };
        },
        [backend, workspaceId, actorId, getCurrentBranchId],
    );

    const compilePoliciesFromRaw = React.useCallback((raw: unknown) => {
        const { policies: compiled, diagnostics } = compilePolicies(raw);

        __setPoliciesState(() => ready(compiled));
        __setPolicyDiagnosticsState(() => ready(diagnostics));

        return { policies: compiled, diagnostics };
    }, []);

    return {
        policies,
        policyDiagnostics,

        __setPoliciesState,
        __setPolicyDiagnosticsState,

        invalidatePolicies,
        refreshPolicies,
        savePolicies,

        compilePoliciesFromRaw,
    };
}
```

---
#### 40


` File: src/react/workspace/context/provider/slices/use-services-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-services-slice.ts
import * as React from "react";
import type { BackendError, WorkspaceBackend } from "../../backend";
import type { DgpServiceMap } from "@/schema/provider";
import type { Loadable } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";
import { toServiceMap } from "../helpers";

export interface ServicesSliceApi {
    readonly services: Loadable<DgpServiceMap>;
    readonly refreshServices: () => Promise<void>;
    readonly invalidateServices: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseServicesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly initialServices?: DgpServiceMap | null;
    readonly runtime: BackendRuntime;
}

export function useServicesSlice(
    params: UseServicesSliceParams,
): ServicesSliceApi {
    const { backend, workspaceId, initialServices, runtime } = params;

    const [services, setServices] = React.useState<Loadable<DgpServiceMap>>({
        data: initialServices ?? null,
        loading: false,
        updatedAt: initialServices ? runtime.now() : undefined,
    });

    const refreshServices = React.useCallback(async (): Promise<void> => {
        setServices((s) => ({ ...s, loading: true }));

        const res = await backend.services.refresh(workspaceId, {
            since: services.updatedAt,
        });

        if (!res.ok) {
            setLoadableError(setServices, res.error);
            return;
        }

        const map: DgpServiceMap | null = toServiceMap(res.value);
        setServices({
            data: map ?? ({} as DgpServiceMap),
            loading: false,
            updatedAt: runtime.now(),
        });
    }, [backend.services, workspaceId, services.updatedAt, runtime]);

    const invalidateServices = React.useCallback((): void => {
        setServices((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<ServicesSliceApi>(
        () => ({ services, refreshServices, invalidateServices }),
        [services, refreshServices, invalidateServices],
    );
}
```

---
#### 41


` File: src/react/workspace/context/provider/slices/use-snapshots-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-snapshots-slice.ts
import * as React from "react";
import type {
    Actor,
    BackendError,
    Commit,
    Draft,
    Result,
    SnapshotsLoadResult,
    WorkspaceBackend,
} from "../../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { SnapshotSlice, WorkspaceAPI } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface SnapshotsSliceApi {
    readonly snapshot: SnapshotSlice;

    readonly loadSnapshotForBranch: (
        branchId: string,
        params?: Readonly<{ versionId?: string }>,
    ) => Result<SnapshotsLoadResult>;

    readonly loadSnapshot: WorkspaceAPI["snapshot"]["load"];
    readonly refreshSnapshotPointersForBranch: (
        branchId: string,
    ) => Promise<void>;
    readonly refreshSnapshotPointers: () => Promise<void>;

    readonly setSnapshotData: WorkspaceAPI["snapshot"]["set"];
    readonly autosave: WorkspaceAPI["snapshot"]["autosave"];
    readonly save: WorkspaceAPI["snapshot"]["save"];
    readonly publish: WorkspaceAPI["snapshot"]["publish"];
    readonly discardDraft: WorkspaceAPI["snapshot"]["discardDraft"];

    /** internal setters for branch-cache composition */
    readonly __setSnapshotState: React.Dispatch<
        React.SetStateAction<SnapshotSlice>
    >;

    readonly resetSnapshotForBranch: () => void;
}

function setSnapshotError(error: BackendError): {
    ok: false;
    error: BackendError;
} {
    return { ok: false, error };
}

export interface UseSnapshotsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly actor: Actor;

    readonly getCurrentBranchId: () => string | undefined;

    readonly initialSnapshot?: {
        schema_version: string;
        data: EditorSnapshot;
    } | null;
    readonly initialHead?: Commit;
    readonly initialDraft?: Draft;

    readonly autosaveMs: number;
    readonly autoAutosave: boolean;

    readonly runtime: BackendRuntime;
}

export function useSnapshotsSlice(
    params: UseSnapshotsSliceParams,
): SnapshotsSliceApi {
    const {
        backend,
        workspaceId,
        actor,
        getCurrentBranchId,
        initialSnapshot,
        initialHead,
        initialDraft,
        autosaveMs,
        autoAutosave,
        runtime,
    } = params;

    const [snapshot, setSnapshot] = React.useState<SnapshotSlice>({
        schemaVersion: initialSnapshot?.schema_version,
        data: initialSnapshot?.data as EditorSnapshot | undefined,
        head: initialHead,
        draft: initialDraft,
        state: initialDraft ? "uncommitted" : "clean",
        saving: false,
        dirty: false,
    });

    const autosaveTimerRef = React.useRef<number | null>(null);

    const loadSnapshotForBranch = React.useCallback(
        async (
            branchId: string,
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult> => {
            const res = await backend.snapshots.load({
                workspaceId,
                branchId,
                actorId: actor.id,
                versionId: params?.versionId,
            });

            if (res.ok) {
                const { head, draft, snapshot: snap } = res.value;
                setSnapshot({
                    schemaVersion: snap.schema_version,
                    data: snap.data,
                    head,
                    draft,
                    state: draft ? "uncommitted" : "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: undefined,
                    lastDraftAt: undefined,
                });
            }

            return res;
        },
        [backend.snapshots, workspaceId, actor.id],
    );

    const loadSnapshot = React.useCallback<WorkspaceAPI["snapshot"]["load"]>(
        async (params?: Readonly<{ versionId?: string }>) => {
            const branchId = getCurrentBranchId();
            if (!branchId) {
                return setSnapshotError({
                    code: "no_branch",
                    message: "No current branch to load snapshot from.",
                }) as unknown as Result<SnapshotsLoadResult>;
            }
            return loadSnapshotForBranch(branchId, params);
        },
        [getCurrentBranchId, loadSnapshotForBranch],
    );

    const setSnapshotData = React.useCallback<WorkspaceAPI["snapshot"]["set"]>(
        (
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void => {
            setSnapshot((s) => ({
                ...s,
                data: updater(s.data),
                state: s.draft ? "uncommitted" : "dirty",
                dirty: true,
            }));
        },
        [],
    );

    const refreshSnapshotPointersForBranch = React.useCallback(
        async (branchId: string): Promise<void> => {
            const res = await backend.snapshots.refresh({
                workspaceId,
                branchId,
                actorId: actor.id,
                since: snapshot.lastSavedAt ?? snapshot.lastDraftAt,
            });

            if (!res.ok) return;

            setSnapshot((s) => ({
                ...s,
                head: res.value.head ?? s.head,
                draft: res.value.draft,
                state: res.value.draft
                    ? "uncommitted"
                    : s.dirty
                      ? "dirty"
                      : "clean",
            }));
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            snapshot.lastSavedAt,
            snapshot.lastDraftAt,
        ],
    );

    const refreshSnapshotPointers =
        React.useCallback(async (): Promise<void> => {
            const branchId = getCurrentBranchId();
            if (!branchId) return;
            await refreshSnapshotPointersForBranch(branchId);
        }, [getCurrentBranchId, refreshSnapshotPointersForBranch]);

    const autosave = React.useCallback<
        WorkspaceAPI["snapshot"]["autosave"]
    >(async () => {
        const branchId = getCurrentBranchId();
        if (!branchId) {
            return setSnapshotError({
                code: "no_branch",
                message: "No current branch to autosave.",
            }) as any;
        }

        if (!snapshot.data || !snapshot.schemaVersion) {
            return setSnapshotError({
                code: "no_snapshot",
                message: "Nothing to autosave.",
            }) as any;
        }

        const res = await backend.snapshots.autosave({
            workspaceId,
            branchId,
            actorId: actor.id,
            snapshot: {
                schema_version: snapshot.schemaVersion,
                data: snapshot.data,
            },
            etag: snapshot.draft?.etag,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: res.value.draft,
                state: "uncommitted",
                dirty: false,
                lastDraftAt: runtime.now(),
            }));
        }

        return res;
    }, [
        backend.snapshots,
        workspaceId,
        actor.id,
        getCurrentBranchId,
        snapshot.data,
        snapshot.schemaVersion,
        snapshot.draft?.etag,
        runtime,
    ]);

    const save = React.useCallback<WorkspaceAPI["snapshot"]["save"]>(
        async (message?: string) => {
            const branchId = getCurrentBranchId();
            if (!branchId) {
                return setSnapshotError({
                    code: "no_branch",
                    message: "No current branch to save.",
                }) as any;
            }

            if (!snapshot.data || !snapshot.schemaVersion) {
                return setSnapshotError({
                    code: "no_snapshot",
                    message: "Nothing to save.",
                }) as any;
            }

            setSnapshot((s) => ({ ...s, state: "saving", saving: true }));

            const res = await backend.snapshots.save({
                workspaceId,
                branchId,
                actorId: actor.id,
                snapshot: {
                    schema_version: snapshot.schemaVersion,
                    data: snapshot.data,
                },
                message,
                draftId: snapshot.draft?.id,
                etag: snapshot.head?.etag,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: runtime.now(),
                }));
            } else {
                setSnapshot((s) => ({
                    ...s,
                    state: s.draft ? "uncommitted" : "dirty",
                    saving: false,
                }));
            }

            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            getCurrentBranchId,
            snapshot.data,
            snapshot.schemaVersion,
            snapshot.draft?.id,
            snapshot.head?.etag,
            runtime,
        ],
    );

    const publish = React.useCallback<WorkspaceAPI["snapshot"]["publish"]>(
        async (message?: string) => {
            const draftId = snapshot.draft?.id;
            if (!draftId) return save(message);

            const res = await backend.snapshots.publish({
                workspaceId,
                actorId: actor.id,
                draftId,
                message,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: runtime.now(),
                }));
            }

            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            snapshot.draft?.id,
            save,
            runtime,
        ],
    );

    const discardDraft = React.useCallback<
        WorkspaceAPI["snapshot"]["discardDraft"]
    >(async () => {
        const draftId = snapshot.draft?.id;
        if (!draftId) return { ok: true, value: undefined } as const;

        const res = await backend.snapshots.discard({
            workspaceId,
            actorId: actor.id,
            draftId,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: undefined,
                state: s.dirty ? "dirty" : "clean",
            }));
        }

        return res;
    }, [backend.snapshots, workspaceId, actor.id, snapshot.draft?.id]);

    // Autosave effect (same behavior as old provider)
    React.useEffect((): (() => void) | void => {
        if (!autoAutosave || !snapshot.dirty) return;

        if (autosaveTimerRef.current) {
            window.clearTimeout(autosaveTimerRef.current);
            autosaveTimerRef.current = null;
        }

        autosaveTimerRef.current = window.setTimeout(() => {
            void autosave();
            autosaveTimerRef.current = null;
        }, autosaveMs) as unknown as number;

        return (): void => {
            if (autosaveTimerRef.current) {
                window.clearTimeout(autosaveTimerRef.current);
                autosaveTimerRef.current = null;
            }
        };
    }, [snapshot.dirty, autosaveMs, autoAutosave, autosave]);

    const resetSnapshotForBranch = React.useCallback((): void => {
        setSnapshot((s) => ({
            ...s,
            head: undefined,
            draft: undefined,
            state: "clean",
            saving: false,
            dirty: false,
            lastSavedAt: undefined,
            lastDraftAt: undefined,
        }));
    }, []);

    return React.useMemo<SnapshotsSliceApi>(
        () => ({
            snapshot,
            loadSnapshotForBranch,
            loadSnapshot,
            refreshSnapshotPointersForBranch,
            refreshSnapshotPointers,
            setSnapshotData,
            autosave,
            save,
            publish,
            discardDraft,
            __setSnapshotState: setSnapshot,
            resetSnapshotForBranch,
        }),
        [
            snapshot,
            loadSnapshotForBranch,
            loadSnapshot,
            refreshSnapshotPointersForBranch,
            refreshSnapshotPointers,
            setSnapshotData,
            autosave,
            save,
            publish,
            discardDraft,
            resetSnapshotForBranch,
        ],
    );
}
```

---
#### 42


` File: src/react/workspace/context/provider/slices/use-templates-slice.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-templates-slice.ts
import * as React from "react";
import type {
    BackendError,
    FieldTemplate,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesListParams,
    WorkspaceBackend,
} from "../../backend";
import type { Loadable, WorkspaceAPI } from "@/react";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface TemplatesSliceApi {
    readonly templates: Loadable<readonly FieldTemplate[]>;

    readonly refreshTemplates: (
        params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
    ) => Promise<void>;

    readonly createTemplate: WorkspaceAPI["createTemplate"];
    readonly updateTemplate: WorkspaceAPI["updateTemplate"];
    readonly cloneTemplate: WorkspaceAPI["cloneTemplate"];
    readonly publishTemplate: WorkspaceAPI["publishTemplate"];
    readonly unpublishTemplate: WorkspaceAPI["unpublishTemplate"];
    readonly deleteTemplate: WorkspaceAPI["deleteTemplate"];

    readonly invalidateTemplates: () => void;

    /** internal setters for branch-cache composition */
    readonly __setTemplatesState: React.Dispatch<
        React.SetStateAction<Loadable<readonly FieldTemplate[]>>
    >;

    readonly resetTemplatesForBranch: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseTemplatesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;

    readonly getCurrentBranchId: () => string | undefined;

    readonly initialTemplates?: readonly FieldTemplate[] | null;

    readonly runtime: BackendRuntime;
}

export function useTemplatesSlice(
    params: UseTemplatesSliceParams,
): TemplatesSliceApi {
    const {
        backend,
        workspaceId,
        getCurrentBranchId,
        initialTemplates,
        runtime,
    } = params;

    const [templates, setTemplates] = React.useState<
        Loadable<readonly FieldTemplate[]>
    >({
        data: initialTemplates ?? null,
        loading: false,
        updatedAt: initialTemplates ? runtime.now() : undefined,
    });

    const refreshTemplates = React.useCallback(
        async (
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void> => {
            const branchId: string | undefined =
                params?.branchId ?? getCurrentBranchId();
            if (!branchId) return;

            setTemplates((s) => ({ ...s, loading: true }));

            const res = await backend.templates.refresh({
                workspaceId,
                branchId,
                since: params?.since ?? templates.updatedAt,
            });

            if (res.ok) {
                setTemplates({
                    data: res.value,
                    loading: false,
                    updatedAt: runtime.now(),
                });
            } else {
                setLoadableError(setTemplates, res.error);
            }
        },
        [
            backend.templates,
            workspaceId,
            getCurrentBranchId,
            templates.updatedAt,
            runtime,
        ],
    );

    const createTemplate = React.useCallback<WorkspaceAPI["createTemplate"]>(
        async (input: TemplateCreateInput) => {
            const res = await backend.templates.create(workspaceId, {
                ...input,
                branchId: input.branchId ?? getCurrentBranchId(),
            });

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, workspaceId, getCurrentBranchId, refreshTemplates],
    );

    const updateTemplate = React.useCallback<WorkspaceAPI["updateTemplate"]>(
        async (id: string, patch: TemplateUpdatePatch) => {
            const res = await backend.templates.update(id, patch);

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const cloneTemplate = React.useCallback<WorkspaceAPI["cloneTemplate"]>(
        async (source, opts) => {
            const res = await backend.templates.clone(
                source,
                opts ?? { branchId: getCurrentBranchId() ?? undefined },
            );

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const publishTemplate = React.useCallback<WorkspaceAPI["publishTemplate"]>(
        async (id: string) => {
            const res = await backend.templates.publish(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const unpublishTemplate = React.useCallback<
        WorkspaceAPI["unpublishTemplate"]
    >(
        async (id: string) => {
            const res = await backend.templates.unpublish(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const deleteTemplate = React.useCallback<WorkspaceAPI["deleteTemplate"]>(
        async (id: string) => {
            const res = await backend.templates.delete(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const invalidateTemplates = React.useCallback((): void => {
        setTemplates((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    const resetTemplatesForBranch = React.useCallback((): void => {
        setTemplates((s) => ({ ...s, data: null, error: undefined }));
    }, []);

    return React.useMemo<TemplatesSliceApi>(
        () => ({
            templates,
            refreshTemplates,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidateTemplates,
            __setTemplatesState: setTemplates,
            resetTemplatesForBranch,
        }),
        [
            templates,
            refreshTemplates,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidateTemplates,
            resetTemplatesForBranch,
        ],
    );
}
```

---
#### 43


` File: src/react/workspace/context/provider/types.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/context/provider/types.ts
import type {
    Actor,
    Author,
    BackendError,
    Branch,
    BranchParticipant,
    Commit,
    Draft,
    FieldTemplate,
    LiveOptions,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsLoadResult,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesListParams,
    WorkspaceBackend,
    WorkspaceInfo,
} from "../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceMap } from "@/schema/provider";
import React from "react";
import { WorkspaceLiveAdapterRegistry } from "@/react/workspace/context/provider/live/types";
import { CommentsSliceApi } from "@/react/workspace/context/provider/slices/use-comments-slice";
import { DynamicRule } from "@/schema/validation";
import type { CommentThread } from "@/schema/comments";
import { PoliciesSlice } from "@/react/workspace/context/provider/slices/use-policies-slice";
export interface Loadable<T> {
    readonly data: T | null;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export type SnapshotState = "clean" | "dirty" | "uncommitted" | "saving";

export type RunOk = { ok: true };
export type RunErr = { ok: false; errors: BackendError[] };
export type RunResult = RunOk | RunErr;

export interface WorkspaceProviderProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    readonly initial?: Partial<{
        authors: readonly Author[];
        permissions: PermissionsMap;
        branches: readonly Branch[];
        mainId: string;

        // branch-scoped caches
        templates: readonly FieldTemplate[];
        participants: readonly BranchParticipant[];

        snapshot: ServiceSnapshot;
        head?: Commit;
        draft?: Draft;

        currentBranchId?: string;

        // services can be injected as already-normalized map
        services: DgpServiceMap;
        policies?: readonly DynamicRule[];
        comments?: readonly CommentThread[];
    }>;

    readonly ensureMain?: boolean;
    readonly live?: LiveOptions;
    /**
     * Optional adapter registry for live modes.
     * If you want ws/sse (or custom), pass adapters here.
     */
    readonly liveAdapters?: WorkspaceLiveAdapterRegistry;

    /**
     * Debounce refresh ticks (WS bursts etc). Default handled in hook (250ms).
     */
    readonly liveDebounceMs?: number;
    readonly autosaveMs?: number; // default 9000
    readonly autoAutosave?: boolean; // default true
    readonly children: React.ReactNode;
}

export interface BranchesSlice {
    readonly data: readonly Branch[];
    readonly mainId?: string;
    readonly currentId?: string;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export interface SnapshotSlice {
    readonly schemaVersion?: string;
    readonly data?: EditorSnapshot;
    readonly head?: Commit;
    readonly draft?: Draft;

    readonly state: SnapshotState;
    readonly saving: boolean;
    readonly dirty: boolean;

    readonly lastSavedAt?: number;
    readonly lastDraftAt?: number;
}

export interface BranchCacheEntry {
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;
    readonly snapshot: SnapshotSlice;
}

export interface WorkspaceAPI {
    readonly info: WorkspaceInfo;
    readonly actor: Actor;

    readonly authors: Loadable<readonly Author[]>;
    readonly permissions: Loadable<PermissionsMap>;
    readonly branches: BranchesSlice;

    /** branch-scoped */
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;

    /** workspace-scoped map (already normalized) */
    readonly services: Loadable<DgpServiceMap>;

    readonly refresh: {
        /** Refresh everything (workspace + current-branch context) */
        all(opts?: { strict?: boolean }): Promise<RunResult>;

        authors(): Promise<void>;
        permissions(): Promise<void>;
        branches(): Promise<void>;
        services(): Promise<void>;

        /** Current branch-scoped refreshers */
        branchContext(): Promise<void>;
        templates(
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void>;
        participants(
            params?: Partial<{ branchId: string; since?: number | string }>,
        ): Promise<void>;

        snapshotPointers(): Promise<void>;
        policies(): Promise<void>;
    };

    readonly setCurrentBranch: (id: string) => void;

    readonly createBranch: (
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ) => Result<Branch>;
    readonly setMain: (branchId: string) => Result<Branch>;
    readonly mergeBranch: (
        sourceId: string,
        targetId: string,
    ) => Result<MergeResult>;
    readonly deleteBranch: (branchId: string) => Result<void>;

    // Template ops
    readonly createTemplate: (
        input: TemplateCreateInput,
    ) => Result<FieldTemplate>;
    readonly updateTemplate: (
        id: string,
        patch: TemplateUpdatePatch,
    ) => Result<FieldTemplate>;
    readonly cloneTemplate: (
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ) => Result<FieldTemplate>;
    readonly publishTemplate: (id: string) => Result<FieldTemplate>;
    readonly unpublishTemplate: (id: string) => Result<FieldTemplate>;
    readonly deleteTemplate: (id: string) => Result<void>;

    readonly invalidate: (
        keys?: Array<
            | "authors"
            | "permissions"
            | "branches"
            | "services"
            | "templates"
            | "participants"
            | "comments"
            | "policies"
            | "snapshot"
        >,
    ) => void;

    readonly live: {
        readonly connected: boolean;
        readonly lastEventAt?: number;
        connect(): void;
        disconnect(): void;
    };

    readonly snapshot: {
        readonly state: SnapshotState;
        readonly saving: boolean;
        readonly dirty: boolean;
        readonly head?: Commit;
        readonly draft?: Draft;
        readonly schemaVersion?: string;
        readonly data?: EditorSnapshot;
        readonly lastSavedAt?: number;
        readonly lastDraftAt?: number;

        set(
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void;

        load(
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult>;
        refresh(): Promise<void>;

        autosave(): Result<Readonly<{ draft: Draft }>>;
        save(message?: string): Result<Readonly<{ commit: Commit }>>;
        publish(message?: string): Result<Readonly<{ commit: Commit }>>;
        discardDraft(): Result<void>;
    };

    readonly comments: CommentsSliceApi;
    readonly policies: PoliciesSlice;
}
```

---
#### 44


` File: src/react/workspace/index.ts`  [↑ Back to top](#index)

```ts
// src/react/workspace/index.ts

export { Workspace } from "./app";
export type { WorkspaceProps } from "./app";

export * from "./context";
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-22T02:55:14.253Z -->