*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L42 -->
<!-- PRODEX_FILE_COUNT: 35 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/react/workspace/app.tsx](#1)  L46-L133
- [src/react/workspace/components/canvas.tsx](#2)  L134-L254
- [src/react/workspace/components/context-menu-renderer.tsx](#3)  L255-L460
- [src/react/workspace/components/reactflow/edge.tsx](#4)  L461-L470
- [src/react/workspace/components/reactflow/index.tsx](#5)  L471-L492
- [src/react/workspace/components/reactflow/nodes/comments.tsx](#6)  L493-L502
- [src/react/workspace/components/reactflow/nodes/field.tsx](#7)  L503-L537
- [src/react/workspace/components/reactflow/nodes/node.tsx](#8)  L538-L706
- [src/react/workspace/components/reactflow/nodes/options.tsx](#9)  L707-L725
- [src/react/workspace/components/reactflow/nodes/tags.tsx](#10)  L726-L748
- [src/react/workspace/context/backend.ts](#11)  L749-L1149
- [src/react/workspace/context/context.tsx](#12)  L1150-L1461
- [src/react/workspace/context/ctxmenu.tsx](#13)  L1462-L1760
- [src/react/workspace/context/index.tsx](#14)  L1761-L1804
- [src/react/workspace/context/memory-backend.ts](#15)  L1805-L2442
- [src/react/workspace/context/provider/compose/use-branch-cache.ts](#16)  L2443-L2724
- [src/react/workspace/context/provider/compose/use-live-polling.ts](#17)  L2725-L3012
- [src/react/workspace/context/provider/compose/use-workspace-refresh.ts](#18)  L3013-L3222
- [src/react/workspace/context/provider/context.ts](#19)  L3223-L3250
- [src/react/workspace/context/provider/helpers.ts](#20)  L3251-L3361
- [src/react/workspace/context/provider/live/adapters/manual.ts](#21)  L3362-L3371
- [src/react/workspace/context/provider/live/adapters/poll.ts](#22)  L3372-L3452
- [src/react/workspace/context/provider/live/adapters/sse.ts](#23)  L3453-L3462
- [src/react/workspace/context/provider/live/adapters/ws.ts](#24)  L3463-L3472
- [src/react/workspace/context/provider/live/types.ts](#25)  L3473-L3555
- [src/react/workspace/context/provider/provider.tsx](#26)  L3556-L4038
- [src/react/workspace/context/provider/runtime/use-backend-runtime.ts](#27)  L4039-L4086
- [src/react/workspace/context/provider/slices/use-authors-slice.ts](#28)  L4087-L4156
- [src/react/workspace/context/provider/slices/use-branches-slice.ts](#29)  L4157-L4372
- [src/react/workspace/context/provider/slices/use-permissions-slice.ts](#30)  L4373-L4450
- [src/react/workspace/context/provider/slices/use-services-slice.ts](#31)  L4451-L4527
- [src/react/workspace/context/provider/slices/use-snapshots-slice.ts](#32)  L4528-L4974
- [src/react/workspace/context/provider/slices/use-templates-slice.ts](#33)  L4975-L5214
- [src/react/workspace/context/provider/types.ts](#34)  L5215-L5447
- [src/react/workspace/index.ts](#35)  L5448-L5465
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/react/workspace/app.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/app.tsx
import * as React from "react";

import { WorkspaceProvider } from "./context";
import type { WorkspaceProviderProps } from "./context";
import type { Actor, WorkspaceBackend } from "./context/backend";

import type { ToolsConfig } from "../adapters/reactflow";
import { CanvasProvider } from "./context/context";

/**
 * Props for the Workspace wrapper. Mirrors WorkspaceProvider options.
 */
export interface WorkspaceProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    /** Optional pre-hydration to avoid blank first paint */
    readonly initial?: WorkspaceProviderProps["initial"];

    /** Ensure a 'main' branch exists; otherwise first branch is used (default true) */
    readonly ensureMain?: WorkspaceProviderProps["ensureMain"];

    /** Live refresh mode (poll/SSE/WS/off). Defaults to off. */
    readonly live?: WorkspaceProviderProps["live"];

    /** Optional live adapter registry (ws/sse/custom). */
    readonly liveAdapters?: WorkspaceProviderProps["liveAdapters"];

    /** Debounce refresh ticks (WS bursts etc). */
    readonly liveDebounceMs?: WorkspaceProviderProps["liveDebounceMs"];

    /** Autosave debounce window in ms (default 9000) */
    readonly autosaveMs?: WorkspaceProviderProps["autosaveMs"];

    /** Auto-run autosave when dirty (default true) */
    readonly autoAutosave?: WorkspaceProviderProps["autoAutosave"];

    readonly tools?: ToolsConfig;
    readonly children: (tools?: ToolsConfig) => React.ReactNode;
}

/**
 * Workspace: wraps app panels with WorkspaceProvider.
 * Accepts the same inputs as WorkspaceProvider and passes them through.
 */
export function Workspace(props: WorkspaceProps): React.JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain,
        live,
        liveAdapters,
        liveDebounceMs,
        autosaveMs,
        autoAutosave,
        tools,
        children,
    } = props;

    return (
        <WorkspaceProvider
            backend={backend}
            actor={actor}
            initial={initial}
            ensureMain={ensureMain}
            live={live}
            liveAdapters={liveAdapters}
            liveDebounceMs={liveDebounceMs}
            autosaveMs={autosaveMs}
            autoAutosave={autoAutosave}
        >
            <CanvasProvider>{children(tools)}</CanvasProvider>
        </WorkspaceProvider>
    );
}

export default Workspace;
```

---
#### 2


` File: src/react/workspace/components/canvas.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/adapters/reactflow/ReactFlowCanvas.tsx
import React, { useMemo, useState } from "react";
import ReactFlow, { Background, ConnectionMode, MiniMap } from "reactflow";
import "reactflow/dist/style.css";

import {
    type AdapterOptions,
    useReactFlowAdapter,
} from "../../adapters/reactflow/adapter";
import type { CanvasAPI } from "@/react";
import { Toolbar } from "../../adapters/reactflow/toolbar";
import type { LabelPlacement, ToolsConfig } from "../../adapters/reactflow";
import { edgeTypes, nodeTypes } from "./reactflow";

export type ReactFlowCanvasProps = {
    api: CanvasAPI;
    options?: AdapterOptions;

    showToolbar?: boolean;
    tools?: ToolsConfig;
    labelPlacement?: LabelPlacement;
    renderTool?: Parameters<typeof Toolbar>[0]["renderButton"];

    initialShowGrid?: boolean;
    initialShowMiniMap?: boolean;

    /** absolute position classes relative to the ReactFlow canvas */
    toolbarPositionClassName?: string; // e.g. "left-2 top-2"
};

export function Canvas({
    api,
    options,
    showToolbar = true,
    tools,
    labelPlacement = "tooltip",
    renderTool,
    initialShowGrid = true,
    initialShowMiniMap = false,
    toolbarPositionClassName = "left-2 top-2",
}: ReactFlowCanvasProps) {
    const [showGrid, setShowGrid] = useState(initialShowGrid);
    const [showMiniMap, setShowMiniMap] = useState(initialShowMiniMap);

    const {
        nodes,
        edges,
        onNodesChange,
        onEdgesChange,
        onConnect,
        onConnectStart,
        onConnectEnd,
        onMoveEnd,
        onSelectionChange,
        isValidConnection,
        snapVector,
    } = useReactFlowAdapter(api, options);

    const snapToGrid = useMemo(
        () => !!options?.snapToGrid,
        [options?.snapToGrid],
    );
    const snapGrid = useMemo<[number, number] | undefined>(
        () => snapVector,
        [snapVector],
    );

    return (
        <div className="relative h-full w-full bg-gray-50">
            <ReactFlow
                nodes={nodes}
                edges={edges}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                connectionMode={ConnectionMode.Loose}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnectStart={onConnectStart}
                onConnectEnd={onConnectEnd}
                onConnect={onConnect}
                onMoveEnd={onMoveEnd}
                onSelectionChange={onSelectionChange}
                isValidConnection={isValidConnection}
                fitView
                snapToGrid={snapToGrid}
                snapGrid={snapGrid}
            >
                {/* toolbar inside ReactFlow so useReactFlow() works */}
                {showToolbar && (
                    <div
                        className={`pointer-events-none absolute z-10 ${toolbarPositionClassName}`}
                    >
                        <Toolbar
                            api={api}
                            mode="dev"
                            showGrid={showGrid}
                            setShowGrid={setShowGrid}
                            showMiniMap={showMiniMap}
                            setShowMiniMap={setShowMiniMap}
                            tools={tools}
                            labelPlacement={labelPlacement}
                            renderButton={renderTool}
                        />
                    </div>
                )}

                {showMiniMap && <MiniMap />}
                {showGrid && <Background />}
            </ReactFlow>
        </div>
    );
}
```

---
#### 3


` File: src/react/workspace/components/context-menu-renderer.tsx`  [‚Üë Back to top](#index)

```tsx
import type { ContextState, MenuItem } from "@/react/workspace/context/ctxmenu";
import React, {
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState,
} from "react";

/**
 * Pure presentational menu. Mirrors Stitch spec:
 * - 8px+ padding groups with 1px separators
 * - Icons on the left, label, right-aligned hint
 * - Disabled shows muted colors + not-allowed cursor
 * - Danger shows red accents
 */
export const ContextMenuRenderer: React.FC<{
    items: MenuItem[];
    ctx: ContextState;
    onClose: () => void;
    onAction: (item: MenuItem, e: MouseEvent | KeyboardEvent) => void;
}> = ({ items, ctx, onClose, onAction }) => {
    const rootRef = useRef<HTMLDivElement | null>(null);
    const [focusIdx, setFocusIdx] = useState<number>(() =>
        nextFocusable(items, ctx, -1),
    );

    const flat = useMemo(
        () => items, // simple 1-level for now; submenus can extend this
        [items],
    );

    const isDisabled = useCallback(
        (it: MenuItem) =>
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled,
        [ctx],
    );

    const handleActivate = useCallback(
        (it: MenuItem, e: MouseEvent | KeyboardEvent) => {
            if (isDisabled(it) || it.divider || !it.onSelect) return;
            onAction(it, e);
            onClose();
        },
        [isDisabled, onClose, onAction],
    );

    // Keyboard support
    useEffect(() => {
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") {
                e.preventDefault();
                onClose();
                return;
            }
            if (e.key === "ArrowDown") {
                e.preventDefault();
                setFocusIdx((i) => nextFocusable(flat, ctx, i));
                return;
            }
            if (e.key === "ArrowUp") {
                e.preventDefault();
                setFocusIdx((i) => prevFocusable(flat, ctx, i));
                return;
            }
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                const it = flat[focusIdx];
                if (it) handleActivate(it, e);
            }
        };
        document.addEventListener("keydown", onKey, true);
        return () => document.removeEventListener("keydown", onKey, true);
    }, [flat, ctx, focusIdx, handleActivate, onClose]);

    return (
        <div
            ref={rootRef}
            className="w-64 min-w-max rounded-lg border border-slate-200/80 bg-white shadow-xl shadow-slate-950/5 backdrop-blur-sm dark:border-slate-800 dark:bg-slate-900"
            role="menu"
            aria-orientation="vertical"
        >
            <div className="flex flex-col gap-0.5 p-1.5">
                {flat.map((it, idx) => {
                    if (it.divider) {
                        return (
                            <hr
                                key={`div-${idx}`}
                                className="my-1.5 border-t border-slate-200 dark:border-slate-800"
                                aria-hidden
                            />
                        );
                    }

                    const disabled = isDisabled(it);
                    const danger = !!it.danger;
                    const focused = idx === focusIdx;

                    return (
                        <button
                            key={it.key ?? idx}
                            type="button"
                            role="menuitem"
                            aria-disabled={disabled || undefined}
                            onMouseEnter={() => setFocusIdx(idx)}
                            onClick={(e) => {
                                e.preventDefault();
                                if (disabled) return;
                                handleActivate(it, e.nativeEvent);
                            }}
                            className={[
                                "flex min-h-10 w-full items-center justify-between gap-3 rounded-md px-3 text-sm font-medium",
                                disabled
                                    ? "cursor-not-allowed text-slate-400 dark:text-slate-600"
                                    : danger
                                      ? "text-red-600 hover:bg-red-50 hover:text-red-700 dark:text-red-400 dark:hover:bg-red-950/30 dark:hover:text-red-300"
                                      : focused
                                        ? "bg-primary/10 text-slate-900 dark:text-slate-100"
                                        : "text-slate-700 hover:bg-primary/10 dark:text-slate-300",
                            ].join(" ")}
                        >
                            <span className="flex items-center gap-3">
                                {it.icon ?? null}
                                <span className="truncate">{it.label}</span>
                            </span>
                            {it.hint ? (
                                <span className="text-xs text-slate-400 dark:text-slate-500">
                                    {it.hint}
                                </span>
                            ) : (
                                <span />
                            )}
                        </button>
                    );
                })}
            </div>
        </div>
    );
};

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function nextFocusable(
    items: MenuItem[],
    ctx: ContextState,
    from: number,
): number {
    for (let i = from + 1; i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = 0; i <= from && i < items.length; i++) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}

function prevFocusable(
    items: MenuItem[],
    ctx: ContextState,
    from: number,
): number {
    for (let i = from - 1; i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    // wrap
    for (let i = items.length - 1; i >= from && i >= 0; i--) {
        const it = items[i];
        if (it.divider) continue;
        const disabled =
            typeof it.disabled === "function"
                ? it.disabled(ctx)
                : !!it.disabled;
        if (!disabled) return i;
    }
    return Math.max(0, Math.min(items.length - 1, from));
}
```

---
#### 4


` File: src/react/workspace/components/reactflow/edge.tsx`  [‚Üë Back to top](#index)

```tsx

```

---
#### 5


` File: src/react/workspace/components/reactflow/index.tsx`  [‚Üë Back to top](#index)

```tsx
import Tag from "./nodes/tags";
import Field from "./nodes/field";
import Options from "./nodes/options";

const nodeTypes = {
    tag: Tag,
    field: Field,
    option: Options,
};

const edgeTypes = {};

export { nodeTypes, edgeTypes };
```

---
#### 6


` File: src/react/workspace/components/reactflow/nodes/comments.tsx`  [‚Üë Back to top](#index)

```tsx

```

---
#### 7


` File: src/react/workspace/components/reactflow/nodes/field.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "./node";
import React from "react";
import { FlowNode } from "@/schema/graph";

const Field: React.FC<FlowNode> = (props) => {
    const {
        id,
        data: {
            node: { label },
        },
    } = props;
    return (
        <Node label={label} id={id} type={"field"}>
            {(label, icon) => {
                return (
                    <span className="flex gap-2 items-center">
                        {icon}
                        {label}
                    </span>
                );
            }}
        </Node>
    );
};

export default Field;
```

---
#### 8


` File: src/react/workspace/components/reactflow/nodes/node.tsx`  [‚Üë Back to top](#index)

```tsx
import React, { ReactNode, useEffect, useRef } from "react";
import { LiaTagsSolid } from "react-icons/lia";
import { RxInput } from "react-icons/rx";
import { TbHandClick } from "react-icons/tb";
import { LuTextSelect } from "react-icons/lu";
import { TfiComments } from "react-icons/tfi";
import { Handle, Position } from "reactflow";
import { useCanvasAPI } from "@/react/workspace/context/context";
import { clsx } from "clsx";

interface Errors {
    title?: string;
    description: string;
    meta?: Record<string, unknown>;
}
interface NodeProps {
    children?: (
        label: ReactNode,
        icon: ReactNode,
        errors?: Errors[],
    ) => React.ReactNode;
    description?: string;
    label: string;
    id: string;
    type: "tag" | "field" | "option" | "button" | "comment";
    errors?: Errors[];
    meta?: Record<string, unknown>;
}

function getIcon(
    type: NodeProps["type"],
): React.FC<React.SVGProps<SVGSVGElement>> {
    switch (type) {
        case "tag":
            return LiaTagsSolid;
        case "field":
            return RxInput;
        case "option":
            return LuTextSelect;
        case "button":
            return TbHandClick;
        case "comment":
            return TfiComments;
    }
}
const Node: React.FC<NodeProps> = ({
    children,
    label,
    errors,
    id,
    type,
    description,
}) => {
    const labelRef = useRef<HTMLDivElement>(null);
    const descRef = useRef<HTMLDivElement>(null);
    const { editor } = useCanvasAPI();

    useEffect(() => {
        if (labelRef.current && labelRef.current.innerText !== label) {
            labelRef.current.innerText = label;
        }
        if (
            descRef.current &&
            descRef.current.innerText !== (description ?? "")
        ) {
            descRef.current.innerText = description ?? "";
        }
    }, [label, description]);
    const Icon = getIcon(type);
    const Label = (
        <div
            contentEditable
            suppressContentEditableWarning
            tabIndex={0} // make it focusable
            onPointerDown={(e) => e.stopPropagation()}
            onMouseDown={(e) => e.stopPropagation()}
            onContextMenu={(e) => {
                e.preventDefault(); // prevent default context menu
                labelRef.current?.focus(); // focus the editable div
            }}
            onDoubleClick={(e) => {
                e.stopPropagation();
                labelRef.current?.focus();
            }}
            onBlur={() => {
                const newText = labelRef.current?.innerText.trim() || "";
                if (newText && newText !== label) {
                    editor.reLabel(id, newText);
                }
            }}
            className="text-[12px] outline-none w-full cursor-text text-center"
        >
            {label}
        </div>
    );
    return (
        <div
            className={clsx(
                "px-4 items-center gap-2 relative min-h-[40px] flex h-fit bg-card ring ring-grey-100 rounded-md shadow text-card-foreground font-black",
            )}
        >
            {children ? (
                children(Label, <Icon />, errors)
            ) : (
                <span className={"flex gap-2 items-center"}>
                    <Icon /> {Label}
                </span>
            )}

            <Handle
                id="mid-top"
                type="target"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-top"
                type="source"
                position={Position.Top}
                style={{
                    top: 0,
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    zIndex: 10,
                }}
            />

            {/* mid-bottom: target + source */}
            <Handle
                id="mid-bottom"
                type="target"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
            <Handle
                id="mid-bottom"
                type="source"
                position={Position.Bottom}
                style={{
                    bottom: 0,
                    left: "50%",
                    transform: "translate(-50%, 50%)",
                    zIndex: 10,
                }}
            />
        </div>
    );
};

export default Node;
```

---
#### 9


` File: src/react/workspace/components/reactflow/nodes/options.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "./node";
import { NodeProps } from "reactflow";
import { GraphNode } from "@/schema/graph";
import React from "react";

const Options: React.FC<NodeProps<GraphNode>> = ({ id, data: { label } }) => {
    return <Node label={label} id={id} type={"option"} />;
};

export default Options;
```

---
#### 10


` File: src/react/workspace/components/reactflow/nodes/tags.tsx`  [‚Üë Back to top](#index)

```tsx
import Node from "./node";
import React from "react";
import type { FlowNode } from "@/schema/graph";

const Tag: React.FC<FlowNode> = ({
    id,
    data: {
        node: { label },
    },
}) => {
    return <Node type={"tag"} label={label} id={id} />;
};

export default Tag;
```

---
#### 11


` File: src/react/workspace/context/backend.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/backend.ts
// Transport-agnostic contracts for the Workspace layer.
// Explicit types only (no implicit any). Result shape: { ok, value | error }.

import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";

/* ---------------- core result & identity ---------------- */

export interface BackendError {
    readonly meta?: any;
    readonly code: string;
    readonly message: string;
    readonly status?: number;
    readonly hint?: string;
    readonly cause?: unknown;
}

export type BackendResult<T> =
    | { ok: true; value: T }
    | { ok: false; error: BackendError };

export type Result<T> = Promise<BackendResult<T>>;

export interface Actor {
    readonly id: string;
    readonly name?: string;
    readonly roles?: readonly string[];
    readonly meta?: Readonly<Record<string, unknown>>;
}

/* ---------------- common entities ---------------- */

export interface Author {
    readonly id: string;
    readonly name: string;
    readonly handle?: string;
    readonly avatarUrl?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export type PermissionsMap = Readonly<Record<string, boolean>>;

export interface Branch {
    readonly id: string;
    readonly name: string;
    readonly isMain: boolean;
    readonly headVersionId?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface MergeResult {
    readonly sourceId: string;
    readonly targetId: string;
    readonly conflicts?: number;
    readonly message?: string;
}

/* ---------------- services ---------------- */

export type ServicesInput = readonly DgpServiceCapability[] | DgpServiceMap;

export interface ServicesBackend {
    get(workspaceId: string): Result<ServicesInput>;
    refresh(
        workspaceId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<ServicesInput>;
}

/* ---------------- branch access / participants ---------------- */

export interface BranchParticipant {
    readonly id: string;
    readonly workspaceId: string;
    readonly branchId: string;

    /** points into Authors directory */
    readonly authorId: string;

    /** roles are intentionally loose; host decides taxonomy */
    readonly roles?: readonly string[];

    readonly canRead: boolean;
    readonly canWrite: boolean;

    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}

export interface BranchAccessBackend {
    listParticipants(
        workspaceId: string,
        branchId: string,
    ): Result<readonly BranchParticipant[]>;
    refreshParticipants(
        workspaceId: string,
        branchId: string,
        params?: Readonly<{ since?: number | string }>,
    ): Result<readonly BranchParticipant[]>;
}

/* ---------------- snapshots (editor state) ---------------- */

export interface ServiceSnapshot {
    readonly schema_version: string;
    readonly data: EditorSnapshot;
    readonly meta?: Readonly<Record<string, unknown>>;
}

export interface Draft {
    readonly id: string;
    readonly branchId: string;
    readonly status: "uncommitted";
    readonly etag?: string;
    readonly meta?: Readonly<Record<string, unknown>>;
    readonly createdAt: string;
    readonly updatedAt: string;
}

export interface Commit {
    readonly id: string;
    readonly branchId: string;
    readonly message?: string;
    readonly versionId?: string;
    readonly etag?: string;
    readonly createdAt: string;
}

export interface SnapshotsLoadResult {
    readonly head?: Commit;
    readonly draft?: Draft;
    readonly snapshot: ServiceSnapshot;
}

export interface SnapshotsBackend {
    load(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            versionId?: string;
        }>,
    ): Result<SnapshotsLoadResult>;
    autosave(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            clientId?: string;
            since?: number | string;
            etag?: string;
        }>,
    ): Result<Readonly<{ draft: Draft }>>;
    save(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            snapshot: ServiceSnapshot;
            message?: string;
            draftId?: string;
            etag?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    publish(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
            message?: string;
        }>,
    ): Result<Readonly<{ commit: Commit }>>;
    discard(
        params: Readonly<{
            workspaceId: string;
            actorId: string;
            draftId: string;
        }>,
    ): Result<void>;
    refresh(
        params: Readonly<{
            workspaceId: string;
            branchId: string;
            actorId: string;
            since?: number | string;
        }>,
    ): Result<Readonly<{ head?: Commit; draft?: Draft }>>;
}

/* ---------------- templates (replacing "assets") ---------------- */

export interface TemplateValidator {
    readonly type: string; // e.g., "required" | "regex" | "min" | "max" | custom code
    readonly rule?: unknown; // params for the validator
    readonly message?: string;
}

export interface FieldTemplate {
    readonly id: string;
    /** Unique key (per workspace, optionally per branch) used to reference this template */
    readonly key: string;
    readonly name: string;
    /** logical kind e.g. "text", "number", "date", "select", "relation", ... */
    readonly kind: string;

    /** Optional branch scoping (can be global if undefined) */
    readonly branchId?: string;

    /** Canonical, builder-consumable definition (shape up to your app) */
    readonly definition: Readonly<Record<string, unknown>>;

    /** Default values the editor may inject when using this template */
    readonly defaults?: Readonly<Record<string, unknown>>;

    /** UI metadata (icons, color, sizing, render hints, etc.) */
    readonly ui?: Readonly<Record<string, unknown>>;

    /** Client- or server-side validators */
    readonly validators?: readonly TemplateValidator[];

    readonly tags?: readonly string[];
    readonly category?: string;

    /** Published templates are selectable by default in the editor palette */
    readonly published: boolean;

    /** Incremented on every update */
    readonly version: number;

    readonly createdAt: string;
    readonly updatedAt: string;
}

/** Narrow list/search input */
export interface TemplatesListParams {
    readonly workspaceId: string;
    readonly branchId?: string;
    readonly q?: string;
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly since?: string | number;
}

export interface TemplateCreateInput {
    readonly key?: string; // if omitted, backend generates a unique one
    readonly name: string;
    readonly kind: string;
    readonly branchId?: string;
    readonly definition: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>>;
    readonly ui?: Readonly<Record<string, unknown>>;
    readonly validators?: readonly TemplateValidator[];
    readonly tags?: readonly string[];
    readonly category?: string;
    readonly published?: boolean;
}

export interface TemplateUpdatePatch {
    readonly name?: string;
    readonly kind?: string;
    readonly branchId?: string | null;
    readonly definition?: Readonly<Record<string, unknown>>;
    readonly defaults?: Readonly<Record<string, unknown>> | null;
    readonly ui?: Readonly<Record<string, unknown>> | null;
    readonly validators?: readonly TemplateValidator[] | null;
    readonly tags?: readonly string[] | null;
    readonly category?: string | null;
    readonly published?: boolean;
}

export interface TemplatesBackend {
    list(params: TemplatesListParams): Result<readonly FieldTemplate[]>;
    get(id: string): Result<FieldTemplate | null>;
    getByKey(
        workspaceId: string,
        key: string,
        branchId?: string,
    ): Result<FieldTemplate | null>;
    create(
        workspaceId: string,
        input: TemplateCreateInput,
    ): Result<FieldTemplate>;
    update(id: string, patch: TemplateUpdatePatch): Result<FieldTemplate>;
    clone(
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ): Result<FieldTemplate>;
    publish(id: string): Result<FieldTemplate>;
    unpublish(id: string): Result<FieldTemplate>;
    delete(id: string): Result<void>;
    refresh(
        params: Omit<TemplatesListParams, "q" | "tags" | "category">,
    ): Result<readonly FieldTemplate[]>;
}

/* ---------------- live channel ---------------- */

export type WorkspaceEvent =
    | { type: "authors.updated"; since?: number | string }
    | { type: "permissions.updated" }
    | { type: "services.updated"; since?: number | string }
    | {
          type: "branch.participants.updated";
          branchId: string;
          since?: number | string;
      }
    | { type: "branch.created"; branch: Branch }
    | { type: "branch.deleted"; branchId: string }
    | { type: "branch.setMain"; branchId: string }
    | { type: "branch.merged"; sourceId: string; targetId: string }
    | { type: "template.created"; template: FieldTemplate }
    | { type: "template.updated"; template: FieldTemplate }
    | { type: "template.deleted"; templateId: string }
    | { type: "snapshot.autosaved"; branchId: string; draft: Draft }
    | { type: "snapshot.saved"; branchId: string; commit: Commit }
    | { type: "snapshot.published"; branchId: string; commit: Commit }
    | { type: "snapshot.discarded"; branchId: string };

export type LiveOptions =
    | { mode: "off" }
    | { mode: "poll"; intervalMs?: number }
    | { mode: "sse"; url: string; headers?: Readonly<Record<string, string>> }
    | { mode: "ws"; url: string; protocols?: readonly string[] };

/* ---------------- authors / permissions / branches ---------------- */

export interface AuthorsBackend {
    list(workspaceId: string): Result<readonly Author[]>;
    get(authorId: string): Result<Author | null>;
    refresh(workspaceId: string): Result<readonly Author[]>;
}

export interface PermissionsBackend {
    get(workspaceId: string, actor: Actor): Result<PermissionsMap>;
    refresh(workspaceId: string, actor: Actor): Result<PermissionsMap>;
}

export interface BranchesBackend {
    list(workspaceId: string): Result<readonly Branch[]>;
    create(
        workspaceId: string,
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ): Result<Branch>;
    setMain(workspaceId: string, branchId: string): Result<Branch>;
    merge(
        workspaceId: string,
        sourceId: string,
        targetId: string,
    ): Result<MergeResult>;
    delete(workspaceId: string, branchId: string): Result<void>;
    refresh(workspaceId: string): Result<readonly Branch[]>;
}

/* ---------------- workspace backend root ---------------- */

export interface WorkspaceInfo {
    readonly id: string;
    readonly name: string;
    readonly description?: string;
    readonly createdAt: string;
    readonly updatedAt: string;
    readonly meta?: Readonly<Record<string, unknown>>;
}

export interface WorkspaceBackend {
    readonly info: WorkspaceInfo;

    readonly authors: AuthorsBackend;
    readonly permissions: PermissionsBackend;
    readonly branches: BranchesBackend;

    /** branch-scoped access control / participants */
    readonly access: BranchAccessBackend;

    /** first-class services channel */
    readonly services: ServicesBackend;

    readonly templates: TemplatesBackend;
    readonly snapshots: SnapshotsBackend;
}
```

---
#### 12


` File: src/react/workspace/context/context.tsx`  [‚Üë Back to top](#index)

```tsx
import React, {
    createContext,
    useContext,
    useEffect,
    useMemo,
    useRef,
    type ReactNode,
} from "react";
import { CanvasAPI } from "@/react";
import { Builder, BuilderOptions, createBuilder } from "@/core";
import type { CanvasOptions } from "@/schema/canvas-types";
import type { CanvasBackendOptions } from "../../canvas/backend";
import type { ServiceProps } from "@/schema";
import { useWorkspaceMaybe } from ".";

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ context ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const Ctx = createContext<CanvasAPI | null>(null);

/** Managed props (back-compat): host provides the API instance. */
type CanvasProviderManagedProps = { api: CanvasAPI; children: ReactNode };

/** Workspace-aware props: host omits `api`, we attach to Workspace on demand. */
type CanvasProviderWorkspaceProps = {
    children: ReactNode;
    /** Optional Builder options (e.g., historyLimit, serviceMap if you already have one). */
    builderOpts?: BuilderOptions;
    /** Canvas view/backend options for CanvasAPI ctor. */
    canvasOpts?: CanvasOptions & CanvasBackendOptions;
    /** If false, we won‚Äôt attempt to read Workspace; will throw if no api is provided. */
    attachToWorkspace?: boolean; // default true
};

type CanvasProviderProps =
    | CanvasProviderManagedProps
    | CanvasProviderWorkspaceProps;

/**
 * CanvasProvider
 * - Managed mode (existing): <CanvasProvider api={api}>{...}</CanvasProvider>
 * - Workspace-aware mode (new): if no `api` and inside a Workspace, auto-create Builder+CanvasAPI and load snapshot props.
 */
export function CanvasProvider(props: CanvasProviderProps) {
    // Managed mode: unchanged behavior
    if ("api" in props) {
        return <Ctx.Provider value={props.api}>{props.children}</Ctx.Provider>;
    }

    // Workspace-aware mode
    const {
        children,
        builderOpts,
        canvasOpts,
        attachToWorkspace = true,
    } = props;

    const ws = useWorkspaceMaybe();

    if (!attachToWorkspace || !ws) {
        throw new Error(
            "CanvasProvider: no `api` provided and no Workspace context available. " +
                "Either pass an `api` prop or render within <WorkspaceProvider>.",
        );
    }

    // üîπ NEW: if snapshot props aren‚Äôt loaded yet, trigger a one-time load
    const triedInitialLoadRef = useRef<boolean>(false);
    useEffect(() => {
        const hasProps = Boolean(ws.snapshot.data?.props);
        if (!hasProps && !triedInitialLoadRef.current) {
            triedInitialLoadRef.current = true;
            void ws.snapshot.load().then((res) => {
                // dev-only noise; stay silent in prod
                if (
                    typeof window !== "undefined" &&
                    // @ts-expect-error allow host env guard
                    window.SITE?.env !== "production"
                ) {
                    if (!res.ok) {
                        // eslint-disable-next-line no-console
                        console.warn(
                            "[CanvasProvider] snapshot.load() failed:",
                            res.error?.code ?? "load_error",
                            res.error?.message ?? "(no message)",
                        );
                    }
                }
            });
        }
    }, [ws]);

    // Pull initial ServiceProps from current editor snapshot (if present)
    const initialProps: ServiceProps | undefined = ws.snapshot.data?.props as
        | ServiceProps
        | undefined;

    // If the Workspace exposes services as a map, we can forward it to builderOpts.
    // (We avoid any normalization here; arrays are ignored by design.)
    const resolvedBuilderOpts: BuilderOptions | undefined = useMemo(() => {
        const svc = ws.services.data as unknown;
        const hasMap =
            svc != null &&
            typeof svc === "object" &&
            !Array.isArray(svc as unknown[]);
        return hasMap
            ? {
                  ...(builderOpts ?? {}),
                  serviceMap: svc as BuilderOptions["serviceMap"],
              }
            : builderOpts;
    }, [builderOpts, ws.services.data]);

    const { api } = useCanvasOwned(
        initialProps,
        canvasOpts,
        resolvedBuilderOpts,
    );

    return <Ctx.Provider value={api}>{children}</Ctx.Provider>;
}

export function useCanvasAPI(): CanvasAPI {
    const api = useContext(Ctx);
    if (!api)
        throw new Error("useCanvasAPI must be used within <CanvasProvider>");
    return api;
}

/**
 * Create & memoize a CanvasAPI from a Builder.
 * - Disposes the previous API when builder changes.
 * - Accepts both view/state options and backend options.
 * - Warns (DEV only) if `opts` identity is changing every render.
 */
export function useCanvasFromBuilder(
    builder: Builder,
    opts?: CanvasOptions & CanvasBackendOptions,
): CanvasAPI {
    // Warn (DEV) if the raw opts reference is churning each render
    useDevWarnOnOptsChurn(opts);

    // Stabilize opts content to avoid churn-driven re-instantiation
    const lastOptsRef = useRef<
        (CanvasOptions & CanvasBackendOptions) | undefined
    >(undefined);
    const stableOpts =
        opts &&
        lastOptsRef.current &&
        shallowEqualOpts(lastOptsRef.current, opts)
            ? lastOptsRef.current
            : (lastOptsRef.current = opts);

    const api = useMemo(
        () => new CanvasAPI(builder, stableOpts),
        [builder, stableOpts],
    );

    useEffect(() => {
        return () => {
            // Clean up listeners / timers when API instance is replaced or unmounted
            api.dispose?.();
        };
    }, [api]);

    return api;
}

/**
 * Use an existing CanvasAPI instance without creating/disposing anything.
 * Useful when the host fully manages the API lifecycle (e.g., from a parent).
 */
export function useCanvasFromExisting(api: CanvasAPI): CanvasAPI {
    // No disposal here‚Äîthe host owns the instance
    return api;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function shallowEqualOpts(
    a?: CanvasOptions & CanvasBackendOptions,
    b?: CanvasOptions & CanvasBackendOptions,
) {
    if (a === b) return true;
    if (!a || !b) return false;
    const aKeys = Object.keys(a) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    const bKeys = Object.keys(b) as (keyof (CanvasOptions &
        CanvasBackendOptions))[];
    if (aKeys.length !== bKeys.length) return false;
    for (const k of aKeys) {
        if ((a as any)[k] !== (b as any)[k]) return false;
    }
    return true;
}

/** DEV-only: warn if opts identity changes on most renders (suggests wrapping in useMemo). */
function useDevWarnOnOptsChurn(opts?: CanvasOptions & CanvasBackendOptions) {
    const rawRef = useRef<typeof opts>(undefined);
    const churnCountRef = useRef(0);
    const lastWindowStartRef = useRef<number>(Date.now());
    const warnedRef = useRef(false);

    useEffect(() => {
        // @ts-ignore
        if (window.SITE?.env === "production") return;
        const now = Date.now();

        // Reset window every 2s
        if (now - lastWindowStartRef.current > 2000) {
            lastWindowStartRef.current = now;
            churnCountRef.current = 0;
        }

        if (rawRef.current !== opts) {
            churnCountRef.current += 1;
            rawRef.current = opts;
        }

        // If we see churn on most renders in the window, warn once.
        if (!warnedRef.current && churnCountRef.current >= 5) {
            warnedRef.current = true;
            // eslint-disable-next-line no-console
            console.warn(
                "[digital-service-ui-builder] useCanvasFromBuilder: `opts` is changing identity frequently. " +
                    "Wrap your options in useMemo to avoid unnecessary API re-instantiation.",
            );
        }
    });
}

type UseCanvasOwnedReturn = { api: CanvasAPI; builder: Builder };

/** Creates a Builder once, loads initial props, and owns the CanvasAPI lifecycle. */
export function useCanvasOwned(
    initialProps?: ServiceProps,
    canvasOpts?: CanvasOptions & CanvasBackendOptions,
    builderOpts?: BuilderOptions, // ‚Üê pass builder params here
): UseCanvasOwnedReturn {
    // 1) Create the builder ONCE with the provided builder options
    const builderRef = useRef<Builder>();
    const builderOptsRef = useRef<BuilderOptions | undefined>(builderOpts);
    const loadedOnceRef = useRef<boolean>(false);

    if (!builderRef.current) {
        builderRef.current = createBuilder(builderOptsRef.current); // ‚Üê forwarded
        if (initialProps) {
            builderRef.current.load(initialProps);
            loadedOnceRef.current = true;
        }
        // @ts-ignore
    } else if (window.SITE?.env !== "production") {
        // Warn if builderOpts identity changes after first mount (they won't be applied)
        if (builderOptsRef.current !== builderOpts) {
            // eslint-disable-next-line no-console
            console.warn(
                "[useCanvasOwned] builderOpts changed after init; new values are ignored. " +
                    "If you need to recreate the builder, remount the hook (e.g. change a React key).",
            );
            builderOptsRef.current = builderOpts;
        }
    }
    const builder = builderRef.current!;

    // If initial props arrive later (async Workspace load), load them once.
    useEffect(() => {
        if (!loadedOnceRef.current && initialProps) {
            builderRef.current!.load(initialProps);
            loadedOnceRef.current = true;
        }
    }, [initialProps]);

    // 2) Stabilize canvas options to avoid churn re-instantiation of CanvasAPI
    const lastCanvasOptsRef = useRef<typeof canvasOpts>();
    const stableCanvasOpts = useMemo(() => {
        if (!lastCanvasOptsRef.current) {
            lastCanvasOptsRef.current = canvasOpts;
            return canvasOpts;
        }
        const a = canvasOpts ?? {};
        const b = lastCanvasOptsRef.current ?? {};
        const same = Object.keys({ ...a, ...b }).every(
            (k) => (a as any)[k] === (b as any)[k],
        );
        if (same) return lastCanvasOptsRef.current;
        lastCanvasOptsRef.current = canvasOpts;
        return canvasOpts;
    }, [canvasOpts]);

    // 3) Create CanvasAPI and dispose on change/unmount
    const api = useMemo(
        () => new CanvasAPI(builder, stableCanvasOpts),
        [builder, stableCanvasOpts],
    );

    useEffect(
        () => () => {
            api.dispose?.();
        },
        [api],
    );

    return { api, builder };
}
```

---
#### 13


` File: src/react/workspace/context/ctxmenu.tsx`  [‚Üë Back to top](#index)

```tsx
import { ContextMenuRenderer } from "@/react/workspace/components/context-menu-renderer";
import React, {
    createContext,
    useCallback,
    useContext,
    useEffect,
    useLayoutEffect,
    useMemo,
    useRef,
    useState,
} from "react";
import { createPortal } from "react-dom";
import { CanvasAPI } from "@/react";

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export type ContextScope =
    | "file"
    | "folder"
    | "library"
    | "empty"
    | (string & {});

export type ContextState = CtxWithAttach;

// Allow attaching UI-scoped helpers (e.g., Sidebar startAdd)
type CtxWithAttach = CanvasAPI;
export interface MenuItem {
    key?: React.Key;
    label?: string;
    icon?: React.ReactNode;
    hint?: string;
    divider?: boolean;
    danger?: boolean;
    disabled?: boolean | ((ctx: CtxWithAttach) => boolean);
    onSelect?: (args: {
        ctx: CtxWithAttach;
        nativeEvent: MouseEvent | KeyboardEvent;
    }) => void | Promise<void>;
    children?: MenuItem[];
}

interface InternalState {
    open: boolean;
    x: number;
    y: number;
    items: MenuItem[];
    ariaLabel?: string;
    ctx: CtxWithAttach;
}

export type MenuBuilder =
    | MenuItem[]
    | ((opts: {
          ctx: ContextState;
          nativeEvent?: MouseEvent;
      }) => MenuItem[] | Promise<MenuItem[]>);

export interface OpenOptions {
    /** A11y label for the menu. */
    ariaLabel?: string;
    /** Context state used by disabled predicates & callbacks. */
    ctx?: ContextState;
    /** If you already have precise coords, pass them. Otherwise we‚Äôll use the event‚Äôs clientX/Y. */
    coords?: { x: number; y: number };
    /** Native event (if any). */
    nativeEvent?: MouseEvent;
}

export interface ContextMenuApi {
    openAt: (
        evOrCoords: MouseEvent | { x: number; y: number },
        items: MenuBuilder,
        options?: OpenOptions,
    ) => void;
    close: () => void;
    /** Ergonomic helper for `onContextMenu={cm.bind(() => items, { ctx: ... })}` */
    bind: (
        builder: (ev: React.MouseEvent) => MenuBuilder | Promise<MenuBuilder>,
        options?: Omit<OpenOptions, "nativeEvent" | "coords">,
    ) => (ev: React.MouseEvent) => void;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Context ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const Ctx = createContext<ContextMenuApi | null>(null);

export const useContextMenu = (): ContextMenuApi => {
    const api = useContext(Ctx);
    if (!api) {
        throw new Error(
            "useContextMenu() must be used under <ContextMenuProvider>.",
        );
    }
    return api;
};

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Provider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

export const Ctxmenu: React.FC<{
    children: React.ReactNode;
    zIndex?: number;
}> = ({
    children,
    zIndex = 60, // sits above most app chrome; tweak if needed
}) => {
    const containerRef = useRef<HTMLDivElement | null>(null);

    const [state, setState] = useState<InternalState>({
        open: false,
        x: 0,
        y: 0,
        items: [],
        ariaLabel: "Context menu",
        //@ts-expect-error
        ctx: {},
    });

    const [measured, setMeasured] = useState<{ w: number; h: number }>({
        w: 0,
        h: 0,
    });

    // Close on outside click / ESC
    useEffect(() => {
        if (!state.open) return;

        const onDown = (e: MouseEvent) => {
            const el = containerRef.current;
            if (el && !el.contains(e.target as Node)) {
                setState((s) => ({ ...s, open: false }));
            }
        };
        const onKey = (e: KeyboardEvent) => {
            if (e.key === "Escape") {
                setState((s) => ({ ...s, open: false }));
            }
        };

        document.addEventListener("mousedown", onDown, true);
        document.addEventListener("keydown", onKey, true);
        return () => {
            document.removeEventListener("mousedown", onDown, true);
            document.removeEventListener("keydown", onKey, true);
        };
    }, [state.open]);

    // Clamp menu within viewport after render
    useLayoutEffect(() => {
        if (!state.open) return;
        const el = containerRef.current;
        if (!el) return;

        const rect = el.getBoundingClientRect();
        if (rect.width !== measured.w || rect.height !== measured.h) {
            setMeasured({ w: rect.width, h: rect.height });
        }

        const margin = 8;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let nx = state.x;
        let ny = state.y;

        if (nx + rect.width + margin > vw)
            nx = Math.max(margin, vw - rect.width - margin);
        if (ny + rect.height + margin > vh)
            ny = Math.max(margin, vh - rect.height - margin);

        if (nx !== state.x || ny !== state.y) {
            setState((s) => ({ ...s, x: nx, y: ny }));
        }
    }, [state.open, state.x, state.y, measured.w, measured.h]);

    const resolveItems = useCallback(
        async (items: MenuBuilder, opts: OpenOptions): Promise<MenuItem[]> => {
            let raw: MenuItem[] | Promise<MenuItem[]>;
            if (typeof items === "function") {
                raw = items({
                    //@ts-expect-error
                    ctx: opts.ctx ?? {},
                    nativeEvent: opts.nativeEvent,
                });
            } else {
                raw = items;
            }
            const resolved = await raw;
            return Array.isArray(resolved) ? resolved : [];
        },
        [],
    );

    const openAt = useCallback<ContextMenuApi["openAt"]>(
        async (evOrCoords, items, options) => {
            const nativeEvent =
                "x" in evOrCoords
                    ? options?.nativeEvent
                    : (evOrCoords as MouseEvent);
            const coords =
                "x" in evOrCoords
                    ? evOrCoords
                    : {
                          x: (evOrCoords as MouseEvent).clientX,
                          y: (evOrCoords as MouseEvent).clientY,
                      };

            if (
                !("x" in evOrCoords) &&
                (evOrCoords as MouseEvent).preventDefault
            ) {
                (evOrCoords as MouseEvent).preventDefault();
            }

            const resolved = await resolveItems(items, {
                ...(options ?? {}),
                nativeEvent,
            });
            setState({
                open: true,
                x: coords.x,
                y: coords.y,
                items: resolved,
                ariaLabel: options?.ariaLabel ?? "Context menu",
                //@ts-expect-error
                ctx: options?.ctx ?? {},
            });
        },
        [resolveItems],
    );

    const close = useCallback(
        () => setState((s) => ({ ...s, open: false })),
        [],
    );

    const bind = useCallback<ContextMenuApi["bind"]>(
        (builder, options) => {
            return (ev: React.MouseEvent) => {
                ev.preventDefault();
                const native: MouseEvent = ev.nativeEvent;
                const maybePromise = builder(ev);
                Promise.resolve(maybePromise).then((items) => {
                    openAt(
                        { x: native.clientX, y: native.clientY },
                        // If builder returned a function or array, pass through; openAt will resolve again safely.
                        typeof items === "function" || Array.isArray(items)
                            ? (items as MenuBuilder)
                            : [],
                        { ...(options ?? {}), nativeEvent: native },
                    );
                });
            };
        },
        [openAt],
    );

    const api = useMemo<ContextMenuApi>(
        () => ({ openAt, close, bind }),
        [openAt, close, bind],
    );

    return (
        <Ctx.Provider value={api}>
            {children}
            {state.open &&
                createPortal(
                    <div
                        ref={containerRef}
                        className="fixed z-[9999]"
                        style={{ left: state.x, top: state.y, zIndex }}
                        role="dialog"
                        aria-label={state.ariaLabel}
                    >
                        <ContextMenuRenderer
                            items={state.items}
                            ctx={state.ctx}
                            onClose={close}
                            onAction={(it, e) =>
                                it.onSelect?.({
                                    ctx: state.ctx,
                                    nativeEvent: e,
                                })
                            }
                        />
                    </div>,
                    document.body,
                )}
        </Ctx.Provider>
    );
};
```

---
#### 14


` File: src/react/workspace/context/index.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/context/index.ts

export {
    WorkspaceContext,
    useWorkspace,
    useWorkspaceMaybe,
} from "./provider/context";

export { WorkspaceProvider } from "./provider/provider";

export type {
    WorkspaceAPI,
    WorkspaceProviderProps,
    Loadable,
    SnapshotSlice,
    BranchesSlice,
} from "./provider/types";

/**
 * Live adapter contracts ‚Äî exposed so the host can implement custom adapters
 * (Echo, native WebSocket, SSE, custom protocols).
 */
export type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterRegistry,
    WorkspaceLiveAdapterHandlers,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "./provider/live/types";

/**
 * Default poll adapter ‚Äî hosts may use this or provide their own ws/sse adapters.
 */
export { createPollAdapter } from "./provider/live/adapters/poll";
```

---
#### 15


` File: src/react/workspace/context/memory-backend.ts`  [‚Üë Back to top](#index)

```ts
//@ts-nocheck
// src/react/workspace/memory-backend.ts
// In-memory WorkspaceBackend with Field Templates (plus a deprecated assets shim).
// noinspection JSConstantReassignment,JSDeprecatedSymbols

import type {
    Actor,
    Author,
    BackendError,
    Branch,
    BranchesBackend,
    Commit,
    Draft,
    FieldTemplate,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsBackend,
    SnapshotsLoadResult,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesBackend,
    TemplatesListParams,
    WorkspaceBackend,
} from "./backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";

/* ---------------- utilities ---------------- */

type Id = string;
const nowIso = () => new Date().toISOString();
const ok = <T>(value: T): { ok: true; value: T } => ({ ok: true, value });
const err = (
    code: string,
    message: string,
    hint?: string,
): { ok: false; error: BackendError } => ({
    ok: false,
    error: { code, message, hint },
});

function clone<T>(v: T): T {
    if (Array.isArray(v)) return v.slice() as unknown as T;
    if (typeof v === "object" && v !== null) return { ...(v as object) } as T;
    return v;
}
const genId = (p: string, i: number): Id => `${p}-${i}`;

/* ---------------- seed & store ---------------- */

export interface MemorySeed {
    workspaceId: string;
    authors?: Author[];
    permissionsForActor?: (ctx: {
        workspaceId: string;
        actor: Actor;
    }) => PermissionsMap;
    branchNames?: string[]; // default ["main"]
    initialSnapshot?: ServiceSnapshot;
    initialHeadMessage?: string;
    initialDraft?: boolean;
    services?: readonly DgpServiceCapability[] | DgpServiceMap;

    /** Pre-seed field templates */
    templates?: ReadonlyArray<
        Pick<
            FieldTemplate,
            | "key"
            | "name"
            | "kind"
            | "definition"
            | "defaults"
            | "ui"
            | "validators"
            | "tags"
            | "category"
            | "published"
        > & { branchId?: string }
    >;
}

interface Store {
    readonly workspaceId: string;
    authors: Author[];
    permissionsForActor: (actor: Actor) => PermissionsMap;

    branches: Branch[];
    mainId: string;

    templates: FieldTemplate[];

    snapshot: ServiceSnapshot;
    head?: Commit;
    draft?: Draft;

    counters: { id: number; version: number; template: number };
}

/* ---------------- factory ---------------- */

export function createMemoryWorkspaceBackend(seed: MemorySeed): WorkspaceBackend {
    const wsId = seed.workspaceId;
    let idCounter = 1;
    let versionCounter = 1;
    let templateCounter = 1;

    // branches
    const names = seed.branchNames?.length ? seed.branchNames : ["main"];
    const branches: Branch[] = names.map(
        (name): Branch => ({
            id: genId("branch", idCounter++),
            name,
            isMain: false,
            createdAt: nowIso(),
            updatedAt: nowIso(),
        }),
    );
    const mainIdx = Math.max(
        0,
        branches.findIndex((b) => b.name.toLowerCase() === "main"),
    );
    branches.forEach((b, i) => (b.isMain = i === (mainIdx >= 0 ? mainIdx : 0)));
    const mainId = branches.find((b) => b.isMain)!.id;

    // authors / permissions
    const authors = seed.authors ?? [];
    const perms = seed.permissionsForActor
        ? (actor: Actor) =>
              seed.permissionsForActor!({ workspaceId: wsId, actor })
        : (_actor: Actor) => ({ "*": true });

    // snapshot pointers
    const snapshot: ServiceSnapshot = seed.initialSnapshot ?? {
        schema_version: "1.0",
        data: {} as EditorSnapshot,
    };
    const head: Commit | undefined = seed.initialHeadMessage
        ? {
              id: genId("commit", versionCounter++),
              branchId: mainId,
              message: seed.initialHeadMessage,
              versionId: genId("version", versionCounter++),
              etag: `etag-${Date.now()}`,
              createdAt: nowIso(),
          }
        : undefined;
    const draft: Draft | undefined = seed.initialDraft
        ? {
              id: genId("draft", versionCounter++),
              branchId: mainId,
              status: "uncommitted",
              etag: `draft-${Date.now()}`,
              createdAt: nowIso(),
              updatedAt: nowIso(),
          }
        : undefined;

    // templates
    const templates: FieldTemplate[] = (seed.templates ?? []).map(
        (t): FieldTemplate => ({
            id: genId("tpl", templateCounter++),
            key: t.key,
            name: t.name,
            kind: t.kind,
            branchId: t.branchId,
            definition: clone(t.definition ?? {}),
            defaults: t.defaults ? clone(t.defaults) : undefined,
            ui: t.ui ? clone(t.ui) : undefined,
            validators: t.validators ? clone(t.validators) : undefined,
            tags: t.tags ? clone(t.tags) : undefined,
            category: t.category,
            published: t.published ?? false,
            version: 1,
            createdAt: nowIso(),
            updatedAt: nowIso(),
        }),
    );

    const store: Store = {
        workspaceId: wsId,
        authors,
        permissionsForActor: perms,
        branches,
        mainId,
        templates,
        snapshot,
        head,
        draft,
        counters: {
            id: idCounter,
            version: versionCounter,
            template: templateCounter,
        },
    };

    /* ---------------- authors backend ---------------- */

    const authorsBackend = {
        async list(workspaceId: string): Result<readonly Author[]> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.authors));
        },
        async get(authorId: string): Result<Author | null> {
            const a = store.authors.find((x) => x.id === authorId) ?? null;
            return ok(a ? clone(a) : null);
        },
        async refresh(workspaceId: string): Result<readonly Author[]> {
            return this.list(workspaceId);
        },
    };

    /* ---------------- permissions backend ---------------- */

    const permissionsBackend = {
        async get(workspaceId: string, actor: Actor): Result<PermissionsMap> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.permissionsForActor(actor)));
        },
        async refresh(
            workspaceId: string,
            actor: Actor,
        ): Result<PermissionsMap> {
            return this.get(workspaceId, actor);
        },
    };

    /* ---------------- branches backend ---------------- */

    const branchesBackend: BranchesBackend = {
        async list(workspaceId: string): Result<readonly Branch[]> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok(clone(store.branches));
        },
        async create(
            workspaceId: string,
            name: string,
            opts?: Readonly<{ fromId?: string }>,
        ): Result<Branch> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const now = nowIso();
            const fromId = opts?.fromId;
            const headVersionId = fromId
                ? store.branches.find((b) => b.id === fromId)?.headVersionId
                : undefined;
            const b: Branch = {
                id: genId("branch", ++store.counters.id),
                name,
                isMain: false,
                headVersionId,
                createdAt: now,
                updatedAt: now,
            };
            store.branches.push(b);
            return ok(clone(b));
        },
        async setMain(workspaceId: string, branchId: string): Result<Branch> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const target = store.branches.find((b) => b.id === branchId);
            if (!target) return err("not_found", "Branch not found");
            store.branches.forEach((b) => (b.isMain = b.id === branchId));
            store.mainId = branchId;
            target.updatedAt = nowIso();
            return ok(clone(target));
        },
        async merge(
            workspaceId: string,
            sourceId: string,
            targetId: string,
        ): Result<MergeResult> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const src = store.branches.find((b) => b.id === sourceId);
            const tgt = store.branches.find((b) => b.id === targetId);
            if (!src || !tgt)
                return err("not_found", "Source or target branch not found");
            const merge: MergeResult = {
                sourceId,
                targetId,
                conflicts: 0,
                message: "Fast-forward (memory)",
            };
            tgt.headVersionId = genId("version", ++store.counters.version);
            tgt.updatedAt = nowIso();
            return ok(merge);
        },
        async delete(workspaceId: string, branchId: string): Result<void> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const idx = store.branches.findIndex((b) => b.id === branchId);
            if (idx < 0) return err("not_found", "Branch not found");
            if (store.branches[idx].isMain)
                return err("forbidden", "Cannot delete main branch");
            store.branches.splice(idx, 1);
            return ok(undefined);
        },
        async refresh(workspaceId: string): Result<readonly Branch[]> {
            return this.list(workspaceId);
        },
    };

    /* ---------------- templates backend ---------------- */

    const templatesBackend: TemplatesBackend = {
        async list(
            params: TemplatesListParams,
        ): Result<readonly FieldTemplate[]> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            let items = store.templates.slice();
            if (params.branchId)
                items = items.filter((t) => t.branchId === params.branchId);
            if (params.q) {
                const q = params.q.toLowerCase();
                items = items.filter(
                    (t) =>
                        t.name.toLowerCase().includes(q) ||
                        t.key.toLowerCase().includes(q) ||
                        (t.tags ?? []).some((tag) =>
                            tag.toLowerCase().includes(q),
                        ),
                );
            }
            if (params.tags?.length) {
                items = items.filter((t) => {
                    const set = new Set(
                        (t.tags ?? []).map((x) => x.toLowerCase()),
                    );
                    return params.tags!.every((tg) =>
                        set.has(tg.toLowerCase()),
                    );
                });
            }
            if (params.category) {
                items = items.filter(
                    (t) =>
                        (t.category ?? "").toLowerCase() ===
                        params.category!.toLowerCase(),
                );
            }
            return ok(clone(items));
        },

        async get(id: string): Result<FieldTemplate | null> {
            const t = store.templates.find((x) => x.id === id) ?? null;
            return ok(t ? clone(t) : null);
        },

        async getByKey(
            workspaceId: string,
            key: string,
            branchId?: string,
        ): Result<FieldTemplate | null> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const t =
                store.templates.find(
                    (x) =>
                        x.key === key &&
                        (branchId ? x.branchId === branchId : true),
                ) ?? null;
            return ok(t ? clone(t) : null);
        },

        async create(
            workspaceId: string,
            input: TemplateCreateInput,
        ): Result<FieldTemplate> {
            if (workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            const key = input.key ?? suggestKey(input.name);
            if (
                store.templates.some(
                    (t) =>
                        t.key === key &&
                        (input.branchId
                            ? t.branchId === input.branchId
                            : !t.branchId),
                )
            ) {
                return err("conflict", "Template key already exists");
            }
            const t: FieldTemplate = {
                id: genId("tpl", ++store.counters.template),
                key,
                name: input.name,
                kind: input.kind,
                branchId: input.branchId,
                definition: clone(input.definition ?? {}),
                defaults: input.defaults ? clone(input.defaults) : undefined,
                ui: input.ui ? clone(input.ui) : undefined,
                validators: input.validators
                    ? clone(input.validators)
                    : undefined,
                tags: input.tags ? clone(input.tags) : undefined,
                category: input.category,
                published: input.published ?? false,
                version: 1,
                createdAt: nowIso(),
                updatedAt: nowIso(),
            };
            store.templates.push(t);
            return ok(clone(t));
        },

        async update(
            id: string,
            patch: TemplateUpdatePatch,
        ): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            if (patch.name !== undefined) t.name = patch.name;
            if (patch.kind !== undefined) t.kind = patch.kind;
            if (patch.branchId !== undefined)
                t.branchId = patch.branchId ?? undefined;
            if (patch.definition !== undefined)
                t.definition = clone(patch.definition);
            if (patch.defaults !== undefined)
                t.defaults = patch.defaults ? clone(patch.defaults) : undefined;
            if (patch.ui !== undefined)
                t.ui = patch.ui ? clone(patch.ui) : undefined;
            if (patch.validators !== undefined)
                t.validators = patch.validators
                    ? clone(patch.validators)
                    : undefined;
            if (patch.tags !== undefined)
                t.tags = patch.tags ? clone(patch.tags) : undefined;
            if (patch.category !== undefined)
                t.category = patch.category ?? undefined;
            if (patch.published !== undefined) t.published = patch.published;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async clone(
            source: Readonly<{ id?: string; key?: string }>,
            opts?: Readonly<{
                newKey?: string;
                name?: string;
                branchId?: string;
                asDraft?: boolean;
            }>,
        ): Result<FieldTemplate> {
            const orig =
                (source.id &&
                    store.templates.find((x) => x.id === source.id)) ||
                (source.key &&
                    store.templates.find((x) => x.key === source.key)) ||
                null;
            if (!orig) return err("not_found", "Source template not found");
            const key = opts?.newKey ?? uniqueKey(orig.key);
            const t: FieldTemplate = {
                ...clone(orig),
                id: genId("tpl", ++store.counters.template),
                key,
                name: opts?.name ?? `${orig.name} Copy`,
                branchId: opts?.branchId ?? orig.branchId,
                published: opts?.asDraft ? false : orig.published,
                version: 1,
                createdAt: nowIso(),
                updatedAt: nowIso(),
            };
            store.templates.push(t);
            return ok(clone(t));
        },

        async publish(id: string): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            t.published = true;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async unpublish(id: string): Result<FieldTemplate> {
            const t = store.templates.find((x) => x.id === id);
            if (!t) return err("not_found", "Template not found");
            t.published = false;
            t.version += 1;
            t.updatedAt = nowIso();
            return ok(clone(t));
        },

        async delete(id: string): Result<void> {
            const i = store.templates.findIndex((x) => x.id === id);
            if (i < 0) return err("not_found", "Template not found");
            store.templates.splice(i, 1);
            return ok(undefined);
        },

        async refresh(
            params: Omit<TemplatesListParams, "q" | "tags" | "category">,
        ): Result<readonly FieldTemplate[]> {
            return this.list(params as TemplatesListParams);
        },
    };

    function suggestKey(name: string): string {
        const base = name
            .trim()
            .toLowerCase()
            .replace(/\s+/g, "-")
            .replace(/[^a-z0-9\-]/g, "");
        return uniqueKey(base || "template");
    }
    function uniqueKey(base: string): string {
        let k = base;
        let i = 1;
        while (store.templates.some((t) => t.key === k)) {
            k = `${base}-${++i}`;
        }
        return k;
    }

    /* ---------------- snapshots backend ---------------- */

    const snapshotsBackend: SnapshotsBackend = {
        async load(params): Result<SnapshotsLoadResult> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok({
                head: store.head ? clone(store.head) : undefined,
                draft: store.draft ? clone(store.draft) : undefined,
                snapshot: clone(store.snapshot),
            });
        },
        async autosave(params): Result<{ draft: Draft }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            store.snapshot = clone(params.snapshot);
            const d: Draft = {
                id: store.draft?.id ?? genId("draft", ++store.counters.version),
                branchId: params.branchId,
                status: "uncommitted",
                etag: `draft-${Date.now()}`,
                createdAt: store.draft?.createdAt ?? nowIso(),
                updatedAt: nowIso(),
            };
            store.draft = d;
            return ok({ draft: clone(d) });
        },
        async save(params): Result<{ commit: Commit }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            store.snapshot = clone(params.snapshot);
            const commit: Commit = {
                id: genId("commit", ++store.counters.version),
                branchId: params.branchId,
                message: params.message ?? "Save (memory)",
                versionId: genId("version", ++store.counters.version),
                etag: `etag-${Date.now()}`,
                createdAt: nowIso(),
            };
            store.head = commit;
            store.draft = undefined;
            const tgt = store.branches.find((b) => b.id === params.branchId);
            if (tgt) {
                tgt.headVersionId = commit.versionId;
                tgt.updatedAt = nowIso();
            }
            return ok({ commit: clone(commit) });
        },
        async publish(params): Result<{ commit: Commit }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            if (!store.draft || store.draft.id !== params.draftId)
                return err("not_found", "Draft not found");
            const commit: Commit = {
                id: genId("commit", ++store.counters.version),
                branchId: store.draft.branchId,
                message: params.message ?? "Publish (memory)",
                versionId: genId("version", ++store.counters.version),
                etag: `etag-${Date.now()}`,
                createdAt: nowIso(),
            };
            store.head = commit;
            store.draft = undefined;
            const tgt = store.branches.find((b) => b.id === commit.branchId);
            if (tgt) {
                tgt.headVersionId = commit.versionId;
                tgt.updatedAt = nowIso();
            }
            return ok({ commit: clone(commit) });
        },
        async discard(params): Result<void> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            if (!store.draft || store.draft.id !== params.draftId)
                return err("not_found", "Draft not found");
            store.draft = undefined;
            return ok(undefined);
        },
        async refresh(params): Result<{ head?: Commit; draft?: Draft }> {
            if (params.workspaceId !== store.workspaceId)
                return err("bad_workspace", "Unknown workspace id");
            return ok({
                head: store.head ? clone(store.head) : undefined,
                draft: store.draft ? clone(store.draft) : undefined,
            });
        },
    };

    /* ---------------- compose backend ---------------- */

    const backend: WorkspaceBackend = {
        info: {
            id: wsId,
            name: "Workspace 101",
            createdAt: nowIso(),
            updatedAt: nowIso(),
        },
        authors: authorsBackend,
        permissions: permissionsBackend,
        branches: branchesBackend,
        templates: templatesBackend,
        snapshots: snapshotsBackend,
        services: seed.services,
    };

    return backend;
}
```

---
#### 16


` File: src/react/workspace/context/provider/compose/use-branch-cache.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-branch-cache.ts
import * as React from "react";
import type { BranchCacheEntry, Loadable, SnapshotSlice } from "../types";
import type { FieldTemplate, BranchParticipant } from "../../backend";

import { createCache, createIndexedDBDriver } from "@timeax/cache-store";
import type { CacheStore } from "@timeax/cache-store";

export interface BranchCacheApi {
    /**
     * Clear cached branch scopes for THIS workspace.
     */
    readonly clear: () => void;

    readonly switchBranch: (
        args: Readonly<{
            /**
             * Redundant on purpose: call-sites must pass workspaceId explicitly,
             * and the hook is also workspace-scoped.
             *
             * This allows us to detect wiring bugs (mismatched workspace scopes).
             */
            workspaceId: string;

            nextId: string;
            prevId?: string;

            templates: Loadable<readonly FieldTemplate[]>;
            participants: Loadable<readonly BranchParticipant[]>;
            snapshot: SnapshotSlice;

            setTemplates: React.Dispatch<
                React.SetStateAction<Loadable<readonly FieldTemplate[]>>
            >;
            setParticipants: React.Dispatch<
                React.SetStateAction<Loadable<readonly BranchParticipant[]>>
            >;
            setSnapshot: React.Dispatch<React.SetStateAction<SnapshotSlice>>;

            resetTemplates: () => void;
            resetParticipants: () => void;
            resetSnapshot: () => void;

            setCurrentBranchId: (id: string) => void;

            hasInitialSnapshot: boolean;

            loadSnapshotForBranch: (branchId: string) => void;
        }>,
    ) => void;
}

const DB_NAME = "dgp-cache";
const STORE_NAME = "kv";
const NS = "workspace";

// Key scheme (per workspace):
//   ws:<workspaceId>:branch:<branchId>
const WS_PREFIX = "ws:";
const keyOf = (workspaceId: string, branchId: string): string =>
    `${WS_PREFIX}${workspaceId}:branch:${branchId}`;

const branchPrefixOf = (workspaceId: string): string =>
    `${WS_PREFIX}${workspaceId}:branch:`;

type PendingSwitch = Readonly<{
    workspaceId: string;
    nextId: string;
    hasInitialSnapshot: boolean;

    setTemplates: React.Dispatch<
        React.SetStateAction<Loadable<readonly FieldTemplate[]>>
    >;
    setParticipants: React.Dispatch<
        React.SetStateAction<Loadable<readonly BranchParticipant[]>>
    >;
    setSnapshot: React.Dispatch<React.SetStateAction<SnapshotSlice>>;

    loadSnapshotForBranch: (branchId: string) => void;
}>;

export function useBranchCache(workspaceId: string): BranchCacheApi {
    // IndexedDB-backed cache instance (scoped by ns + key prefixing).
    const cache: CacheStore = React.useMemo(() => {
        return createCache({
            driver: createIndexedDBDriver({
                dbName: DB_NAME,
                storeName: STORE_NAME,
                ns: NS,
            }),
            hydrate: true,
            cleanupExpiredOnHydrate: true,
        });
    }, []);

    const wsIdRef = React.useRef<string>(workspaceId);
    React.useEffect(() => {
        wsIdRef.current = workspaceId;
    }, [workspaceId]);

    // IDB hydration is async. We keep it internal to preserve the hook API.
    const readyRef = React.useRef<boolean>(cache.isReady());

    // If switchBranch runs before hydration completes, we defer the ‚Äúload snapshot‚Äù decision.
    const pendingRef = React.useRef<PendingSwitch | null>(null);

    const applyCached = React.useCallback(
        (
            wsId: string,
            nextId: string,
            p: PendingSwitch,
        ): { cached?: BranchCacheEntry; hasCachedSnapshot: boolean } => {
            const cached = cache.get<BranchCacheEntry>(keyOf(wsId, nextId));

            if (cached) {
                p.setTemplates(cached.templates);
                p.setParticipants(cached.participants);
                p.setSnapshot(cached.snapshot);
            }

            const hasCachedSnapshot = Boolean(
                cached?.snapshot?.data && cached?.snapshot?.schemaVersion,
            );

            return { cached, hasCachedSnapshot };
        },
        [cache],
    );

    React.useEffect(() => {
        if (cache.isReady()) {
            readyRef.current = true;
            return;
        }

        const unsub = cache.subscribeReady(() => {
            readyRef.current = true;

            const p = pendingRef.current;
            if (!p) return;

            const { hasCachedSnapshot } = applyCached(
                p.workspaceId,
                p.nextId,
                p,
            );

            if (!hasCachedSnapshot && !p.hasInitialSnapshot) {
                p.loadSnapshotForBranch(p.nextId);
            }

            pendingRef.current = null;
        });

        return () => unsub();
    }, [cache, applyCached]);

    const clear = React.useCallback((): void => {
        pendingRef.current = null;

        // Clear ONLY this workspace scope.
        cache.clear(branchPrefixOf(wsIdRef.current));
    }, [cache]);

    const switchBranch = React.useCallback(
        (
            args: Readonly<{
                workspaceId: string;

                nextId: string;
                prevId?: string;

                templates: Loadable<readonly FieldTemplate[]>;
                participants: Loadable<readonly BranchParticipant[]>;
                snapshot: SnapshotSlice;

                setTemplates: React.Dispatch<
                    React.SetStateAction<Loadable<readonly FieldTemplate[]>>
                >;
                setParticipants: React.Dispatch<
                    React.SetStateAction<Loadable<readonly BranchParticipant[]>>
                >;
                setSnapshot: React.Dispatch<
                    React.SetStateAction<SnapshotSlice>
                >;

                resetTemplates: () => void;
                resetParticipants: () => void;
                resetSnapshot: () => void;

                setCurrentBranchId: (id: string) => void;

                hasInitialSnapshot: boolean;

                loadSnapshotForBranch: (branchId: string) => void;
            }>,
        ): void => {
            const hookWsId: string = wsIdRef.current;
            const callWsId: string = args.workspaceId;

            // Redundant-by-design safety check (catch wiring mistakes).
            if (callWsId !== hookWsId) {
                // Keep it non-fatal (warn) to avoid breaking UX in production.
                // If you want strict behavior later, we can throw in dev only.
                // eslint-disable-next-line no-console
                console.warn(
                    `[useBranchCache] workspaceId mismatch: hook="${hookWsId}" vs switchBranch="${callWsId}". Using switchBranch workspaceId.`,
                );
            }

            const wsId: string = callWsId;
            const prevId: string | undefined = args.prevId;

            // Cache previous branch scope (per workspace).
            if (prevId && prevId !== args.nextId) {
                cache.set<BranchCacheEntry>(keyOf(wsId, prevId), {
                    templates: args.templates,
                    participants: args.participants,
                    snapshot: args.snapshot,
                });
            }

            // Try to read cached next branch from mirror (may be empty before hydration).
            const cached = cache.get<BranchCacheEntry>(
                keyOf(wsId, args.nextId),
            );

            if (cached) {
                args.setTemplates(cached.templates);
                args.setParticipants(cached.participants);
                args.setSnapshot(cached.snapshot);
            } else {
                args.resetTemplates();
                args.resetParticipants();
                args.resetSnapshot();
            }

            args.setCurrentBranchId(args.nextId);

            const hasCachedSnapshot: boolean = Boolean(
                cached?.snapshot?.data && cached?.snapshot?.schemaVersion,
            );

            // If not hydrated yet, defer the ‚Äúno cache ‚Üí load snapshot‚Äù decision because hydration
            // might bring in a cached snapshot for this workspace+branch.
            if (!readyRef.current && !hasCachedSnapshot) {
                pendingRef.current = {
                    workspaceId: wsId,
                    nextId: args.nextId,
                    hasInitialSnapshot: args.hasInitialSnapshot,
                    setTemplates: args.setTemplates,
                    setParticipants: args.setParticipants,
                    setSnapshot: args.setSnapshot,
                    loadSnapshotForBranch: args.loadSnapshotForBranch,
                };
                return;
            }

            // Normal behavior once ready (or when already has cached snapshot).
            if (!hasCachedSnapshot && !args.hasInitialSnapshot) {
                args.loadSnapshotForBranch(args.nextId);
            } else {
                pendingRef.current = null;
            }
        },
        [cache],
    );

    return React.useMemo<BranchCacheApi>(
        () => ({ clear, switchBranch }),
        [clear, switchBranch],
    );
}
```

---
#### 17


` File: src/react/workspace/context/provider/compose/use-live-polling.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-live-polling.ts
import * as React from "react";
import type { Actor, BackendError, LiveOptions } from "../../backend";
import type { RunResult } from "../types";
import type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterRegistry,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "../live/types";
import { createPollAdapter } from "../live/adapters/poll";

export interface LiveControl {
    readonly connected: boolean;
    readonly lastEventAt?: number;
    readonly lastError?: BackendError;
    readonly connect: () => void;
    readonly disconnect: () => void;
}

export interface UseLivePollingParams {
    readonly live: LiveOptions;
    readonly workspaceId: string;
    readonly actor: Actor;

    readonly hasAnyData: boolean;

    readonly getCurrentBranchId: () => string | undefined;

    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;
    readonly refreshBranchContext?: () => Promise<void>;
    readonly refreshSnapshotPointers?: () => Promise<void>;

    /**
     * Host can provide adapters for modes like "ws" / "sse"
     * (and even custom strings later).
     */
    readonly adapters?: WorkspaceLiveAdapterRegistry;

    /**
     * Simple debounce to avoid refresh storms (WS bursts etc).
     * Default: 250ms
     */
    readonly debounceMs?: number;
}

function toError(e: unknown): BackendError {
    if (
        typeof e === "object" &&
        e &&
        "code" in (e as Record<string, unknown>) &&
        "message" in (e as Record<string, unknown>)
    ) {
        return e as BackendError;
    }
    if (e instanceof Error) {
        return { code: "runtime_error", message: `${e.name}: ${e.message}` };
    }
    return { code: "unknown_error", message: String(e ?? "Unknown error") };
}

export function useLivePolling(params: UseLivePollingParams): LiveControl {
    const {
        live,
        workspaceId,
        actor,
        hasAnyData,
        getCurrentBranchId,
        refreshAll,
        refreshBranchContext,
        refreshSnapshotPointers,
        adapters,
        debounceMs,
    } = params;

    const [status, setStatus] = React.useState<WorkspaceLiveStatus>(() => ({
        connected: false,
    }));

    const adapterRef = React.useRef<WorkspaceLiveAdapter | null>(null);
    const inflightRef = React.useRef<boolean>(false);
    const debounceTimerRef = React.useRef<number | null>(null);
    const lastTickRef = React.useRef<WorkspaceLiveTick | null>(null);

    const debounceWindowMs: number = debounceMs ?? 250;

    const disconnect = React.useCallback((): void => {
        if (debounceTimerRef.current != null) {
            window.clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = null;
        }
        adapterRef.current?.disconnect();
        adapterRef.current = null;
        inflightRef.current = false;
        lastTickRef.current = null;
        setStatus({ connected: false });
    }, []);

    const resolveAdapter =
        React.useCallback((): WorkspaceLiveAdapter | null => {
            if (live.mode === "off") return null;

            if (live.mode === "poll") {
                return createPollAdapter({ defaultIntervalMs: 15000 });
            }

            // ws/sse (or future modes) must be provided by host registry
            const reg: WorkspaceLiveAdapterRegistry | undefined = adapters;
            const factory = reg ? reg[live.mode] : undefined;

            return factory ? factory() : null;
        }, [live.mode, adapters]);

    const ctx = React.useMemo<WorkspaceLiveAdapterContext>(
        () => ({
            workspaceId,
            actorId: actor.id,
            live,
            getCurrentBranchId,
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers,
        }),
        [
            workspaceId,
            actor.id,
            live,
            getCurrentBranchId,
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers,
        ],
    );

    const scheduleRefresh = React.useCallback(
        (tick: WorkspaceLiveTick): void => {
            lastTickRef.current = tick;

            if (debounceTimerRef.current != null) {
                window.clearTimeout(debounceTimerRef.current);
                debounceTimerRef.current = null;
            }

            debounceTimerRef.current = window.setTimeout(() => {
                debounceTimerRef.current = null;

                if (inflightRef.current) return;
                inflightRef.current = true;

                void (async () => {
                    try {
                        const res: RunResult = await refreshAll({
                            strict: false,
                        });

                        if (!res.ok) {
                            setStatus((s) => ({
                                ...s,
                                connected: true,
                                lastEventAt: tick.at,
                                lastError: res.errors[0],
                            }));
                        } else {
                            setStatus((s) => ({
                                ...s,
                                connected: true,
                                lastEventAt: tick.at,
                                lastError: undefined,
                            }));
                        }
                    } catch (e: unknown) {
                        setStatus((s) => ({
                            ...s,
                            connected: true,
                            lastEventAt: tick.at,
                            lastError: toError(e),
                        }));
                    } finally {
                        inflightRef.current = false;
                    }
                })();
            }, debounceWindowMs) as unknown as number;
        },
        [refreshAll, debounceWindowMs],
    );

    const connect = React.useCallback((): void => {
        // idempotent: disconnect current first
        disconnect();

        if (live.mode === "off") {
            setStatus({ connected: false });

            // parity with old behavior: if nothing loaded yet, do an initial refresh
            if (!hasAnyData) {
                void (async () => {
                    await refreshAll({ strict: false });
                })();
            }

            return;
        }

        const adapter: WorkspaceLiveAdapter | null = resolveAdapter();

        if (!adapter) {
            setStatus({
                connected: false,
                lastError: {
                    code: "live_adapter_missing",
                    message: `No live adapter registered for mode "${live.mode}".`,
                },
            });
            return;
        }

        adapterRef.current = adapter;

        void Promise.resolve(
            adapter.connect(ctx, {
                onTick: (tick: WorkspaceLiveTick) => {
                    // treat any tick as ‚Äúrefresh now‚Äù
                    scheduleRefresh(tick);
                },
                onStatus: (s: WorkspaceLiveStatus) => {
                    setStatus((prev) => ({
                        ...prev,
                        ...s,
                    }));
                },
            }),
        ).catch((e: unknown) => {
            setStatus({
                connected: false,
                lastError: toError(e),
            });
        });
    }, [
        disconnect,
        live.mode,
        hasAnyData,
        refreshAll,
        resolveAdapter,
        ctx,
        scheduleRefresh,
    ]);

    // Auto-connect/disconnect based on (workspaceId + live.mode + key options)
    const liveKey: string = React.useMemo(() => {
        if (live.mode === "poll") return `poll:${live.intervalMs ?? 15000}`;
        if (live.mode === "ws") return `ws:${live.url}`;
        if (live.mode === "sse") return `sse:${live.url}`;
        return String(live.mode);
    }, [live]);

    React.useEffect(() => {
        connect();
        return () => disconnect();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [workspaceId, liveKey]);

    return React.useMemo<LiveControl>(
        () => ({
            connected: status.connected,
            lastEventAt: status.lastEventAt,
            lastError: status.lastError,
            connect,
            disconnect,
        }),
        [
            status.connected,
            status.lastEventAt,
            status.lastError,
            connect,
            disconnect,
        ],
    );
}
```

---
#### 18


` File: src/react/workspace/context/provider/compose/use-workspace-refresh.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/compose/use-workspace-refresh.ts
import * as React from "react";
import type { RunResult } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface WorkspaceRefreshApi {
    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;

    // NOTE: still callable as refreshBranchContext() ‚Äî we just allow optional params.
    readonly refreshBranchContext: (
        opts?: Readonly<{
            branchId?: string;

            /**
             * When true, errors stop the chain (same meaning as refreshAll strict).
             * Defaults to false (tolerant).
             */
            strict?: boolean;

            /**
             * Include workspace-scoped refreshes that are often ‚Äúbranch-relevant‚Äù in practice
             * (services, permissions, authors). Defaults to true.
             */
            includeWorkspaceData?: boolean;
        }>,
    ) => Promise<void>;

    // NOTE: still callable as refreshSnapshotPointers() ‚Äî optional params allowed.
    readonly refreshSnapshotPointers: (
        opts?: Readonly<{
            branchId?: string;
            strict?: boolean;
        }>,
    ) => Promise<void>;
}

export interface UseWorkspaceRefreshParams {
    readonly runtime: BackendRuntime;

    readonly refreshAuthors: () => Promise<void>;
    readonly refreshPermissions: () => Promise<void>;
    readonly refreshBranches: () => Promise<void>;
    readonly refreshServices: () => Promise<void>;

    readonly getCurrentBranchId: () => string | undefined;

    readonly refreshTemplates: (
        params?: Partial<{ branchId: string }>,
    ) => Promise<void>;
    readonly refreshParticipants: (
        params?: Partial<{ branchId: string }>,
    ) => Promise<void>;

    readonly refreshSnapshotPointersForBranch: (
        branchId: string,
    ) => Promise<void>;
    readonly refreshSnapshotPointers: () => Promise<void>;
}

export function useWorkspaceRefresh(
    params: UseWorkspaceRefreshParams,
): WorkspaceRefreshApi {
    const {
        runtime,
        refreshAuthors,
        refreshPermissions,
        refreshBranches,
        refreshServices,
        getCurrentBranchId,
        refreshTemplates,
        refreshParticipants,
        refreshSnapshotPointersForBranch,
        refreshSnapshotPointers,
    } = params;

    const refreshBranchLocalContext = React.useCallback(
        async (branchId: string, tolerant: boolean): Promise<RunResult> => {
            return runtime.runTasks(
                [
                    () => refreshParticipants({ branchId }),
                    () => refreshTemplates({ branchId }),
                    () => refreshSnapshotPointersForBranch(branchId),
                ],
                tolerant,
            );
        },
        [
            runtime,
            refreshParticipants,
            refreshTemplates,
            refreshSnapshotPointersForBranch,
        ],
    );

    const refreshBranchContext = React.useCallback(
        async (
            opts?: Readonly<{
                branchId?: string;
                strict?: boolean;
                includeWorkspaceData?: boolean;
            }>,
        ): Promise<void> => {
            const branchId: string | undefined =
                opts?.branchId ?? getCurrentBranchId();

            if (!branchId) return;

            const tolerant: boolean = !(opts?.strict ?? false);
            const includeWorkspaceData: boolean =
                opts?.includeWorkspaceData ?? true;

            // The ‚Äúpractical‚Äù expectation: branch refresh should refresh branch-local data
            // AND other workspace data that impacts the branch experience.
            // (Services, authors/permissions often impact what a branch can do/render.)
            const tasks: Array<() => Promise<unknown>> = [];

            if (includeWorkspaceData) {
                tasks.push(() => refreshAuthors());
                tasks.push(() => refreshPermissions());
                tasks.push(() => refreshServices());
            }

            tasks.push(() => refreshBranchLocalContext(branchId, tolerant));

            await runtime.runTasks(tasks, tolerant);
        },
        [
            getCurrentBranchId,
            runtime,
            refreshAuthors,
            refreshPermissions,
            refreshServices,
            refreshBranchLocalContext,
        ],
    );

    const refreshAll = React.useCallback(
        async (opts?: { strict?: boolean }): Promise<RunResult> => {
            const tolerant: boolean = !(opts?.strict ?? false);

            // Avoid duplicate workspace refresh work:
            // refreshAll() does workspace-wide first, then branch-local only.
            const branchId: string | undefined = getCurrentBranchId();

            const tasks: Array<() => Promise<unknown>> = [
                () => refreshAuthors(),
                () => refreshPermissions(),
                () => refreshBranches(),
                () => refreshServices(),
            ];

            if (branchId) {
                tasks.push(() => refreshBranchLocalContext(branchId, tolerant));
            }

            return runtime.runTasks(tasks, tolerant);
        },
        [
            runtime,
            refreshAuthors,
            refreshPermissions,
            refreshBranches,
            refreshServices,
            getCurrentBranchId,
            refreshBranchLocalContext,
        ],
    );

    const refreshSnapshotPointersWrapped = React.useCallback(
        async (
            opts?: Readonly<{ branchId?: string; strict?: boolean }>,
        ): Promise<void> => {
            const tolerant: boolean = !(opts?.strict ?? false);

            if (opts?.branchId) {
                await runtime.runTasks(
                    [
                        () =>
                            refreshSnapshotPointersForBranch(
                                opts.branchId as string,
                            ),
                    ],
                    tolerant,
                );
                return;
            }

            await runtime.runTasks([() => refreshSnapshotPointers()], tolerant);
        },
        [runtime, refreshSnapshotPointers, refreshSnapshotPointersForBranch],
    );

    return React.useMemo<WorkspaceRefreshApi>(
        () => ({
            refreshAll,
            refreshBranchContext,
            refreshSnapshotPointers: refreshSnapshotPointersWrapped,
        }),
        [refreshAll, refreshBranchContext, refreshSnapshotPointersWrapped],
    );
}
```

---
#### 19


` File: src/react/workspace/context/provider/context.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/context.ts
import * as React from "react";
import type { WorkspaceAPI } from "./types";

export const WorkspaceContext = React.createContext<WorkspaceAPI | null>(null);

export function useWorkspace(): WorkspaceAPI {
    const ctx = React.useContext(WorkspaceContext);
    if (!ctx) {
        throw new Error(
            "useWorkspace() must be used under <WorkspaceProvider/>",
        );
    }
    return ctx;
}

export function useWorkspaceMaybe(): WorkspaceAPI | null {
    return React.useContext(WorkspaceContext);
}
```

---
#### 20


` File: src/react/workspace/context/provider/helpers.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/helpers.ts
import type { BackendError, LiveOptions } from "../backend";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import type { RunResult } from "./types";

// Stable default ‚Äî avoids a new object per render
export const LIVE_OFF: LiveOptions = Object.freeze({ mode: "off" as const });

function isBackendErrorLike(e: unknown): e is BackendError {
    if (!e || typeof e !== "object") return false;
    const obj: Record<string, unknown> = e as Record<string, unknown>;
    return typeof obj.code === "string" && typeof obj.message === "string";
}

export function toBackendError(e: unknown): BackendError {
    if (isBackendErrorLike(e)) return e;

    // Preserve real Error information (without assuming BackendError supports extra fields)
    if (e instanceof Error) {
        const name: string = e.name || "Error";
        const msg: string = e.message || String(e);
        return {
            code: "runtime_error",
            message: `${name}: ${msg}`,
        };
    }

    if (typeof e === "string") {
        return { code: "unknown_error", message: e };
    }

    try {
        return { code: "unknown_error", message: JSON.stringify(e) };
    } catch {
        return { code: "unknown_error", message: String(e ?? "Unknown error") };
    }
}

/**
 * Sequential task runner (ordering preserved).
 * - tolerant=true: collects errors and continues
 * - tolerant=false: throws on first failure
 */
export async function runTasks(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    const errors: BackendError[] = [];
    for (const t of tasks) {
        try {
            await t();
        } catch (e) {
            if (!tolerant) throw e;
            errors.push(toBackendError(e));
        }
    }
    return errors.length ? { ok: false, errors } : { ok: true };
}

/**
 * Parallel task runner (ordering not guaranteed).
 * Kept separate so callers can choose intentionally.
 */
export async function runTasksParallel(
    tasks: Array<() => Promise<unknown>>,
    tolerant: boolean,
): Promise<RunResult> {
    if (tasks.length === 0) return { ok: true };

    const results: Array<{ ok: true } | { ok: false; error: BackendError }> =
        await Promise.all(
            tasks.map(async (t) => {
                try {
                    await t();
                    return { ok: true } as const;
                } catch (e) {
                    if (!tolerant) throw e;
                    return { ok: false, error: toBackendError(e) } as const;
                }
            }),
        );

    const errors: BackendError[] = results
        .filter((r) => !r.ok)
        .map((r) => (r as { ok: false; error: BackendError }).error);

    return errors.length ? { ok: false, errors } : { ok: true };
}

export function toServiceMap(
    input?: readonly DgpServiceCapability[] | DgpServiceMap | null,
): DgpServiceMap | null {
    if (!input) return null;

    if (Array.isArray(input)) {
        const out: Record<string, DgpServiceCapability> = Object.create(null);
        for (const s of input) out[s.id] = s;
        return out as unknown as DgpServiceMap;
    }

    return input as DgpServiceMap;
}
```

---
#### 21


` File: src/react/workspace/context/provider/live/adapters/manual.ts`  [‚Üë Back to top](#index)

```ts

```

---
#### 22


` File: src/react/workspace/context/provider/live/adapters/poll.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/live/adapters/poll.ts
import type { LiveOptions } from "../../../backend";
import type {
    WorkspaceLiveAdapter,
    WorkspaceLiveAdapterContext,
    WorkspaceLiveAdapterHandlers,
    WorkspaceLiveStatus,
    WorkspaceLiveTick,
} from "../types";

export interface PollAdapterOptions {
    readonly defaultIntervalMs: number; // e.g. 15000
}

export function createPollAdapter(
    opts?: Partial<PollAdapterOptions>,
): WorkspaceLiveAdapter {
    const defaultIntervalMs: number = opts?.defaultIntervalMs ?? 15000;

    let intervalId: number | undefined;
    let connected: boolean = false;

    const disconnect = (): void => {
        if (typeof intervalId === "number") {
            window.clearInterval(intervalId);
        }
        intervalId = undefined;
        connected = false;
    };

    const connect = async (
        ctx: WorkspaceLiveAdapterContext,
        handlers: WorkspaceLiveAdapterHandlers,
    ): Promise<void> => {
        disconnect();

        const live: LiveOptions = ctx.live;

        if (live.mode !== "poll") {
            handlers.onStatus({ connected: false } as WorkspaceLiveStatus);
            return;
        }

        const intervalMs: number = live.intervalMs ?? defaultIntervalMs;

        connected = true;
        handlers.onStatus({ connected: true } as WorkspaceLiveStatus);

        const tickOnce = async (
            reason: WorkspaceLiveTick["reason"],
        ): Promise<void> => {
            const tick: WorkspaceLiveTick = {
                at: Date.now(),
                reason,
            };
            handlers.onTick(tick);
        };

        // immediate tick
        await tickOnce("init");

        intervalId = window.setInterval(() => {
            void tickOnce("timer");
        }, intervalMs) as unknown as number;
    };

    return {
        id: "poll",
        connect,
        disconnect,
    };
}
```

---
#### 23


` File: src/react/workspace/context/provider/live/adapters/sse.ts`  [‚Üë Back to top](#index)

```ts

```

---
#### 24


` File: src/react/workspace/context/provider/live/adapters/ws.ts`  [‚Üë Back to top](#index)

```ts

```

---
#### 25


` File: src/react/workspace/context/provider/live/types.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/live/types.ts
import type { BackendError, LiveOptions } from "../../backend";
import type { RunResult } from "../types";

/**
 * The ‚Äútick‚Äù is the only thing the adapter *must* emit.
 * You can treat any WS/SSE message as a tick initially,
 * and later introduce selective refresh events.
 */
export interface WorkspaceLiveTick {
    readonly at: number;
    readonly reason:
        | "init"
        | "timer"
        | "message"
        | "manual"
        | "reconnect"
        | "unknown";
}

export interface WorkspaceLiveStatus {
    readonly connected: boolean;
    readonly lastEventAt?: number;
    readonly lastError?: BackendError;
}

export interface WorkspaceLiveAdapterContext {
    readonly workspaceId: string;
    readonly actorId: string;

    readonly live: LiveOptions;

    /** current branch (if any) */
    readonly getCurrentBranchId: () => string | undefined;

    /**
     * ‚ÄúWhat to do‚Äù is owned by the provider (refresh semantics).
     * ‚ÄúWhen to do it‚Äù is owned by the adapter (poll/ws/sse/etc).
     */
    readonly refreshAll: (opts?: { strict?: boolean }) => Promise<RunResult>;

    /** Optional: adapters can use these for lighter refresh policies later */
    readonly refreshBranchContext?: () => Promise<void>;
    readonly refreshSnapshotPointers?: () => Promise<void>;
}

export interface WorkspaceLiveAdapterHandlers {
    readonly onTick: (tick: WorkspaceLiveTick) => void;
    readonly onStatus: (status: WorkspaceLiveStatus) => void;
}

export interface WorkspaceLiveAdapter {
    /** A stable id (e.g. "poll", "ws", "sse") */
    readonly id: string;

    connect(
        ctx: WorkspaceLiveAdapterContext,
        handlers: WorkspaceLiveAdapterHandlers,
    ): void | Promise<void>;

    disconnect(): void;

    /**
     * Optional: allow branch changes / live option changes without reconnect.
     * If not implemented, the runner will disconnect+connect when key changes.
     */
    update?(ctx: WorkspaceLiveAdapterContext): void;
}

export type WorkspaceLiveAdapterFactory = () => WorkspaceLiveAdapter;

export type WorkspaceLiveAdapterRegistry = Readonly<
    Record<string, WorkspaceLiveAdapterFactory>
>;
```

---
#### 26


` File: src/react/workspace/context/provider/provider.tsx`  [‚Üë Back to top](#index)

```tsx
// src/react/workspace/context/provider/provider.tsx
import * as React from "react";
import type {
    LiveOptions,
    MergeResult,
    Result,
    TemplatesListParams,
} from "../backend";
import type { DgpServiceMap } from "@/schema/provider";

import { WorkspaceContext } from "./context";
import type { WorkspaceAPI, WorkspaceProviderProps } from "./types";
import { LIVE_OFF } from "./helpers";

import { useBackendRuntime } from "./runtime/use-backend-runtime";

import { useAuthorsSlice } from "./slices/use-authors-slice";
import { usePermissionsSlice } from "./slices/use-permissions-slice";
import { useBranchesSlice } from "./slices/use-branches-slice";
import { useTemplatesSlice } from "./slices/use-templates-slice";
import { useServicesSlice } from "./slices/use-services-slice";
import { useSnapshotsSlice } from "./slices/use-snapshots-slice";

import { useBranchCache } from "./compose/use-branch-cache";
import { useWorkspaceRefresh } from "./compose/use-workspace-refresh";
import { useLivePolling } from "./compose/use-live-polling";

/* ---------------- provider (thin composition root) ---------------- */

export function WorkspaceProvider(
    props: WorkspaceProviderProps,
): React.JSX.Element {
    const {
        backend,
        actor,
        initial,
        ensureMain = true,
        live: liveProp,
        autosaveMs = 9000,
        autoAutosave = true,
        children,
        liveAdapters,
        liveDebounceMs = 250,
    } = props;

    const runtime = useBackendRuntime();

    const workspaceId: string = backend.info.id;
    const live: LiveOptions = liveProp ?? LIVE_OFF;

    const authorsSlice = useAuthorsSlice({
        backend,
        workspaceId,
        initialAuthors: initial?.authors ?? null,
        runtime,
    });

    const permissionsSlice = usePermissionsSlice({
        backend,
        workspaceId,
        actor,
        initialPermissions: initial?.permissions ?? null,
        runtime,
    });

    const branchesSlice = useBranchesSlice({
        backend,
        workspaceId,
        ensureMain,
        initialBranches: initial?.branches ?? [],
        initialMainId: initial?.mainId,
        initialCurrentId: initial?.currentBranchId ?? initial?.mainId,
        initialParticipants: initial?.participants ?? null,
        runtime,
    });

    const getCurrentBranchId = React.useCallback(
        (): string | undefined => branchesSlice.branches.currentId,
        [branchesSlice.branches.currentId],
    );

    const templatesSlice = useTemplatesSlice({
        backend,
        workspaceId,
        getCurrentBranchId,
        initialTemplates: initial?.templates ?? null,
        runtime,
    });

    const servicesSlice = useServicesSlice({
        backend,
        workspaceId,
        initialServices: (initial?.services as DgpServiceMap | null) ?? null,
        runtime,
    });

    const snapshotsSlice = useSnapshotsSlice({
        backend,
        workspaceId,
        actor,
        getCurrentBranchId,
        initialSnapshot: initial?.snapshot
            ? {
                  schema_version: initial.snapshot.schema_version,
                  data: initial.snapshot.data as any,
              }
            : null,
        initialHead: initial?.head,
        initialDraft: initial?.draft,
        autosaveMs,
        autoAutosave,
        runtime,
    });

    const branchCache = useBranchCache(workspaceId);

    const refresh = useWorkspaceRefresh({
        runtime,
        refreshAuthors: authorsSlice.refreshAuthors,
        refreshPermissions: permissionsSlice.refreshPermissions,
        refreshBranches: branchesSlice.refreshBranches,
        refreshServices: servicesSlice.refreshServices,
        getCurrentBranchId,
        refreshTemplates: async (p?: Partial<{ branchId: string }>) => {
            await templatesSlice.refreshTemplates(
                p?.branchId
                    ? ({ branchId: p.branchId } as Partial<
                          Pick<TemplatesListParams, "branchId">
                      >)
                    : undefined,
            );
        },
        refreshParticipants: async (p?: Partial<{ branchId: string }>) => {
            await branchesSlice.refreshParticipants(
                p?.branchId
                    ? ({ branchId: p.branchId } as Partial<{
                          branchId: string;
                      }>)
                    : undefined,
            );
        },
        refreshSnapshotPointersForBranch:
            snapshotsSlice.refreshSnapshotPointersForBranch,
        refreshSnapshotPointers: snapshotsSlice.refreshSnapshotPointers,
    });

    const hasAnyData: boolean = Boolean(
        (authorsSlice.authors.data && authorsSlice.authors.data.length) ||
            (branchesSlice.branches.data &&
                branchesSlice.branches.data.length) ||
            (templatesSlice.templates.data &&
                templatesSlice.templates.data.length) ||
            (branchesSlice.participants.data &&
                branchesSlice.participants.data.length) ||
            snapshotsSlice.snapshot.data?.props,
    );

    const liveCtl = useLivePolling({
        live,
        workspaceId,
        actor,
        hasAnyData,
        getCurrentBranchId: () => branchesSlice.branches.currentId,
        refreshAll: refresh.refreshAll,
        refreshBranchContext: refresh.refreshBranchContext,
        refreshSnapshotPointers: refresh.refreshSnapshotPointers,
        adapters: liveAdapters,
        debounceMs: liveDebounceMs,
    });

    /* ---------------- branch ops ---------------- */

    const createBranch = React.useCallback<WorkspaceAPI["createBranch"]>(
        async (name: string, opts?: Readonly<{ fromId?: string }>) => {
            const res = await backend.branches.create(workspaceId, name, opts);
            if (res.ok) {
                await branchesSlice.refreshBranches();
                setCurrentBranch(res.value.id);
            }
            return res;
        },
        [backend.branches, workspaceId, branchesSlice /* setCurrentBranch */],
    );

    const setMain = React.useCallback<WorkspaceAPI["setMain"]>(
        async (branchId: string) => {
            const res = await backend.branches.setMain(workspaceId, branchId);
            if (res.ok) await branchesSlice.refreshBranches();
            return res;
        },
        [backend.branches, workspaceId, branchesSlice],
    );

    const mergeBranch = React.useCallback<WorkspaceAPI["mergeBranch"]>(
        async (sourceId: string, targetId: string): Result<MergeResult> => {
            const res = await backend.branches.merge(
                workspaceId,
                sourceId,
                targetId,
            );
            if (res.ok) {
                await runtime.runTasks(
                    [
                        () => branchesSlice.refreshBranches(),
                        () => refresh.refreshBranchContext(),
                    ],
                    true,
                );
            }
            return res;
        },
        [backend.branches, workspaceId, runtime, branchesSlice, refresh],
    );

    const deleteBranch = React.useCallback<WorkspaceAPI["deleteBranch"]>(
        async (branchId: string) => {
            const res = await backend.branches.delete(workspaceId, branchId);
            if (res.ok) {
                await branchesSlice.refreshBranches();

                if (branchesSlice.branches.currentId === branchId) {
                    const fallback: string | undefined =
                        branchesSlice.branches.data.find(
                            (b) => b.id !== branchId,
                        )?.id;

                    if (fallback) setCurrentBranch(fallback);
                }
            }
            return res;
        },
        [backend.branches, workspaceId, branchesSlice /* setCurrentBranch */],
    );

    /* ---------------- branch switching (cache-first) ---------------- */

    const hasInitialSnapshot: boolean = Boolean(initial?.snapshot);

    const setCurrentBranch = React.useCallback(
        (id: string): void => {
            const prevId: string | undefined = branchesSlice.branches.currentId;

            branchCache.switchBranch({
                workspaceId: workspaceId,
                nextId: id,
                prevId,

                templates: templatesSlice.templates,
                participants: branchesSlice.participants,
                snapshot: snapshotsSlice.snapshot,

                setTemplates: templatesSlice.__setTemplatesState,
                setParticipants: branchesSlice.__setParticipantsState,
                setSnapshot: snapshotsSlice.__setSnapshotState,

                resetTemplates: templatesSlice.resetTemplatesForBranch,
                resetParticipants: () => {
                    branchesSlice.__setParticipantsState((s) => ({
                        ...s,
                        data: null,
                        error: undefined,
                    }));
                },
                resetSnapshot: snapshotsSlice.resetSnapshotForBranch,

                setCurrentBranchId: branchesSlice.setCurrentBranchId,

                hasInitialSnapshot,

                loadSnapshotForBranch: (branchId: string) => {
                    void snapshotsSlice.loadSnapshotForBranch(branchId);
                },
            });
        },
        [
            branchesSlice.branches.currentId,
            branchesSlice.participants,
            branchesSlice.setCurrentBranchId,
            branchesSlice.__setParticipantsState,
            templatesSlice.templates,
            templatesSlice.__setTemplatesState,
            templatesSlice.resetTemplatesForBranch,
            snapshotsSlice.snapshot,
            snapshotsSlice.__setSnapshotState,
            snapshotsSlice.resetSnapshotForBranch,
            snapshotsSlice.loadSnapshotForBranch,
            branchCache,
            hasInitialSnapshot,
        ],
    );

    /* ---------------- cache invalidation ---------------- */

    const invalidate = React.useCallback<WorkspaceAPI["invalidate"]>(
        (keys) => {
            const setAll: boolean = !keys || keys.length === 0;

            if (setAll || keys?.includes("authors"))
                authorsSlice.invalidateAuthors();
            if (setAll || keys?.includes("permissions"))
                permissionsSlice.invalidatePermissions();
            if (setAll || keys?.includes("branches"))
                branchesSlice.invalidateBranches();
            if (setAll || keys?.includes("services"))
                servicesSlice.invalidateServices();

            if (setAll || keys?.includes("templates"))
                templatesSlice.invalidateTemplates();
            if (setAll || keys?.includes("participants"))
                branchesSlice.invalidateParticipants();

            if (
                setAll ||
                keys?.includes("templates") ||
                keys?.includes("participants")
            ) {
                branchCache.clear();
            }
        },
        [
            authorsSlice,
            permissionsSlice,
            branchesSlice,
            servicesSlice,
            templatesSlice,
            branchCache,
        ],
    );

    /* ---------------- memo API ---------------- */

    const api: WorkspaceAPI = React.useMemo<WorkspaceAPI>(
        () => ({
            info: backend.info,
            actor,

            authors: authorsSlice.authors,
            permissions: permissionsSlice.permissions,
            branches: branchesSlice.branches,

            templates: templatesSlice.templates,
            participants: branchesSlice.participants,
            services: servicesSlice.services,

            refresh: {
                all: refresh.refreshAll,

                authors: authorsSlice.refreshAuthors,
                permissions: permissionsSlice.refreshPermissions,
                branches: branchesSlice.refreshBranches,
                services: servicesSlice.refreshServices,

                branchContext: refresh.refreshBranchContext,

                templates: async (
                    params?: Partial<
                        Pick<TemplatesListParams, "branchId" | "since">
                    >,
                ) => templatesSlice.refreshTemplates(params),

                participants: async (
                    params?: Partial<{
                        branchId: string;
                        since?: number | string;
                    }>,
                ) => branchesSlice.refreshParticipants(params),

                snapshotPointers: refresh.refreshSnapshotPointers,
            },

            setCurrentBranch,

            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            createTemplate: templatesSlice.createTemplate,
            updateTemplate: templatesSlice.updateTemplate,
            cloneTemplate: templatesSlice.cloneTemplate,
            publishTemplate: templatesSlice.publishTemplate,
            unpublishTemplate: templatesSlice.unpublishTemplate,
            deleteTemplate: templatesSlice.deleteTemplate,

            invalidate,

            live: {
                connected: liveCtl.connected,
                lastEventAt: liveCtl.lastEventAt,
                connect: liveCtl.connect,
                disconnect: liveCtl.disconnect,
            },

            snapshot: {
                state: snapshotsSlice.snapshot.state,
                saving: snapshotsSlice.snapshot.saving,
                dirty: snapshotsSlice.snapshot.dirty,
                head: snapshotsSlice.snapshot.head,
                draft: snapshotsSlice.snapshot.draft,
                schemaVersion: snapshotsSlice.snapshot.schemaVersion,
                data: snapshotsSlice.snapshot.data,
                lastSavedAt: snapshotsSlice.snapshot.lastSavedAt,
                lastDraftAt: snapshotsSlice.snapshot.lastDraftAt,

                set: snapshotsSlice.setSnapshotData,
                load: snapshotsSlice.loadSnapshot,
                refresh: snapshotsSlice.refreshSnapshotPointers,

                autosave: snapshotsSlice.autosave,
                save: snapshotsSlice.save,
                publish: snapshotsSlice.publish,
                discardDraft: snapshotsSlice.discardDraft,
            },
        }),
        [
            backend.info,
            actor,

            authorsSlice.authors,
            authorsSlice.refreshAuthors,

            permissionsSlice.permissions,
            permissionsSlice.refreshPermissions,

            branchesSlice.branches,
            branchesSlice.participants,
            branchesSlice.refreshBranches,
            branchesSlice.refreshParticipants,

            templatesSlice.templates,
            templatesSlice.refreshTemplates,
            templatesSlice.createTemplate,
            templatesSlice.updateTemplate,
            templatesSlice.cloneTemplate,
            templatesSlice.publishTemplate,
            templatesSlice.unpublishTemplate,
            templatesSlice.deleteTemplate,

            servicesSlice.services,
            servicesSlice.refreshServices,

            refresh.refreshAll,
            refresh.refreshBranchContext,
            refresh.refreshSnapshotPointers,

            setCurrentBranch,

            createBranch,
            setMain,
            mergeBranch,
            deleteBranch,

            invalidate,

            liveCtl.connected,
            liveCtl.lastEventAt,

            snapshotsSlice.snapshot,
            snapshotsSlice.setSnapshotData,
            snapshotsSlice.loadSnapshot,
            snapshotsSlice.refreshSnapshotPointers,
            snapshotsSlice.autosave,
            snapshotsSlice.save,
            snapshotsSlice.publish,
            snapshotsSlice.discardDraft,
        ],
    );

    return (
        <WorkspaceContext.Provider value={api}>
            {children}
        </WorkspaceContext.Provider>
    );
}
```

---
#### 27


` File: src/react/workspace/context/provider/runtime/use-backend-runtime.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/runtime/use-backend-runtime.ts
import * as React from "react";
import type { BackendError } from "../../backend";
import type { RunResult } from "../types";
import {
    runTasks as runTasksBase,
    toBackendError as toBackendErrorBase,
} from "../helpers";

export interface BackendRuntime {
    readonly now: () => number;
    readonly toBackendError: (e: unknown) => BackendError;
    readonly runTasks: (
        tasks: Array<() => Promise<unknown>>,
        tolerant: boolean,
    ) => Promise<RunResult>;
}

export function useBackendRuntime(): BackendRuntime {
    const now = React.useCallback((): number => Date.now(), []);

    const toBackendError = React.useCallback(
        (e: unknown): BackendError => toBackendErrorBase(e),
        [],
    );

    const runTasks = React.useCallback(
        async (
            tasks: Array<() => Promise<unknown>>,
            tolerant: boolean,
        ): Promise<RunResult> => runTasksBase(tasks, tolerant),
        [],
    );

    return React.useMemo<BackendRuntime>(
        () => ({ now, toBackendError, runTasks }),
        [now, toBackendError, runTasks],
    );
}
```

---
#### 28


` File: src/react/workspace/context/provider/slices/use-authors-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-authors-slice.ts
import * as React from "react";
import type { Author, BackendError, WorkspaceBackend } from "../../backend";
import type { Loadable } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface AuthorsSliceApi {
    readonly authors: Loadable<readonly Author[]>;
    readonly refreshAuthors: () => Promise<void>;
    readonly invalidateAuthors: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseAuthorsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly initialAuthors?: readonly Author[] | null;
    readonly runtime: BackendRuntime;
}

export function useAuthorsSlice(
    params: UseAuthorsSliceParams,
): AuthorsSliceApi {
    const { backend, workspaceId, initialAuthors, runtime } = params;

    const [authors, setAuthors] = React.useState<Loadable<readonly Author[]>>({
        data: initialAuthors ?? null,
        loading: false,
        updatedAt: initialAuthors ? runtime.now() : undefined,
    });

    const refreshAuthors = React.useCallback(async (): Promise<void> => {
        setAuthors((s) => ({ ...s, loading: true }));
        const res = await backend.authors.refresh(workspaceId);

        if (res.ok) {
            setAuthors({
                data: res.value,
                loading: false,
                updatedAt: runtime.now(),
            });
        } else {
            setLoadableError(setAuthors, res.error);
        }
    }, [backend.authors, workspaceId, runtime]);

    const invalidateAuthors = React.useCallback((): void => {
        setAuthors((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<AuthorsSliceApi>(
        () => ({ authors, refreshAuthors, invalidateAuthors }),
        [authors, refreshAuthors, invalidateAuthors],
    );
}
```

---
#### 29


` File: src/react/workspace/context/provider/slices/use-branches-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-branches-slice.ts
import * as React from "react";
import type {
    BackendError,
    Branch,
    BranchParticipant,
    WorkspaceBackend,
} from "../../backend";
import type { BranchesSlice, Loadable } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface BranchesSliceApi {
    readonly branches: BranchesSlice;
    readonly participants: Loadable<readonly BranchParticipant[]>;

    readonly setCurrentBranchId: (id: string) => void;

    readonly refreshBranches: () => Promise<void>;
    readonly refreshParticipants: (
        params?: Partial<{ branchId: string; since?: number | string }>,
    ) => Promise<void>;

    readonly invalidateBranches: () => void;
    readonly invalidateParticipants: () => void;

    /** internal setters for branch-cache composition */
    readonly __setParticipantsState: React.Dispatch<
        React.SetStateAction<Loadable<readonly BranchParticipant[]>>
    >;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseBranchesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;

    readonly ensureMain: boolean;

    readonly initialBranches?: readonly Branch[];
    readonly initialMainId?: string;
    readonly initialCurrentId?: string;
    readonly initialParticipants?: readonly BranchParticipant[] | null;

    readonly runtime: BackendRuntime;
}

export function useBranchesSlice(
    params: UseBranchesSliceParams,
): BranchesSliceApi {
    const {
        backend,
        workspaceId,
        ensureMain,
        initialBranches,
        initialMainId,
        initialCurrentId,
        initialParticipants,
        runtime,
    } = params;

    const [branches, setBranches] = React.useState<BranchesSlice>({
        data: initialBranches ?? [],
        mainId: initialMainId,
        currentId: initialCurrentId ?? initialMainId,
        loading: false,
        updatedAt: initialBranches ? runtime.now() : undefined,
    });

    const [participants, setParticipants] = React.useState<
        Loadable<readonly BranchParticipant[]>
    >({
        data: initialParticipants ?? null,
        loading: false,
        updatedAt: initialParticipants ? runtime.now() : undefined,
    });

    // Ensure main branch pointer is stable (same behavior as old provider)
    React.useEffect((): void => {
        if (!ensureMain) return;
        if (branches.data.length === 0) return;

        const existingMain: string | undefined = branches.data.find(
            (b) => b.isMain,
        )?.id;

        if (existingMain && branches.mainId !== existingMain) {
            setBranches((s) => ({
                ...s,
                mainId: existingMain,
                currentId: s.currentId ?? existingMain,
            }));
            return;
        }

        if (!existingMain) {
            const first: string | undefined = branches.data[0]?.id;
            if (first && !branches.currentId) {
                setBranches((s) => ({ ...s, currentId: first }));
            }
        }
    }, [branches.data, branches.mainId, branches.currentId, ensureMain]);

    const setCurrentBranchId = React.useCallback((id: string): void => {
        setBranches((s) => ({ ...s, currentId: id }));
    }, []);

    const refreshBranches = React.useCallback(async (): Promise<void> => {
        setBranches((s) => ({ ...s, loading: true }));
        const res = await backend.branches.refresh(workspaceId);

        if (!res.ok) {
            setBranches((s) => ({ ...s, loading: false, error: res.error }));
            return;
        }

        const data: readonly Branch[] = res.value;
        const main: string | undefined = data.find((b) => b.isMain)?.id;

        setBranches((s) => {
            const currentStillExists: boolean =
                Boolean(s.currentId) && data.some((b) => b.id === s.currentId);

            const nextCurrent: string | undefined = currentStillExists
                ? s.currentId
                : (main ?? data[0]?.id);

            return {
                data,
                mainId: main ?? s.mainId,
                currentId: nextCurrent,
                loading: false,
                updatedAt: runtime.now(),
            };
        });
    }, [backend.branches, workspaceId, runtime]);

    const refreshParticipants = React.useCallback(
        async (
            params?: Partial<{ branchId: string; since?: number | string }>,
        ): Promise<void> => {
            const branchId: string | undefined =
                params?.branchId ?? branches.currentId;
            if (!branchId) return;

            setParticipants((s) => ({ ...s, loading: true }));

            const res = await backend.access.refreshParticipants(
                workspaceId,
                branchId,
                { since: params?.since ?? participants.updatedAt },
            );

            if (res.ok) {
                setParticipants({
                    data: res.value,
                    loading: false,
                    updatedAt: runtime.now(),
                });
            } else {
                setLoadableError(setParticipants, res.error);
            }
        },
        [
            backend.access,
            workspaceId,
            branches.currentId,
            participants.updatedAt,
            runtime,
        ],
    );

    const invalidateBranches = React.useCallback((): void => {
        setBranches((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    const invalidateParticipants = React.useCallback((): void => {
        setParticipants((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<BranchesSliceApi>(
        () => ({
            branches,
            participants,
            setCurrentBranchId,
            refreshBranches,
            refreshParticipants,
            invalidateBranches,
            invalidateParticipants,
            __setParticipantsState: setParticipants,
        }),
        [
            branches,
            participants,
            setCurrentBranchId,
            refreshBranches,
            refreshParticipants,
            invalidateBranches,
            invalidateParticipants,
        ],
    );
}
```

---
#### 30


` File: src/react/workspace/context/provider/slices/use-permissions-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-permissions-slice.ts
import * as React from "react";
import type {
    Actor,
    BackendError,
    PermissionsMap,
    WorkspaceBackend,
} from "../../backend";
import type { Loadable } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface PermissionsSliceApi {
    readonly permissions: Loadable<PermissionsMap>;
    readonly refreshPermissions: () => Promise<void>;
    readonly invalidatePermissions: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UsePermissionsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly actor: Actor;
    readonly initialPermissions?: PermissionsMap | null;
    readonly runtime: BackendRuntime;
}

export function usePermissionsSlice(
    params: UsePermissionsSliceParams,
): PermissionsSliceApi {
    const { backend, workspaceId, actor, initialPermissions, runtime } = params;

    const [permissions, setPermissions] = React.useState<
        Loadable<PermissionsMap>
    >({
        data: initialPermissions ?? null,
        loading: false,
        updatedAt: initialPermissions ? runtime.now() : undefined,
    });

    const refreshPermissions = React.useCallback(async (): Promise<void> => {
        setPermissions((s) => ({ ...s, loading: true }));
        const res = await backend.permissions.refresh(workspaceId, actor);

        if (res.ok) {
            setPermissions({
                data: res.value,
                loading: false,
                updatedAt: runtime.now(),
            });
        } else {
            setLoadableError(setPermissions, res.error);
        }
    }, [backend.permissions, workspaceId, actor, runtime]);

    const invalidatePermissions = React.useCallback((): void => {
        setPermissions((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<PermissionsSliceApi>(
        () => ({ permissions, refreshPermissions, invalidatePermissions }),
        [permissions, refreshPermissions, invalidatePermissions],
    );
}
```

---
#### 31


` File: src/react/workspace/context/provider/slices/use-services-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-services-slice.ts
import * as React from "react";
import type { BackendError, WorkspaceBackend } from "../../backend";
import type { DgpServiceMap } from "@/schema/provider";
import type { Loadable } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";
import { toServiceMap } from "../helpers";

export interface ServicesSliceApi {
    readonly services: Loadable<DgpServiceMap>;
    readonly refreshServices: () => Promise<void>;
    readonly invalidateServices: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseServicesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly initialServices?: DgpServiceMap | null;
    readonly runtime: BackendRuntime;
}

export function useServicesSlice(
    params: UseServicesSliceParams,
): ServicesSliceApi {
    const { backend, workspaceId, initialServices, runtime } = params;

    const [services, setServices] = React.useState<Loadable<DgpServiceMap>>({
        data: initialServices ?? null,
        loading: false,
        updatedAt: initialServices ? runtime.now() : undefined,
    });

    const refreshServices = React.useCallback(async (): Promise<void> => {
        setServices((s) => ({ ...s, loading: true }));

        const res = await backend.services.refresh(workspaceId, {
            since: services.updatedAt,
        });

        if (!res.ok) {
            setLoadableError(setServices, res.error);
            return;
        }

        const map: DgpServiceMap | null = toServiceMap(res.value);
        setServices({
            data: map ?? ({} as DgpServiceMap),
            loading: false,
            updatedAt: runtime.now(),
        });
    }, [backend.services, workspaceId, services.updatedAt, runtime]);

    const invalidateServices = React.useCallback((): void => {
        setServices((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    return React.useMemo<ServicesSliceApi>(
        () => ({ services, refreshServices, invalidateServices }),
        [services, refreshServices, invalidateServices],
    );
}
```

---
#### 32


` File: src/react/workspace/context/provider/slices/use-snapshots-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-snapshots-slice.ts
import * as React from "react";
import type {
    Actor,
    BackendError,
    Commit,
    Draft,
    Result,
    SnapshotsLoadResult,
    WorkspaceBackend,
} from "../../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { SnapshotSlice, WorkspaceAPI } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface SnapshotsSliceApi {
    readonly snapshot: SnapshotSlice;

    readonly loadSnapshotForBranch: (
        branchId: string,
        params?: Readonly<{ versionId?: string }>,
    ) => Result<SnapshotsLoadResult>;

    readonly loadSnapshot: WorkspaceAPI["snapshot"]["load"];
    readonly refreshSnapshotPointersForBranch: (
        branchId: string,
    ) => Promise<void>;
    readonly refreshSnapshotPointers: () => Promise<void>;

    readonly setSnapshotData: WorkspaceAPI["snapshot"]["set"];
    readonly autosave: WorkspaceAPI["snapshot"]["autosave"];
    readonly save: WorkspaceAPI["snapshot"]["save"];
    readonly publish: WorkspaceAPI["snapshot"]["publish"];
    readonly discardDraft: WorkspaceAPI["snapshot"]["discardDraft"];

    /** internal setters for branch-cache composition */
    readonly __setSnapshotState: React.Dispatch<
        React.SetStateAction<SnapshotSlice>
    >;

    readonly resetSnapshotForBranch: () => void;
}

function setSnapshotError(error: BackendError): {
    ok: false;
    error: BackendError;
} {
    return { ok: false, error };
}

export interface UseSnapshotsSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;
    readonly actor: Actor;

    readonly getCurrentBranchId: () => string | undefined;

    readonly initialSnapshot?: {
        schema_version: string;
        data: EditorSnapshot;
    } | null;
    readonly initialHead?: Commit;
    readonly initialDraft?: Draft;

    readonly autosaveMs: number;
    readonly autoAutosave: boolean;

    readonly runtime: BackendRuntime;
}

export function useSnapshotsSlice(
    params: UseSnapshotsSliceParams,
): SnapshotsSliceApi {
    const {
        backend,
        workspaceId,
        actor,
        getCurrentBranchId,
        initialSnapshot,
        initialHead,
        initialDraft,
        autosaveMs,
        autoAutosave,
        runtime,
    } = params;

    const [snapshot, setSnapshot] = React.useState<SnapshotSlice>({
        schemaVersion: initialSnapshot?.schema_version,
        data: initialSnapshot?.data as EditorSnapshot | undefined,
        head: initialHead,
        draft: initialDraft,
        state: initialDraft ? "uncommitted" : "clean",
        saving: false,
        dirty: false,
    });

    const autosaveTimerRef = React.useRef<number | null>(null);

    const loadSnapshotForBranch = React.useCallback(
        async (
            branchId: string,
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult> => {
            const res = await backend.snapshots.load({
                workspaceId,
                branchId,
                actorId: actor.id,
                versionId: params?.versionId,
            });

            if (res.ok) {
                const { head, draft, snapshot: snap } = res.value;
                setSnapshot({
                    schemaVersion: snap.schema_version,
                    data: snap.data,
                    head,
                    draft,
                    state: draft ? "uncommitted" : "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: undefined,
                    lastDraftAt: undefined,
                });
            }

            return res;
        },
        [backend.snapshots, workspaceId, actor.id],
    );

    const loadSnapshot = React.useCallback<WorkspaceAPI["snapshot"]["load"]>(
        async (params?: Readonly<{ versionId?: string }>) => {
            const branchId = getCurrentBranchId();
            if (!branchId) {
                return setSnapshotError({
                    code: "no_branch",
                    message: "No current branch to load snapshot from.",
                }) as unknown as Result<SnapshotsLoadResult>;
            }
            return loadSnapshotForBranch(branchId, params);
        },
        [getCurrentBranchId, loadSnapshotForBranch],
    );

    const setSnapshotData = React.useCallback<WorkspaceAPI["snapshot"]["set"]>(
        (
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void => {
            setSnapshot((s) => ({
                ...s,
                data: updater(s.data),
                state: s.draft ? "uncommitted" : "dirty",
                dirty: true,
            }));
        },
        [],
    );

    const refreshSnapshotPointersForBranch = React.useCallback(
        async (branchId: string): Promise<void> => {
            const res = await backend.snapshots.refresh({
                workspaceId,
                branchId,
                actorId: actor.id,
                since: snapshot.lastSavedAt ?? snapshot.lastDraftAt,
            });

            if (!res.ok) return;

            setSnapshot((s) => ({
                ...s,
                head: res.value.head ?? s.head,
                draft: res.value.draft,
                state: res.value.draft
                    ? "uncommitted"
                    : s.dirty
                      ? "dirty"
                      : "clean",
            }));
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            snapshot.lastSavedAt,
            snapshot.lastDraftAt,
        ],
    );

    const refreshSnapshotPointers =
        React.useCallback(async (): Promise<void> => {
            const branchId = getCurrentBranchId();
            if (!branchId) return;
            await refreshSnapshotPointersForBranch(branchId);
        }, [getCurrentBranchId, refreshSnapshotPointersForBranch]);

    const autosave = React.useCallback<
        WorkspaceAPI["snapshot"]["autosave"]
    >(async () => {
        const branchId = getCurrentBranchId();
        if (!branchId) {
            return setSnapshotError({
                code: "no_branch",
                message: "No current branch to autosave.",
            }) as any;
        }

        if (!snapshot.data || !snapshot.schemaVersion) {
            return setSnapshotError({
                code: "no_snapshot",
                message: "Nothing to autosave.",
            }) as any;
        }

        const res = await backend.snapshots.autosave({
            workspaceId,
            branchId,
            actorId: actor.id,
            snapshot: {
                schema_version: snapshot.schemaVersion,
                data: snapshot.data,
            },
            etag: snapshot.draft?.etag,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: res.value.draft,
                state: "uncommitted",
                dirty: false,
                lastDraftAt: runtime.now(),
            }));
        }

        return res;
    }, [
        backend.snapshots,
        workspaceId,
        actor.id,
        getCurrentBranchId,
        snapshot.data,
        snapshot.schemaVersion,
        snapshot.draft?.etag,
        runtime,
    ]);

    const save = React.useCallback<WorkspaceAPI["snapshot"]["save"]>(
        async (message?: string) => {
            const branchId = getCurrentBranchId();
            if (!branchId) {
                return setSnapshotError({
                    code: "no_branch",
                    message: "No current branch to save.",
                }) as any;
            }

            if (!snapshot.data || !snapshot.schemaVersion) {
                return setSnapshotError({
                    code: "no_snapshot",
                    message: "Nothing to save.",
                }) as any;
            }

            setSnapshot((s) => ({ ...s, state: "saving", saving: true }));

            const res = await backend.snapshots.save({
                workspaceId,
                branchId,
                actorId: actor.id,
                snapshot: {
                    schema_version: snapshot.schemaVersion,
                    data: snapshot.data,
                },
                message,
                draftId: snapshot.draft?.id,
                etag: snapshot.head?.etag,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: runtime.now(),
                }));
            } else {
                setSnapshot((s) => ({
                    ...s,
                    state: s.draft ? "uncommitted" : "dirty",
                    saving: false,
                }));
            }

            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            getCurrentBranchId,
            snapshot.data,
            snapshot.schemaVersion,
            snapshot.draft?.id,
            snapshot.head?.etag,
            runtime,
        ],
    );

    const publish = React.useCallback<WorkspaceAPI["snapshot"]["publish"]>(
        async (message?: string) => {
            const draftId = snapshot.draft?.id;
            if (!draftId) return save(message);

            const res = await backend.snapshots.publish({
                workspaceId,
                actorId: actor.id,
                draftId,
                message,
            });

            if (res.ok) {
                const commit = res.value.commit;
                setSnapshot((s) => ({
                    ...s,
                    head: commit,
                    draft: undefined,
                    state: "clean",
                    saving: false,
                    dirty: false,
                    lastSavedAt: runtime.now(),
                }));
            }

            return res;
        },
        [
            backend.snapshots,
            workspaceId,
            actor.id,
            snapshot.draft?.id,
            save,
            runtime,
        ],
    );

    const discardDraft = React.useCallback<
        WorkspaceAPI["snapshot"]["discardDraft"]
    >(async () => {
        const draftId = snapshot.draft?.id;
        if (!draftId) return { ok: true, value: undefined } as const;

        const res = await backend.snapshots.discard({
            workspaceId,
            actorId: actor.id,
            draftId,
        });

        if (res.ok) {
            setSnapshot((s) => ({
                ...s,
                draft: undefined,
                state: s.dirty ? "dirty" : "clean",
            }));
        }

        return res;
    }, [backend.snapshots, workspaceId, actor.id, snapshot.draft?.id]);

    // Autosave effect (same behavior as old provider)
    React.useEffect((): (() => void) | void => {
        if (!autoAutosave || !snapshot.dirty) return;

        if (autosaveTimerRef.current) {
            window.clearTimeout(autosaveTimerRef.current);
            autosaveTimerRef.current = null;
        }

        autosaveTimerRef.current = window.setTimeout(() => {
            void autosave();
            autosaveTimerRef.current = null;
        }, autosaveMs) as unknown as number;

        return (): void => {
            if (autosaveTimerRef.current) {
                window.clearTimeout(autosaveTimerRef.current);
                autosaveTimerRef.current = null;
            }
        };
    }, [snapshot.dirty, autosaveMs, autoAutosave, autosave]);

    const resetSnapshotForBranch = React.useCallback((): void => {
        setSnapshot((s) => ({
            ...s,
            head: undefined,
            draft: undefined,
            state: "clean",
            saving: false,
            dirty: false,
            lastSavedAt: undefined,
            lastDraftAt: undefined,
        }));
    }, []);

    return React.useMemo<SnapshotsSliceApi>(
        () => ({
            snapshot,
            loadSnapshotForBranch,
            loadSnapshot,
            refreshSnapshotPointersForBranch,
            refreshSnapshotPointers,
            setSnapshotData,
            autosave,
            save,
            publish,
            discardDraft,
            __setSnapshotState: setSnapshot,
            resetSnapshotForBranch,
        }),
        [
            snapshot,
            loadSnapshotForBranch,
            loadSnapshot,
            refreshSnapshotPointersForBranch,
            refreshSnapshotPointers,
            setSnapshotData,
            autosave,
            save,
            publish,
            discardDraft,
            resetSnapshotForBranch,
        ],
    );
}
```

---
#### 33


` File: src/react/workspace/context/provider/slices/use-templates-slice.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/slices/use-templates-slice.ts
import * as React from "react";
import type {
    BackendError,
    FieldTemplate,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesListParams,
    WorkspaceBackend,
} from "../../backend";
import type { Loadable, WorkspaceAPI } from "../types";
import type { BackendRuntime } from "../runtime/use-backend-runtime";

export interface TemplatesSliceApi {
    readonly templates: Loadable<readonly FieldTemplate[]>;

    readonly refreshTemplates: (
        params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
    ) => Promise<void>;

    readonly createTemplate: WorkspaceAPI["createTemplate"];
    readonly updateTemplate: WorkspaceAPI["updateTemplate"];
    readonly cloneTemplate: WorkspaceAPI["cloneTemplate"];
    readonly publishTemplate: WorkspaceAPI["publishTemplate"];
    readonly unpublishTemplate: WorkspaceAPI["unpublishTemplate"];
    readonly deleteTemplate: WorkspaceAPI["deleteTemplate"];

    readonly invalidateTemplates: () => void;

    /** internal setters for branch-cache composition */
    readonly __setTemplatesState: React.Dispatch<
        React.SetStateAction<Loadable<readonly FieldTemplate[]>>
    >;

    readonly resetTemplatesForBranch: () => void;
}

function setLoadableError<T>(
    updater: React.Dispatch<React.SetStateAction<Loadable<T>>>,
    error: BackendError,
): void {
    updater((s) => ({ ...s, loading: false, error }));
}

export interface UseTemplatesSliceParams {
    readonly backend: WorkspaceBackend;
    readonly workspaceId: string;

    readonly getCurrentBranchId: () => string | undefined;

    readonly initialTemplates?: readonly FieldTemplate[] | null;

    readonly runtime: BackendRuntime;
}

export function useTemplatesSlice(
    params: UseTemplatesSliceParams,
): TemplatesSliceApi {
    const {
        backend,
        workspaceId,
        getCurrentBranchId,
        initialTemplates,
        runtime,
    } = params;

    const [templates, setTemplates] = React.useState<
        Loadable<readonly FieldTemplate[]>
    >({
        data: initialTemplates ?? null,
        loading: false,
        updatedAt: initialTemplates ? runtime.now() : undefined,
    });

    const refreshTemplates = React.useCallback(
        async (
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void> => {
            const branchId: string | undefined =
                params?.branchId ?? getCurrentBranchId();
            if (!branchId) return;

            setTemplates((s) => ({ ...s, loading: true }));

            const res = await backend.templates.refresh({
                workspaceId,
                branchId,
                since: params?.since ?? templates.updatedAt,
            });

            if (res.ok) {
                setTemplates({
                    data: res.value,
                    loading: false,
                    updatedAt: runtime.now(),
                });
            } else {
                setLoadableError(setTemplates, res.error);
            }
        },
        [
            backend.templates,
            workspaceId,
            getCurrentBranchId,
            templates.updatedAt,
            runtime,
        ],
    );

    const createTemplate = React.useCallback<WorkspaceAPI["createTemplate"]>(
        async (input: TemplateCreateInput) => {
            const res = await backend.templates.create(workspaceId, {
                ...input,
                branchId: input.branchId ?? getCurrentBranchId(),
            });

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, workspaceId, getCurrentBranchId, refreshTemplates],
    );

    const updateTemplate = React.useCallback<WorkspaceAPI["updateTemplate"]>(
        async (id: string, patch: TemplateUpdatePatch) => {
            const res = await backend.templates.update(id, patch);

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const cloneTemplate = React.useCallback<WorkspaceAPI["cloneTemplate"]>(
        async (source, opts) => {
            const res = await backend.templates.clone(
                source,
                opts ?? { branchId: getCurrentBranchId() ?? undefined },
            );

            if (res.ok) {
                await refreshTemplates({
                    branchId: res.value.branchId ?? getCurrentBranchId(),
                });
            }

            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const publishTemplate = React.useCallback<WorkspaceAPI["publishTemplate"]>(
        async (id: string) => {
            const res = await backend.templates.publish(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const unpublishTemplate = React.useCallback<
        WorkspaceAPI["unpublishTemplate"]
    >(
        async (id: string) => {
            const res = await backend.templates.unpublish(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const deleteTemplate = React.useCallback<WorkspaceAPI["deleteTemplate"]>(
        async (id: string) => {
            const res = await backend.templates.delete(id);
            if (res.ok) {
                await refreshTemplates({ branchId: getCurrentBranchId() });
            }
            return res;
        },
        [backend.templates, getCurrentBranchId, refreshTemplates],
    );

    const invalidateTemplates = React.useCallback((): void => {
        setTemplates((s) => ({ ...s, updatedAt: undefined }));
    }, []);

    const resetTemplatesForBranch = React.useCallback((): void => {
        setTemplates((s) => ({ ...s, data: null, error: undefined }));
    }, []);

    return React.useMemo<TemplatesSliceApi>(
        () => ({
            templates,
            refreshTemplates,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidateTemplates,
            __setTemplatesState: setTemplates,
            resetTemplatesForBranch,
        }),
        [
            templates,
            refreshTemplates,
            createTemplate,
            updateTemplate,
            cloneTemplate,
            publishTemplate,
            unpublishTemplate,
            deleteTemplate,
            invalidateTemplates,
            resetTemplatesForBranch,
        ],
    );
}
```

---
#### 34


` File: src/react/workspace/context/provider/types.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/context/provider/types.ts
import type {
    Actor,
    Author,
    BackendError,
    Branch,
    BranchParticipant,
    Commit,
    Draft,
    FieldTemplate,
    LiveOptions,
    MergeResult,
    PermissionsMap,
    Result,
    ServiceSnapshot,
    SnapshotsLoadResult,
    TemplateCreateInput,
    TemplateUpdatePatch,
    TemplatesListParams,
    WorkspaceBackend,
    WorkspaceInfo,
} from "../backend";
import type { EditorSnapshot } from "@/schema/editor";
import type { DgpServiceMap } from "@/schema/provider";
import React from "react";
import { WorkspaceLiveAdapterRegistry } from "@/react/workspace/context/provider/live/types";

export interface Loadable<T> {
    readonly data: T | null;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export type SnapshotState = "clean" | "dirty" | "uncommitted" | "saving";

export type RunOk = { ok: true };
export type RunErr = { ok: false; errors: BackendError[] };
export type RunResult = RunOk | RunErr;

export interface WorkspaceProviderProps {
    readonly backend: WorkspaceBackend;
    readonly actor: Actor;

    readonly initial?: Partial<{
        authors: readonly Author[];
        permissions: PermissionsMap;
        branches: readonly Branch[];
        mainId: string;

        // branch-scoped caches
        templates: readonly FieldTemplate[];
        participants: readonly BranchParticipant[];

        snapshot: ServiceSnapshot;
        head?: Commit;
        draft?: Draft;

        currentBranchId?: string;

        // services can be injected as already-normalized map
        services: DgpServiceMap;
    }>;

    readonly ensureMain?: boolean;
    readonly live?: LiveOptions;
    /**
     * Optional adapter registry for live modes.
     * If you want ws/sse (or custom), pass adapters here.
     */
    readonly liveAdapters?: WorkspaceLiveAdapterRegistry;

    /**
     * Debounce refresh ticks (WS bursts etc). Default handled in hook (250ms).
     */
    readonly liveDebounceMs?: number;
    readonly autosaveMs?: number; // default 9000
    readonly autoAutosave?: boolean; // default true
    readonly children: React.ReactNode;
}

export interface BranchesSlice {
    readonly data: readonly Branch[];
    readonly mainId?: string;
    readonly currentId?: string;
    readonly loading: boolean;
    readonly error?: BackendError;
    readonly updatedAt?: number;
}

export interface SnapshotSlice {
    readonly schemaVersion?: string;
    readonly data?: EditorSnapshot;
    readonly head?: Commit;
    readonly draft?: Draft;

    readonly state: SnapshotState;
    readonly saving: boolean;
    readonly dirty: boolean;

    readonly lastSavedAt?: number;
    readonly lastDraftAt?: number;
}

export interface BranchCacheEntry {
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;
    readonly snapshot: SnapshotSlice;
}

export interface WorkspaceAPI {
    readonly info: WorkspaceInfo;
    readonly actor: Actor;

    readonly authors: Loadable<readonly Author[]>;
    readonly permissions: Loadable<PermissionsMap>;
    readonly branches: BranchesSlice;

    /** branch-scoped */
    readonly templates: Loadable<readonly FieldTemplate[]>;
    readonly participants: Loadable<readonly BranchParticipant[]>;

    /** workspace-scoped map (already normalized) */
    readonly services: Loadable<DgpServiceMap>;

    readonly refresh: {
        /** Refresh everything (workspace + current-branch context) */
        all(opts?: { strict?: boolean }): Promise<RunResult>;

        authors(): Promise<void>;
        permissions(): Promise<void>;
        branches(): Promise<void>;
        services(): Promise<void>;

        /** Current branch-scoped refreshers */
        branchContext(): Promise<void>;
        templates(
            params?: Partial<Pick<TemplatesListParams, "branchId" | "since">>,
        ): Promise<void>;
        participants(
            params?: Partial<{ branchId: string; since?: number | string }>,
        ): Promise<void>;

        snapshotPointers(): Promise<void>;
    };

    readonly setCurrentBranch: (id: string) => void;

    readonly createBranch: (
        name: string,
        opts?: Readonly<{ fromId?: string }>,
    ) => Result<Branch>;
    readonly setMain: (branchId: string) => Result<Branch>;
    readonly mergeBranch: (
        sourceId: string,
        targetId: string,
    ) => Result<MergeResult>;
    readonly deleteBranch: (branchId: string) => Result<void>;

    // Template ops
    readonly createTemplate: (
        input: TemplateCreateInput,
    ) => Result<FieldTemplate>;
    readonly updateTemplate: (
        id: string,
        patch: TemplateUpdatePatch,
    ) => Result<FieldTemplate>;
    readonly cloneTemplate: (
        source: Readonly<{ id?: string; key?: string }>,
        opts?: Readonly<{
            newKey?: string;
            name?: string;
            branchId?: string;
            asDraft?: boolean;
        }>,
    ) => Result<FieldTemplate>;
    readonly publishTemplate: (id: string) => Result<FieldTemplate>;
    readonly unpublishTemplate: (id: string) => Result<FieldTemplate>;
    readonly deleteTemplate: (id: string) => Result<void>;

    readonly invalidate: (
        keys?: Array<
            | "authors"
            | "permissions"
            | "branches"
            | "services"
            | "templates"
            | "participants"
        >,
    ) => void;

    readonly live: {
        readonly connected: boolean;
        readonly lastEventAt?: number;
        connect(): void;
        disconnect(): void;
    };

    readonly snapshot: {
        readonly state: SnapshotState;
        readonly saving: boolean;
        readonly dirty: boolean;
        readonly head?: Commit;
        readonly draft?: Draft;
        readonly schemaVersion?: string;
        readonly data?: EditorSnapshot;
        readonly lastSavedAt?: number;
        readonly lastDraftAt?: number;

        set(
            updater: (curr: EditorSnapshot | undefined) => EditorSnapshot,
        ): void;

        load(
            params?: Readonly<{ versionId?: string }>,
        ): Result<SnapshotsLoadResult>;
        refresh(): Promise<void>;

        autosave(): Result<Readonly<{ draft: Draft }>>;
        save(message?: string): Result<Readonly<{ commit: Commit }>>;
        publish(message?: string): Result<Readonly<{ commit: Commit }>>;
        discardDraft(): Result<void>;
    };
}
```

---
#### 35


` File: src/react/workspace/index.ts`  [‚Üë Back to top](#index)

```ts
// src/react/workspace/index.ts

export { Workspace } from "./app";
export type { WorkspaceProps } from "./app";

export * from "./context";
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) ‚Äî Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-21T11:35:04.482Z -->