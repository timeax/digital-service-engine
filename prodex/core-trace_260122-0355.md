*Generated by [Prodex](https://github.com/emxhive/prodex#readme)*
> Note for LLMs: `Lx-Ly` ranges refer to lines in this Prodex trace file, not the original source files. Index metadata is provided via the HTML comment markers in this section.

# Index
<!-- PRODEX_INDEX_RANGE: L8-L42 -->
<!-- PRODEX_FILE_COUNT: 35 -->
<!-- PRODEX_INDEX_LIST_START -->
- [src/core/__tests__/builder.test.ts](#1)  L46-L379
- [src/core/__tests__/fallback.spec.ts](#2)  L380-L681
- [src/core/__tests__/normalise.constraints.test.ts](#3)  L682-L752
- [src/core/__tests__/normalise.test.ts](#4)  L753-L1005
- [src/core/__tests__/policy.test.ts](#5)  L1006-L1169
- [src/core/__tests__/utility-validation.spec.ts](#6)  L1170-L1383
- [src/core/__tests__/validate.policies.test.ts](#7)  L1384-L1625
- [src/core/__tests__/validate.rate-coherence.spec.ts](#8)  L1626-L1866
- [src/core/__tests__/validate.test.ts](#9)  L1867-L2665
- [src/core/__tests__/validation.rate-coherence2.spec.ts](#10)  L2666-L2937
- [src/core/builder.ts](#11)  L2938-L3434
- [src/core/fallback.ts](#12)  L3435-L3840
- [src/core/index.ts](#13)  L3841-L3854
- [src/core/normalise.ts](#14)  L3855-L4294
- [src/core/policy.ts](#15)  L4295-L4708
- [src/core/rate-coherence.ts](#16)  L4709-L5027
- [src/core/validate.ts](#17)  L5028-L5038
- [src/core/validate/index.ts](#18)  L5039-L5152
- [src/core/validate/policies/apply-policies.ts](#19)  L5153-L5419
- [src/core/validate/policies/collect-service-items.ts](#20)  L5420-L5924
- [src/core/validate/policies/ops.ts](#21)  L5925-L5982
- [src/core/validate/policies/where.ts](#22)  L5983-L6041
- [src/core/validate/shared.ts](#23)  L6042-L6160
- [src/core/validate/steps/constraints.ts](#24)  L6161-L6329
- [src/core/validate/steps/custom.ts](#25)  L6330-L6355
- [src/core/validate/steps/fallbacks.ts](#26)  L6356-L6492
- [src/core/validate/steps/global-utility-guard.ts](#27)  L6493-L6536
- [src/core/validate/steps/identity.ts](#28)  L6537-L6679
- [src/core/validate/steps/option-maps.ts](#29)  L6680-L6757
- [src/core/validate/steps/rates.ts](#30)  L6758-L6815
- [src/core/validate/steps/service-vs-input.ts](#31)  L6816-L6866
- [src/core/validate/steps/structure.ts](#32)  L6867-L6969
- [src/core/validate/steps/unbound.ts](#33)  L6970-L7024
- [src/core/validate/steps/utility.ts](#34)  L7025-L7136
- [src/core/validate/steps/visibility.ts](#35)  L7137-L7277
<!-- PRODEX_INDEX_LIST_END -->

---
---
#### 1


` File: src/core/__tests__/builder.test.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { createBuilder } from "@/core";
import type { ServiceProps } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";

describe("Builder", () => {
    it("load() normalises payload and builds indices", () => {
        const b = createBuilder();
        // No root provided → normalise() should inject it
        const props: ServiceProps = { filters: [], fields: [] };
        b.load(props);

        const got = b.getProps();
        expect(Array.isArray(got.filters)).toBe(true);
        expect(got.filters[0]?.id).toBe("t:root");
    });

    it("tree() yields tag/field nodes and edges (child/bind/include/exclude)", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                {
                    id: "A",
                    label: "A",
                    bind_id: "root",
                    includes: ["fX"],
                    excludes: ["fY"],
                },
            ],
            fields: [
                { id: "f1", label: "F1", type: "text", bind_id: "A" },
                { id: "fX", label: "FX", type: "text" },
                { id: "fY", label: "FY", type: "text" },
            ],
        });

        const g = b.tree();
        // nodes include tags + fields
        const nodeIds = new Set(g.nodes.map((n) => n.id));
        expect(nodeIds.has("root")).toBe(true);
        expect(nodeIds.has("A")).toBe(true);
        expect(nodeIds.has("f1")).toBe(true);
        expect(nodeIds.has("fX")).toBe(true);

        // edges include child (root->A), bind (A->f1), include/exclude from A
        const sig = g.edges.map((e) => `${e.kind}:${e.from}->${e.to}`);
        expect(sig).toContain("child:root->A");
        expect(sig).toContain("bind:A->f1");
        expect(sig).toContain("include:A->fX");
        expect(sig).toContain("exclude:A->fY");
    });

    it("visibleFields(tagId) respects bind/include − exclude (static)", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                {
                    id: "G",
                    label: "Group",
                    bind_id: "root",
                    includes: ["fInc"],
                    excludes: ["fExc"],
                },
            ],
            fields: [
                { id: "fBound", label: "Bound", type: "text", bind_id: "G" },
                { id: "fInc", label: "Inc", type: "text" },
                { id: "fExc", label: "Exc", type: "text", bind_id: "G" },
                { id: "fOther", label: "Other", type: "text" },
            ],
        });

        const vis = b.visibleFields("G");
        expect(vis).toContain("fBound");
        expect(vis).toContain("fInc"); // included
        expect(vis).not.toContain("fExc"); // excluded
        expect(vis).not.toContain("fOther"); // neither bound nor included
    });

    it("visibleFields(tagId, selectedOptionKeys) applies option-level maps when provided", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                { id: "T", label: "T", bind_id: "root" },
            ],
            fields: [
                {
                    id: "toggle",
                    label: "Toggle",
                    type: "radio",
                    bind_id: "T",
                    options: [
                        { id: "on", label: "On" },
                        { id: "off", label: "Off" },
                    ],
                },
                { id: "base", label: "Base", type: "text", bind_id: "T" },
                { id: "util", label: "Util", type: "text" }, // not bound; will be included by option map
            ],
            includes_for_buttons: { "toggle::on": ["util"] },
            excludes_for_buttons: { "toggle::on": ["base"] },
        });

        const visOn = b.visibleFields("T", ["toggle::on"]);
        const visOff = b.visibleFields("T", ["toggle::off"]);

        expect(visOn).toContain("util"); // included by option
        expect(visOn).not.toContain("base"); // excluded by option
        expect(visOff).not.toContain("util"); // not included without selection
        expect(visOff).toContain("base"); // not excluded without selection
    });

    it("visibleFields uses builder.setOptions({ selectedOptionKeys }) when no argument is passed", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                { id: "T", label: "T", bind_id: "root" },
            ],
            fields: [
                {
                    id: "toggle",
                    label: "Toggle",
                    type: "radio",
                    bind_id: "T",
                    options: [
                        { id: "on", label: "On" },
                        { id: "off", label: "Off" },
                    ],
                },
                { id: "showme", label: "ShowMe", type: "text" },
            ],
            includes_for_buttons: { "toggle::on": ["showme"] },
        });

        b.setOptions({ selectedOptionKeys: ["toggle::on"] });
        const vis = b.visibleFields("T"); // no arg; uses options
        expect(vis).toContain("showme");
    });

    it("errors() integrates validate(): duplicate visible labels and custom rules surface", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                { id: "G", label: "Group", bind_id: "root" },
            ],
            fields: [
                {
                    id: "x",
                    label: "Same",
                    type: "text",
                    name: "n1",
                    bind_id: "G",
                },
                {
                    id: "y",
                    label: "Same",
                    type: "text",
                    name: "n2",
                    bind_id: "G",
                }, // duplicate_visible_label under G
                { id: "c", label: "C", type: "custom", bind_id: "G" }, // custom missing component
            ],
        });
        const errs = b.errors().map((e) => e.code);
        expect(errs).toContain("duplicate_visible_label");
        expect(errs).toContain("custom_component_missing");
    });

    it("cleanedProps() drops unbound utility fields that are excluded and prunes option maps", () => {
        const b = createBuilder();
        b.load({
            filters: [
                { id: "root", label: "Root" },
                {
                    id: "T",
                    label: "T",
                    bind_id: "root",
                    excludes: ["u_orphan"],
                }, // explicit exclude
            ],
            fields: [
                // unbound utility, excluded → will be dropped by cleanedProps()
                {
                    id: "u_orphan",
                    label: "U-orphan",
                    type: "text",
                    pricing_role: "utility",
                },
                // referenced via option include → kept
                {
                    id: "u_ref",
                    label: "U-ref",
                    type: "text",
                    pricing_role: "utility",
                },
                // option-bearing bound field
                {
                    id: "f1",
                    label: "F1",
                    type: "select",
                    bind_id: "T",
                    options: [
                        { id: "o1", label: "O1" },
                        { id: "o2", label: "O2" },
                    ],
                },
            ],
            // option key directly (no `f1::o1` style)
            includes_for_buttons: {
                o1: ["u_ref", "ghost_field"],
            },
            excludes_for_buttons: {
                o2: ["ghost_field"],
            },
        });

        const cleaned = b.cleanedProps();

        const fieldIds = cleaned.fields.map((f) => f.id);
        expect(fieldIds).not.toContain("u_orphan"); // dropped
        expect(fieldIds).toContain("u_ref"); // kept (referenced by option-map include)
        expect(fieldIds).toContain("f1");

        // option maps pruned to existing field ids only
        expect(cleaned.includes_for_buttons?.["o1"]).toEqual(["u_ref"]);
        expect(cleaned.excludes_for_buttons?.["o2"]).toBeUndefined(); // entire entry removed (all ghost)
    });

    it("undo()/redo() restore previous/next props snapshots", () => {
        const b = createBuilder();

        // initial
        b.load({ filters: [], fields: [] }); // normalise injects root
        const firstId = b.getProps().filters[0].id;
        expect(firstId).toBe("t:root");

        // next
        b.load({
            filters: [
                { id: "root", label: "Root" },
                { id: "A", label: "A", bind_id: "root" },
            ],
            fields: [],
        });
        expect(b.getProps().filters.some((t) => t.id === "A")).toBe(true);

        // undo → back to previous (no 'A')
        expect(b.undo()).toBe(true);
        expect(b.getProps().filters.some((t) => t.id === "A")).toBe(false);

        // redo → forward (has 'A')
        expect(b.redo()).toBe(true);
        expect(b.getProps().filters.some((t) => t.id === "A")).toBe(true);
    });

    it("cleanedProps preserves schema_version and returns canonical keys only", () => {
        const b = createBuilder();
        b.load({
            filters: [{ id: "root", label: "Root" }],
            fields: [],
            unknown: "x",
            schema_version: "2.0",
        } as any);

        const cleaned = b.cleanedProps();
        expect(cleaned.schema_version).toBe("2.0");
        expect(Object.keys(cleaned).sort()).toEqual(
            [
                "excludes_for_options",
                "filters",
                "fields",
                "includes_for_options",
                "schema_version",
            ]
                .filter((k) => (cleaned as any)[k] !== undefined)
                .sort(),
        );
    });

    it("visibleFields returns [] for unknown tag id", () => {
        const b = createBuilder();
        b.load({ filters: [{ id: "root", label: "Root" }], fields: [] });
        expect(b.visibleFields("nope")).toEqual([]);
    });

    it("errors() can use serviceMap in options (e.g., rate mismatch check)", () => {
        const b = createBuilder({
            serviceMap: {
                1: { id: 1, rate: 10, name: "" },
                2: { id: 2, rate: 20, name: "" },
            } satisfies DgpServiceMap,
        });
        b.load({
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "multi",
                    label: "Multi",
                    type: "multiselect",
                    options: [
                        {
                            id: "a",
                            label: "A",
                            service_id: 1,
                            pricing_role: "base",
                        },
                        {
                            id: "b",
                            label: "B",
                            service_id: 2,
                            pricing_role: "base",
                        },
                    ],
                },
            ],
        });
        const codes = b.errors().map((e) => e.code);
        expect(codes).toContain("rate_mismatch_across_base");
    });
});
```

---
#### 2


` File: src/core/__tests__/fallback.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import type { ServiceProps, Tag, Field, FieldOption } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";

import { collectFailedFallbacks } from "@/core";
import { pruneInvalidNodeFallbacks } from "@/utils/prune-fallbacks";

// ----------------------- fixtures -----------------------

const svc = (
    id: number,
    rate: number,
    flags?: Partial<
        Pick<NonNullable<DgpServiceMap[0]>, "dripfeed" | "refill" | "cancel">
    >,
) => ({
    id,
    name: `Service ${id}`,
    rate,
    flags,
});

const serviceMap: DgpServiceMap = {
    100: svc(100, 10, { dripfeed: false }), // base for T
    101: svc(101, 8, { dripfeed: false }), // cheaper, fits constraints
    102: svc(102, 12, { dripfeed: false }), // more expensive (rate violation)
    103: svc(103, 9, { dripfeed: true }), // cheaper but dripfeed true (constraint mismatch if tag wants false)
    104: svc(104, 7, { dripfeed: false }), // cheaper, fits constraints
    105: svc(105, 11, { dripfeed: false }), // option base
    106: svc(106, 9, { dripfeed: false }), // option base (multi-context)
};

function baseProps(): ServiceProps {
    const tags: Tag[] = [
        { id: "root", label: "Root" },
        // Single-context tag T
        {
            id: "T",
            label: "Group T",
            bind_id: "root",
            service_id: 100,
            // Effective constraints should be 'dripfeed:false'
            constraints: { dripfeed: false },
        },
        // Multi-context tags
        {
            id: "T1",
            label: "T1",
            bind_id: "root",
            constraints: { dripfeed: false },
        },
        {
            id: "T2",
            label: "T2",
            bind_id: "root",
            constraints: { dripfeed: true },
        },
    ];

    const fields: Field[] = [
        // Field bound to T, with an option that yields a service (optA)
        {
            id: "F_T",
            type: "select",
            label: "F_T",
            bind_id: "T",
            options: [
                {
                    id: "optA",
                    label: "A",
                    service_id: 105,
                    pricing_role: "base",
                } as FieldOption,
            ],
            pricing_role: "base",
        },
        // Field bound to both T1 & T2 (multi-context), with option optM yielding a service
        {
            id: "F_M",
            type: "select",
            label: "F_M",
            bind_id: ["T1", "T2"],
            options: [
                {
                    id: "optM",
                    label: "M",
                    service_id: 106,
                    pricing_role: "base",
                } as FieldOption,
            ],
            pricing_role: "base",
        },
    ];

    const props: ServiceProps = {
        filters: tags,
        fields,
        schema_version: "1.0",
        // Fallbacks shape we agreed: nodes + global
        fallbacks: {
            nodes: {
                // For tag T's base node
                T: [101, 102, 103],
                // For option optA (single-context)
                optA: [104],
                // For option optM (multi-context)
                optM: [103, 102],
            },
            // Global is soft (client does not prune)
            global: {
                100: [104, 102],
            },
        },
    };

    return props;
}

// Convenience to find reasons in diagnostics
function reasonsFor(
    diags: any[],
    where: Partial<{
        scope: string;
        nodeId: string | string[];
        candidate: number | string;
        tagContext: string;
    }>,
) {
    const wantedIds = Array.isArray(where.nodeId)
        ? where.nodeId
        : where.nodeId
          ? [where.nodeId]
          : undefined;
    return diags
        .filter((d) => {
            const scopeOk = where.scope ? d.scope === where.scope : true;
            const nodeOk = wantedIds
                ? wantedIds.some((id) => String(d.nodeId) === String(id))
                : true;
            const candOk =
                where.candidate !== undefined
                    ? String(d.candidate) === String(where.candidate)
                    : true;
            const ctxOk = where.tagContext
                ? d.tagContext === where.tagContext
                : true;
            return scopeOk && nodeOk && candOk && ctxOk;
        })
        .map((d) => d.reason)
        .sort();
}

// ----------------------- tests -----------------------

describe("fallbacks: node-scoped (rate + constraints)", () => {
    it("keeps a candidate that is cheaper and fits constraints", () => {
        const props = baseProps();

        const diags = collectFailedFallbacks(props, serviceMap, {
            mode: "dev",
        });
        // Tag T → candidate 101 should be fine (no failures for that pair)
        expect(reasonsFor(diags, { nodeId: "T", candidate: 101 })).toEqual([]);

        const { props: pruned, removed } = pruneInvalidNodeFallbacks(
            props,
            serviceMap,
            { requireConstraintFit: true },
        );
        expect(
            removed.find(
                (r) => r.nodeId === "T" && String(r.candidate) === "101",
            ),
        ).toBeFalsy();
        expect(pruned.fallbacks?.nodes?.T).toContain(101);
    });

    it("flags & prunes a rate violation (candidate more expensive than primary)", () => {
        const props = baseProps();

        const diags = collectFailedFallbacks(props, serviceMap, {
            mode: "dev",
        });
        expect(reasonsFor(diags, { nodeId: "T", candidate: 102 })).toContain(
            "rate_violation",
        );

        const { props: pruned, removed } = pruneInvalidNodeFallbacks(
            props,
            serviceMap,
            { requireConstraintFit: true },
        );
        // removed contains T::102
        expect(
            removed.some(
                (r) => r.nodeId === "T" && String(r.candidate) === "102",
            ),
        ).toBe(true);
        expect(pruned.fallbacks?.nodes?.T ?? []).not.toContain(102);
    });

    it("flags & prunes a constraint mismatch when the tag requires a flag (true) and the candidate lacks it", () => {
        const props = baseProps();

        // Make the tag require dripfeed=true so we actually have a requirement to check
        const t = props.filters.find((tt) => tt.id === "T")!;
        t.constraints = { dripfeed: true };

        const settings = {
            requireConstraintFit: true,
            ratePolicy: { kind: "lte_primary" as const },
        };

        // Candidate 101 has dripfeed: false (lacks the required capability) → mismatch
        const diags = collectFailedFallbacks(props, serviceMap, settings);
        expect(
            reasonsFor(diags, { nodeId: ["T", "tag:T"], candidate: 101 }),
        ).toContain("constraint_mismatch");

        const { props: pruned, removed } = pruneInvalidNodeFallbacks(
            props,
            serviceMap,
            settings,
        );
        expect(
            removed.some(
                (r) =>
                    (r.nodeId === "T" || r.nodeId === "tag:T") &&
                    String(r.candidate) === "101",
            ),
        ).toBe(true);
        expect(pruned.fallbacks?.nodes?.T ?? []).not.toContain(101);
    });
});

describe("fallbacks: option node with multi-tag context", () => {
    it("keeps a candidate that fails one context but passes another (fails-not-all rule)", () => {
        const props = baseProps();

        // Adjust contexts to actually require/passthrough
        const t1 = props.filters.find((tt) => tt.id === "T1")!;
        const t2 = props.filters.find((tt) => tt.id === "T2")!;
        t1.constraints = { dripfeed: true }; // requires true
        t2.constraints = { dripfeed: false }; // no requirement

        // Ensure optM fallbacks include a candidate that lacks dripfeed (to fail T1)
        // and one that is a rate violation (to be pruned).
        // service 101 -> dripfeed:false, service 102 -> rate 12 (violates lte_primary vs base 106=9)
        props.fallbacks!.nodes!.optM = [101, 102];

        const settings = {
            requireConstraintFit: true,
            ratePolicy: { kind: "lte_primary" as const },
        };

        const diags = collectFailedFallbacks(props, serviceMap, settings);

        // 101 should have at least one constraint failure (against T1)
        expect(
            reasonsFor(diags, { nodeId: ["optM"], candidate: 101 }),
        ).toContain("constraint_mismatch");

        // Prune only candidates that fail all contexts or violate rate policy
        const { props: pruned, removed } = pruneInvalidNodeFallbacks(
            props,
            serviceMap,
            settings,
        );

        // 101 kept (fails T1, passes T2)
        expect(pruned.fallbacks?.nodes?.optM).toContain(101);

        // 102 pruned (rate violation vs base 106=9)
        expect(
            removed.some(
                (r) => r.nodeId === "optM" && String(r.candidate) === "102",
            ),
        ).toBe(true);
        expect(pruned.fallbacks?.nodes?.optM ?? []).not.toContain(102);
    });
});

describe("fallbacks: global (soft)", () => {
    it("does not prune global fallbacks on the client", () => {
        const props = baseProps();
        const before = JSON.stringify(props.fallbacks?.global ?? {});
        const { props: pruned } = pruneInvalidNodeFallbacks(props, serviceMap, {
            requireConstraintFit: true,
        });
        const after = JSON.stringify(pruned.fallbacks?.global ?? {});
        expect(after).toBe(before); // untouched by design
    });
});
```

---
#### 3


` File: src/core/__tests__/normalise.constraints.test.ts`  [↑ Back to top](#index)

```ts
import {describe, it, expect} from 'vitest';
import {normalise} from "@/core";
import type {ServiceProps} from "@/schema";

describe('normalise() constraint propagation', () => {
    it('overrides child flags with nearest ancestor explicit values', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root', constraints: {refill: true}},
                {id: 'A', label: 'A', bind_id: 'root', constraints: {refill: false, cancel: true}},
                {id: 'B', label: 'B', bind_id: 'A', constraints: {dripfeed: true}},
            ],
            fields: [],
        };

        const out = normalise(props);
        const A = out.filters.find(t => t.id === 'A')!;
        const B = out.filters.find(t => t.id === 'B')!;

        // Parent refill:true overrides A.refill=false
        expect(A.constraints?.refill).toBe(true);
        // A.cancel:true is preserved (root didn’t set cancel), and passed to B
        expect(A.constraints?.cancel).toBe(true);

        // At B: inherits refill:true from root and cancel:true from A; keeps its own dripfeed:true
        expect(B.constraints?.refill).toBe(true);
        expect(B.constraints?.cancel).toBe(true);
        expect(B.constraints?.dripfeed).toBe(true);
    });

    it('does not invent constraints when none exist up the chain', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root'},
                {id: 'A', label: 'A', bind_id: 'root'},
                {id: 'B', label: 'B', bind_id: 'A'},
            ],
            fields: [],
        };
        const out = normalise(props);
        expect(out.filters.find(t => t.id === 'root')?.constraints).toBeUndefined();
        expect(out.filters.find(t => t.id === 'A')?.constraints).toBeUndefined();
        expect(out.filters.find(t => t.id === 'B')?.constraints).toBeUndefined();
    });

    it('handles multiple roots / orphaned nodes gracefully', () => {
        const props: ServiceProps = {
            filters: [
                {id: 'root', label: 'Root', constraints: {cancel: false}},
                {id: 'X', label: 'X', constraints: {refill: true}}, // orphan (no bind_id)
                {id: 'Y', label: 'Y', bind_id: 'X'},
            ],
            fields: [],
        };
        const out = normalise(props);
        // Root branch: only cancel:false propagates
        expect(out.filters.find(t => t.id === 'root')?.constraints?.cancel).toBe(false);
        // Orphan X acts as its own root; its refill:true propagates to Y
        expect(out.filters.find(t => t.id === 'X')?.constraints?.refill).toBe(true);
        expect(out.filters.find(t => t.id === 'Y')?.constraints?.refill).toBe(true);
    });
});
```

---
#### 4


` File: src/core/__tests__/normalise.test.ts`  [↑ Back to top](#index)

```ts
// src/core/__tests__/normalise.test.ts
import { describe, it, expect } from "vitest";
import { normalise } from "@/core";
import type { Field } from "@/schema";

describe("normalise()", () => {
    it("injects a root tag (t:root) if missing", () => {
        const input = {
            filters: [{ id: "t1", label: "Tag 1" }],
            fields: [],
        };

        const out = normalise(input);

        // root is injected and placed first
        expect(out.filters[0]).toMatchObject({ id: "t:root", label: "Root" });

        // original tag remains
        expect(out.filters.some((t) => t.id === "t1")).toBe(true);
    });

    it("keeps only canonical top-level keys and ignores legacy/camelCase keys", () => {
        const input = {
            // canonical
            filters: [
                { id: "t1", label: "T1", bind_id: "t:root", service_id: 42 },
            ],
            fields: [
                {
                    id: "f1",
                    label: "Field 1",
                    type: "select",
                    bind_id: ["t1", "t:root"],
                    options: [
                        { id: "o1", label: "Opt 1", service_id: 1001 },
                        { id: "o2", label: "Opt 2" },
                    ],
                },
            ],
            includes_for_buttons: { o1: ["f2"] },
            excludes_for_buttons: { o2: ["f3"] },

            // legacy / non-canonical (should be ignored)
            tags: [
                {
                    id: "tLegacy",
                    label: "Legacy",
                    bindId: "root",
                    serviceId: 99,
                },
            ],
            includesForOptions: { "f1::o1": ["ghost"] },
            excludeForOptions: { "f1::o2": ["ghost2"] },
            foo: "bar",
        };

        const out = normalise(input);

        // canonical keys only (plus schema_version)
        expect(Object.keys(out).sort()).toEqual(
            [
                "excludes_for_buttons",
                "filters",
                "fields",
                "includes_for_buttons",
                "schema_version",
            ].sort(),
        );

        // root injected (even if not provided explicitly)
        expect(out.filters[0]).toMatchObject({ id: "t:root", label: "Root" });

        // tag coercion (canonical snake_case only)
        const t1 = out.filters.find((t) => t.id === "t1")!;
        expect(t1.bind_id).toBe("t:root");
        expect(t1.service_id).toBe(42);

        // field coercion
        const f1 = out.fields.find((f) => f.id === "f1")!;
        expect(f1.bind_id).toEqual(["t1", "t:root"]);

        // option coercion
        expect(f1.options?.[0].service_id).toBe(1001);

        // option maps (canonical keys)
        expect(out.includes_for_buttons).toEqual({ o1: ["f2"] });
        expect(out.excludes_for_buttons).toEqual({ o2: ["f3"] });

        // legacy keys are not kept
        expect((out as any).tags).toBeUndefined();
        expect((out as any).includesForOptions).toBeUndefined();
        expect((out as any).excludeForOptions).toBeUndefined();
        expect((out as any).foo).toBeUndefined();
    });

    it("normalises bind_id: single => string, multi => array, dedupes arrays", () => {
        const input = {
            filters: [
                { id: "root", label: "Root" },
                { id: "t1", label: "T1" },
                { id: "t2", label: "T2" },
            ],
            fields: [
                { id: "f_single", label: "A", type: "text", bind_id: "t1" },
                {
                    id: "f_multi",
                    label: "B",
                    type: "text",
                    bind_id: ["t2", "t2", "root"],
                },
                { id: "f_none", label: "C", type: "text" },
            ],
        };

        const out = normalise(input);
        const fSingle = out.fields.find((f) => f.id === "f_single")!;
        const fMulti = out.fields.find((f) => f.id === "f_multi")!;
        const fNone = out.fields.find((f) => f.id === "f_none")!;

        expect(typeof fSingle.bind_id).toBe("string");
        expect(fSingle.bind_id).toBe("t1");

        expect(Array.isArray(fMulti.bind_id)).toBe(true);
        expect(fMulti.bind_id).toEqual(["t2", "root"]); // deduped, order preserved

        expect(fNone.bind_id).toBeUndefined();
    });

    it('defaults pricing_role to "base" on fields and cascades to options', () => {
        const input = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f1",
                    label: "F1",
                    type: "select",
                    options: [
                        { id: "o1", label: "O1" },
                        { id: "o2", label: "O2" },
                    ],
                },
            ],
        };

        const out = normalise(input);
        const f1 = out.fields.find((f) => f.id === "f1")!;
        expect(f1.pricing_role).toBe("base");
        expect(f1.options?.map((o) => o.pricing_role)).toEqual([
            "base",
            "base",
        ]);
    });

    it("respects option-level pricing_role override", () => {
        const input = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f1",
                    label: "F1",
                    type: "select",
                    pricing_role: "base",
                    options: [
                        { id: "o1", label: "O1" }, // will inherit base
                        { id: "o2", label: "O2", pricing_role: "utility" }, // override
                    ],
                },
            ],
        };

        const out = normalise(input);
        const f1 = out.fields.find((f) => f.id === "f1")!;
        expect(f1.pricing_role).toBe("base");
        expect(f1.options?.map((o) => o.pricing_role)).toEqual([
            "base",
            "utility",
        ]);
    });

    it("keeps component only for custom fields", () => {
        const input = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f_custom",
                    label: "Custom",
                    type: "custom",
                    component: "ServiceForm/Thing",
                },
                {
                    id: "f_text",
                    label: "Text",
                    type: "text",
                    component: "ShouldBeIgnored",
                },
            ],
        };

        const out = normalise(input);
        const fCustom = out.fields.find((f) => f.id === "f_custom")!;
        const fText = out.fields.find((f) => f.id === "f_text")!;

        expect(fCustom.component).toBe("ServiceForm/Thing");
        expect((fText as Field).component).toBeUndefined();
    });

    it('sets schema_version default to "1.0" if missing, preserves if provided', () => {
        const out1 = normalise({ filters: [], fields: [] });
        expect(out1.schema_version).toBe("1.0");

        const out2 = normalise({
            filters: [],
            fields: [],
            schema_version: "2.0",
        });
        expect(out2.schema_version).toBe("2.0");
    });

    it("dedupes include/exclude arrays on tags", () => {
        const input = {
            filters: [
                {
                    id: "root",
                    label: "Root",
                    includes: ["a", "a", "b"],
                    excludes: ["x", "x", "y"],
                },
            ],
            fields: [],
        };

        const out = normalise(input);
        const root = out.filters[1];
        expect(root.includes).toEqual(["a", "b"]);
        expect(root.excludes).toEqual(["x", "y"]);
    });

    it("handles empty/invalid inputs gracefully with meaningful errors", () => {
        expect(() => normalise(null as unknown as object)).toThrowError(
            /expected an object payload/i,
        );
        expect(() => normalise(undefined as unknown as object)).toThrowError();
    });
});
```

---
#### 5


` File: src/core/__tests__/policy.test.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { compilePolicies, splitPolicyDiagnostics } from "../policy";

describe("compilePolicies()", () => {
    it("defaults scope/subject/filter.role/severity/projection", () => {
        const raw = [{ id: "r1", label: "R1", op: "unique" }];
        const { policies, diagnostics } = compilePolicies(raw);

        expect(policies[0]).toMatchObject({
            id: "r1",
            label: "R1",
            scope: "visible_group",
            subject: "services",
            filter: { role: "both" },
            severity: "error",
            projection: "service.id",
            op: "unique",
        });

        expect(diagnostics.length).toBe(0);
    });

    it("accepts arrays or scalars in filter ids and defaults role", () => {
        const { policies, diagnostics } = compilePolicies([
            {
                id: "filt",
                label: "Filter",
                op: "unique",
                filter: { tag_id: "root", field_id: ["f1", "f2"] },
            },
        ]);

        expect(policies[0].filter?.tag_id).toEqual(["root"]);
        expect(policies[0].filter?.field_id).toEqual(["f1", "f2"]);
        expect(policies[0].filter?.role).toBe("both");
        expect(diagnostics.length).toBe(0);
    });

    it("generates id when missing and warns", () => {
        const { policies, diagnostics } = compilePolicies([{ op: "unique" }]);
        expect(policies[0].id).toMatch(/^policy_\d+$/);

        const { warnings } = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some((w) => /Missing "id"/.test(w.message))).toBe(true);
    });

    it("errors on invalid op and on missing numeric value for max_count", () => {
        const { policies, diagnostics } = compilePolicies([
            { id: "bad1", op: "nope" },
            { id: "bad2", op: "max_count" },
        ]);

        expect(policies.length).toBe(0);

        const { errors } = splitPolicyDiagnostics(diagnostics);
        expect(errors.some((e) => e.path === "op")).toBe(true);
        expect(errors.some((e) => e.path === "value")).toBe(true);
    });

    it('warns when projection for services does not start with "service."', () => {
        const { diagnostics } = compilePolicies([
            { id: "r", op: "unique", projection: "key" },
        ]);

        const { warnings } = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some((w) => w.path === "projection")).toBe(true);
    });

    it("warns when value is provided but unused for all_true/any_true", () => {
        const { diagnostics } = compilePolicies([
            { id: "r1", op: "all_true", value: true },
            { id: "r2", op: "any_true", value: false },
        ]);

        const { warnings } = splitPolicyDiagnostics(diagnostics);
        expect(warnings.filter((w) => w.path === "value").length).toBe(2);
    });

    it("normalises filter.where and warns on invalid entries", () => {
        const { policies, diagnostics } = compilePolicies([
            {
                id: "w1",
                op: "unique",
                filter: {
                    where: [
                        { path: "service.handler_id", op: "eq", value: 7 },
                        { path: "", op: "eq", value: 1 }, // invalid (empty path)
                        { path: "handler_id", op: "eq", value: 1 }, // warns (missing service. prefix)
                        { path: "service.platform_id", op: "nope", value: 2 }, // warns (bad op -> eq)
                        { path: "service.x", op: "in", value: "nope" }, // warns (in expects array)
                    ],
                },
            },
        ]);

        // valid ones survive; invalid empty-path entry is dropped
        expect(
            policies[0].filter?.where?.some(
                (w) => w.path === "service.handler_id",
            ),
        ).toBe(true);
        expect(policies[0].filter?.where?.some((w) => w.path === "")).toBe(
            false,
        );

        const { warnings } = splitPolicyDiagnostics(diagnostics);

        expect(
            warnings.some((w) => w.path?.includes("filter.where[1].path")),
        ).toBe(true);
        expect(
            warnings.some((w) => w.path?.includes("filter.where[2].path")),
        ).toBe(true);
        expect(
            warnings.some((w) => w.path?.includes("filter.where[3].op")),
        ).toBe(true);
        expect(
            warnings.some((w) => w.path?.includes("filter.where[4].value")),
        ).toBe(true);
    });

    it("defaults invalid scope/subject and emits warnings (but still compiles)", () => {
        const { policies, diagnostics } = compilePolicies([
            {
                id: "sx",
                op: "unique",
                scope: "nope" as any,
                subject: "nope" as any,
            },
        ]);

        expect(policies.length).toBe(1);
        expect(policies[0]).toMatchObject({
            id: "sx",
            scope: "visible_group",
            subject: "services",
        });

        const { warnings } = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some((w) => w.path === "scope")).toBe(true);
        expect(warnings.some((w) => w.path === "subject")).toBe(true);
    });

    it('warns when "label" is missing (but still compiles)', () => {
        const { policies, diagnostics } = compilePolicies([
            { id: "r1", op: "unique" },
        ]);

        expect(policies.length).toBe(1);
        expect(policies[0].id).toBe("r1");

        const { warnings } = splitPolicyDiagnostics(diagnostics);
        expect(warnings.some((w) => w.path === "label")).toBe(true);
    });
});
```

---
#### 6


` File: src/core/__tests__/utility-validation.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { validate } from "@/core";
import type { ServiceProps, Tag, Field, FieldOption } from "@/schema";

/* ───────────────────────── helpers & fixtures ───────────────────────── */

function rootOnly(): ServiceProps {
    const tags: Tag[] = [{ id: "root", label: "Root" }];
    return { filters: tags, fields: [], schema_version: "1.0" };
}

type Err = { code: string; nodeId?: string; details?: Record<string, unknown> };

function utilityErrors(all: Err[]): Err[] {
    return all.filter(
        (e: Err) => typeof e.code === "string" && e.code.startsWith("utility_"),
    );
}

function opt(id: string, patch?: Partial<FieldOption>): FieldOption {
    const base: FieldOption = {
        id,
        label: id,
        pricing_role: "utility" as const,
        meta: {},
    };
    return { ...base, ...(patch ?? {}) };
}

function field(id: string, patch?: Partial<Field>): Field {
    const base: Field = {
        id,
        type: "select",
        label: id,
        bind_id: "root",
        pricing_role: "utility",
        options: [],
        meta: {},
    };
    return { ...base, ...(patch ?? {}) } as Field;
}

/* ────────────────────────────── tests ─────────────────────────────── */

describe("utility validation", () => {
    it("flags an option marked as utility that also has a service_id (utility_with_service_id)", () => {
        const props: ServiceProps = rootOnly();

        const f = field("F1", {
            options: [
                opt("O1", {
                    pricing_role: "utility",
                    service_id: 999, // <-- not allowed for a utility option
                    // provide a seemingly valid utility meta to isolate the error under test
                    meta: { utility: { rate: 5, mode: "flat" } },
                }),
            ],
        });

        props.fields.push(f);

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) =>
                    e.code === "utility_with_service_id" && e.nodeId === "O1",
            ),
        ).toBe(true);
    });

    it("flags an option marked as utility with missing/invalid rate (utility_missing_rate)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F2", {
                options: [
                    opt("O2", {
                        pricing_role: "utility",
                        meta: {
                            // @ts-expect-error
                            utility: {
                                /* rate missing */ mode: "per_quantity",
                            },
                        },
                    }),
                    opt("O3", {
                        pricing_role: "utility",
                        meta: { utility: { rate: Number.NaN, mode: "flat" } }, // invalid rate
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) => e.code === "utility_missing_rate" && e.nodeId === "O2",
            ),
        ).toBe(true);
        expect(
            util.some(
                (e) => e.code === "utility_missing_rate" && e.nodeId === "O3",
            ),
        ).toBe(true);
    });

    it("flags an option marked as utility with invalid mode (utility_invalid_mode)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F3", {
                options: [
                    opt("O4", {
                        pricing_role: "utility",
                        meta: {
                            utility: {
                                rate: 2.5,
                                mode: "banana" as unknown as "flat",
                            },
                        }, // invalid
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(
            util.some(
                (e) => e.code === "utility_invalid_mode" && e.nodeId === "O4",
            ),
        ).toBe(true);
    });

    it("accepts a valid option-level utility (no service_id, finite rate, allowed mode)", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F4", {
                options: [
                    opt("O5", {
                        pricing_role: "utility",
                        meta: { utility: { rate: 3.0, mode: "per_quantity" } },
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "O5")).toBeUndefined();
    });

    it("accepts a valid field-level utility marker", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("UFEE", {
                pricing_role: "utility",
                // no options; this is a pure utility field (e.g., a checkbox/number/text)
                meta: { utility: { rate: 1.5, mode: "flat" } },
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "UFEE")).toBeUndefined();
    });

    it("accepts per_value utilities with or without valueBy", () => {
        const props: ServiceProps = rootOnly();

        props.fields.push(
            field("F5", {
                options: [
                    opt("O6", {
                        meta: {
                            utility: {
                                rate: 0.25,
                                mode: "per_value",
                                valueBy: "value",
                            },
                        },
                    }),
                    opt("O7", {
                        meta: { utility: { rate: 0.1, mode: "per_value" } }, // defaults are ok
                    }),
                ],
            }),
        );

        const errors: Err[] = validate(props, { allowUnsafe: true }) as any;
        const util = utilityErrors(errors);

        expect(util.find((e) => e.nodeId === "O6")).toBeUndefined();
        expect(util.find((e) => e.nodeId === "O7")).toBeUndefined();
    });
});
```

---
#### 7


` File: src/core/__tests__/validate.policies.test.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { validate } from "@/core";
import type { ServiceProps } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";
import type { DynamicRule } from "@/schema/validation";

describe("validate() dynamic policies", () => {
    const baseProps: ServiceProps = {
        filters: [
            { id: "root", label: "Root" },
            { id: "A", label: "A", bind_id: "root" },
        ],
        fields: [
            {
                id: "f1",
                label: "Base A",
                type: "select",
                bind_id: "A",
                options: [
                    {
                        id: "o1",
                        label: "S-1",
                        service_id: 1,
                        pricing_role: "base",
                    },
                    {
                        id: "o2",
                        label: "S-2",
                        service_id: 2,
                        pricing_role: "base",
                    },
                ],
            },
            {
                id: "f2",
                label: "Util A",
                type: "select",
                bind_id: "A",
                options: [
                    {
                        id: "u1",
                        label: "U-1",
                        service_id: 3,
                        pricing_role: "utility",
                    },
                ],
            },
        ],
    };

    // NOTE:
    // - These include the required ServiceDefinition bits: name/rate/min/max
    // - Extra host props (handler_id/platform_id/key/dripfeed via flags/meta) are fine
    const serviceMap: DgpServiceMap = {
        1: {
            id: 1,
            name: "S1",
            rate: 10,
            min: 1,
            max: 1000,
            key: "k1" as any,
            handler_id: 9 as any,
            platform_id: 100 as any,
            flags: {
                dripfeed: {
                    enabled: true,
                    description: "Supports dripfeed",
                },
            },
            meta: { type: "alpha" } as any,
        },
        2: {
            id: 2,
            name: "S2",
            rate: 10,
            min: 1,
            max: 1000,
            key: "k2" as any,
            handler_id: 9 as any,
            platform_id: 100 as any,
            flags: {
                dripfeed: {
                    enabled: true,
                    description: "Supports dripfeed",
                },
            },
            meta: { type: "alpha" } as any,
        },
        3: {
            id: 3,
            name: "U1",
            rate: 5,
            min: 1,
            max: 1000,
            key: "k1" as any, // duplicate globally with service 1
            handler_id: 7 as any,
            platform_id: 200 as any,
            flags: {
                dripfeed: {
                    enabled: false,
                    description: "No dripfeed",
                },
            },
            meta: { type: "beta" } as any,
        },
    };

    it("visible_group: all_equal on service type passes when equal", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-type-eq",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                projection: "service.type", // comes from meta.type (merged into service)
                op: "all_equal",
                message: "Base services in a group must share the same type",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    (e.details as any)?.ruleId === "grp-type-eq",
            ),
        ).toBe(false);
    });

    it("visible_group: no_mix handler_id fails when handlers differ", () => {
        const props: ServiceProps = JSON.parse(JSON.stringify(baseProps));
        // swap one BASE service to service 3 (handler 7 vs 9)
        (props.fields[0].options![1] as any).service_id = 3;

        const rules: DynamicRule[] = [
            {
                id: "grp-no-mix-handler",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                projection: "service.handler_id",
                op: "no_mix",
                message: "Do not mix providers in one group",
            },
        ];

        const out = validate(props, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-no-mix-handler",
            ),
        ).toBe(true);
    });

    it("global: unique key fails if duplicate provider keys exist", () => {
        const rules: DynamicRule[] = [
            {
                id: "global-unique-key",
                scope: "global",
                subject: "services",
                projection: "service.key",
                op: "unique",
                message: "Provider keys must be unique globally",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "global" &&
                    (e.details as any)?.ruleId === "global-unique-key",
            ),
        ).toBe(true);
    });

    it("visible_group: all_true dripfeed fails if any is false", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-dripfeed-alltrue",
                scope: "visible_group",
                subject: "services",
                projection: "service.flags.dripfeed.enabled",
                filter: { role: "both" },
                op: "all_true",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        // service 3 (utility) has dripfeed.enabled false → violation on tag A
        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-dripfeed-alltrue",
            ),
        ).toBe(true);
    });

    it("visible_group: max_count base=1 fails with two base items", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-max-one-base",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                op: "max_count",
                value: 1,
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-max-one-base",
            ),
        ).toBe(true);
    });
});
```

---
#### 8


` File: src/core/__tests__/validate.rate-coherence.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { validate } from "@/core";
import type { ServiceProps } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";
import type { DynamicRule } from "@/schema/validation";

describe("validate() dynamic policies", () => {
    const baseProps: ServiceProps = {
        filters: [
            { id: "root", label: "Root" },
            { id: "A", label: "A", bind_id: "root" },
        ],
        fields: [
            {
                id: "f1",
                label: "Base A",
                type: "select",
                bind_id: "A",
                options: [
                    {
                        id: "o1",
                        label: "S-1",
                        service_id: 1,
                        pricing_role: "base",
                    },
                    {
                        id: "o2",
                        label: "S-2",
                        service_id: 2,
                        pricing_role: "base",
                    },
                ],
            },
            {
                id: "f2",
                label: "Util A",
                type: "select",
                bind_id: "A",
                options: [
                    {
                        id: "u1",
                        label: "U-1",
                        service_id: 3,
                        pricing_role: "utility",
                    },
                ],
            },
        ],
    };

    const serviceMap: DgpServiceMap = {
        1: {
            id: 1,
            name: "S-1",
            rate: 10,
            min: 1,
            max: 1000,
            key: "k1" as any,
            handler_id: 9 as any,
            platform_id: 100 as any,
            // helps if your collector DOESN'T merge meta into service root:
            type: "alpha" as any,
            meta: { type: "alpha" } as any,
            flags: {
                dripfeed: {
                    enabled: true,
                    description: "Supports dripfeed",
                },
            },
        },
        2: {
            id: 2,
            name: "S-2",
            rate: 10,
            min: 1,
            max: 1000,
            key: "k2" as any,
            handler_id: 9 as any,
            platform_id: 100 as any,
            type: "alpha" as any,
            meta: { type: "alpha" } as any,
            flags: {
                dripfeed: {
                    enabled: true,
                    description: "Supports dripfeed",
                },
            },
        },
        3: {
            id: 3,
            name: "U-1",
            rate: 5,
            min: 1,
            max: 1000,
            key: "k1" as any, // duplicate globally with service 1
            handler_id: 7 as any,
            platform_id: 200 as any,
            type: "beta" as any,
            meta: { type: "beta" } as any,
            flags: {
                dripfeed: {
                    enabled: false,
                    description: "No dripfeed",
                },
            },
        },
    };

    it("visible_group: all_equal on service type passes when equal", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-type-eq",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                projection: "service.type",
                op: "all_equal",
                message: "Base services in a group must share the same type",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    (e.details as any)?.ruleId === "grp-type-eq",
            ),
        ).toBe(false);
    });

    it("visible_group: no_mix handler_id fails when handlers differ", () => {
        const props: ServiceProps = JSON.parse(JSON.stringify(baseProps));
        (props.fields[0].options![1] as any).service_id = 3; // handler 7 vs 9

        const rules: DynamicRule[] = [
            {
                id: "grp-no-mix-handler",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                projection: "service.handler_id",
                op: "no_mix",
                message: "Do not mix providers in one group",
            },
        ];

        const out = validate(props, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-no-mix-handler",
            ),
        ).toBe(true);
    });

    it("global: unique key fails if duplicate provider keys exist", () => {
        const rules: DynamicRule[] = [
            {
                id: "global-unique-key",
                scope: "global",
                subject: "services",
                projection: "service.key",
                op: "unique",
                message: "Provider keys must be unique globally",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "global" &&
                    (e.details as any)?.ruleId === "global-unique-key",
            ),
        ).toBe(true);
    });

    it("visible_group: all_true dripfeed fails if any is false", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-dripfeed-alltrue",
                scope: "visible_group",
                subject: "services",
                projection: "service.flags.dripfeed.enabled",
                filter: { role: "both" },
                op: "all_true",
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-dripfeed-alltrue",
            ),
        ).toBe(true);
    });

    it("visible_group: max_count base=1 fails with two base items", () => {
        const rules: DynamicRule[] = [
            {
                id: "grp-max-one-base",
                scope: "visible_group",
                subject: "services",
                filter: { role: "base" },
                op: "max_count",
                value: 1,
            },
        ];

        const out = validate(baseProps, { serviceMap, policies: rules });

        expect(
            out.some(
                (e) =>
                    e.code === "policy_violation" &&
                    e.nodeId === "A" &&
                    (e.details as any)?.ruleId === "grp-max-one-base",
            ),
        ).toBe(true);
    });
});
```

---
#### 9


` File: src/core/__tests__/validate.test.ts`  [↑ Back to top](#index)

```ts
// src/core/__tests__/validate.test.ts
import { describe, it, expect } from "vitest";
import { validate } from "@/core";
import type { ServiceProps, Field } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";
import { normalise } from "@/core";

function errs(
    props: ServiceProps,
    serviceMap: DgpServiceMap = {},
    shouldNormalise = true,
) {
    return validate(shouldNormalise ? normalise(props) : props, { serviceMap });
}

describe("validate()", () => {
    it("flags root_missing", () => {
        const out = errs(
            {
                filters: [{ id: "t1", label: "T1" }],
                fields: [],
            },
            undefined,
            false,
        );
        expect(out.some((e) => e.code === "root_missing")).toBe(true);
    });

    it("detects cycles and bad bind references (tags & fields)", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root" },
                { id: "a", label: "A", bind_id: "b" },
                { id: "b", label: "B", bind_id: "a" }, // cycle a <-> b
                { id: "c", label: "C", bind_id: "zzz" }, // bad ref
            ],
            fields: [
                {
                    id: "f1",
                    label: "F1",
                    type: "text",
                    name: "n1",
                    bind_id: "nope",
                }, // bad ref
            ],
        };
        const out = errs(props);
        expect(out.some((e) => e.code === "cycle_in_tags")).toBe(true);
        expect(
            out.find(
                (e) =>
                    e.code === "bad_bind_reference" && e.details?.ref === "zzz",
            ),
        ).toBeTruthy();
        expect(
            out.find(
                (e) =>
                    e.code === "bad_bind_reference" &&
                    e.details?.ref === "nope",
            ),
        ).toBeTruthy();
    });

    it("flags duplicate_id, duplicate_tag_label, duplicate_field_name, and label_missing", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "" }, // label_missing
                { id: "dup", label: "Same" },
                { id: "t2", label: "Same" }, // duplicate_tag_label
            ],
            fields: [
                { id: "dup", label: "   ", type: "text", name: "email" }, // duplicate_id + label_missing
                { id: "f2", label: "Field", type: "text", name: "email" }, // duplicate_field_name
                {
                    id: "f3",
                    label: "With options",
                    type: "select",
                    name: "shouldNotHaveService",
                    options: [{ id: "o1", label: "" }], // option label_missing
                },
            ],
        };
        const out = errs(props);
        expect(
            out.some((e) => e.code === "duplicate_id" && e.nodeId === "dup"),
        ).toBe(true);
        expect(out.some((e) => e.code === "duplicate_tag_label")).toBe(true);
        expect(
            out.some(
                (e) => e.code === "duplicate_field_name" && e.nodeId === "f2",
            ),
        ).toBe(true);
        expect(
            out.filter((e) => e.code === "label_missing").length,
        ).toBeGreaterThanOrEqual(3);
    });

    it("validates option map keys and include/exclude conflicts", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f1",
                    label: "Sel",
                    type: "select",
                    options: [{ id: "o1", label: "O1" }],
                },
            ],
            includes_for_buttons: {
                "f1::o1": ["x"],
                "f1::bad": ["y"], // bad key (option not found)
            },
            excludes_for_buttons: {
                "f1::o1": ["z"], // conflict with includes_for_options
            },
        };
        const out = errs(props);
        expect(
            out.some(
                (e) =>
                    e.code === "bad_option_key" && e.details?.key === "f1::bad",
            ),
        ).toBe(true);
        expect(
            out.some(
                (e) =>
                    e.code === "option_include_exclude_conflict" &&
                    e.details?.key === "f1::o1",
            ),
        ).toBe(true);
    });

    it("detects duplicate_visible_label under a tag (bind/include − exclude)", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "a",
                    label: "Same Label",
                    type: "text",
                    name: "x",
                    bind_id: "root",
                },
                {
                    id: "b",
                    label: "Same Label",
                    type: "text",
                    name: "y",
                    bind_id: "root",
                },
            ],
        };
        const out = errs(props);
        expect(out.some((e) => e.code === "duplicate_visible_label")).toBe(
            true,
        );
    });

    it("service vs user-input rules", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "svc_missing",
                    label: "No Name No Service",
                    type: "select",
                    options: [],
                }, // should require service option
                {
                    id: "user_with_service",
                    label: "User Field",
                    type: "select",
                    name: "username",
                    options: [{ id: "o1", label: "O1", service_id: 1 }], // not allowed for user-input
                },
                {
                    id: "custom_with_service",
                    label: "Custom Svc",
                    type: "custom",
                    component: "X/Y",
                    options: [{ id: "o1", label: "O1", service_id: 2 }], // custom cannot map services
                },
            ],
        };
        const out = errs(props);
        expect(
            out.some(
                (e) =>
                    e.code === "service_field_missing_service_id" &&
                    e.nodeId === "svc_missing",
            ),
        ).toBe(true);
        expect(
            out.some(
                (e) =>
                    e.code === "user_input_field_has_service_option" &&
                    e.nodeId === "user_with_service",
            ),
        ).toBe(true);
        expect(
            out.some(
                (e) =>
                    e.code === "user_input_field_has_service_option" &&
                    e.nodeId === "custom_with_service",
            ),
        ).toBe(true);
    });

    it("custom fields must have a component", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [{ id: "c1", label: "C", type: "custom" }],
        };
        const out = errs(props);
        expect(
            out.some(
                (e) =>
                    e.code === "custom_component_missing" && e.nodeId === "c1",
            ),
        ).toBe(true);
    });

    it("rate mismatch across BASE options (multi-select) uses DgpServiceMap", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f_multi",
                    label: "Multi",
                    type: "multiselect", // triggers multi
                    options: [
                        {
                            id: "o1",
                            label: "A",
                            service_id: 1,
                            pricing_role: "base",
                        },
                        {
                            id: "o2",
                            label: "B",
                            service_id: 2,
                            pricing_role: "base",
                        },
                        {
                            id: "o3",
                            label: "C",
                            service_id: 3,
                            pricing_role: "utility",
                        }, // utility ignored for rate match
                    ],
                },
            ],
        };
        const serviceMap: DgpServiceMap = {
            1: {
                id: 1,
                rate: 10,
                refill: true,
                cancel: false,
                dripfeed: false,
            },
            2: {
                id: 2,
                rate: 20,
                refill: true,
                cancel: false,
                dripfeed: false,
            },
            3: { id: 3, rate: 999, refill: true, cancel: true, dripfeed: true },
        };
        const out = errs(props, serviceMap);
        expect(
            out.some(
                (e) =>
                    e.code === "rate_mismatch_across_base" &&
                    e.nodeId === "f_multi",
            ),
        ).toBe(true);
    });

    it("utility_without_base (per visible group): utility visible under root but no base → error on root", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f",
                    label: "F",
                    type: "select",
                    bind_id: "root", // <-- make it visible under root
                    options: [
                        {
                            id: "oU",
                            label: "U",
                            service_id: 10,
                            pricing_role: "utility",
                        },
                    ],
                },
            ],
        };
        const serviceMap: DgpServiceMap = { 10: { id: 10, rate: 30 } };
        const out = validate(normalise(props), { serviceMap });
        // error is attached to the TAG (group), with the list of utility option ids
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "root",
            ),
        ).toBe(true);
        const err = out.find(
            (e) => e.code === "utility_without_base" && e.nodeId === "root",
        );
        expect(err?.details?.utilityOptionIds).toContain("oU");
    });

    it("constraints: descendant cannot contradict ancestor; tag promises must be supported by service", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root", constraints: { refill: true } },
                {
                    id: "t1",
                    label: "Child",
                    bind_id: "root",
                    constraints: { refill: false },
                }, // contradiction
                {
                    id: "t2",
                    label: "SvcTag",
                    service_id: 100,
                    constraints: { cancel: true },
                }, // unsupported by service
            ],
            fields: [],
        };
        const serviceMap: DgpServiceMap = {
            100: {
                id: 100,
                rate: 5,
                cancel: false,
                refill: true,
                dripfeed: true,
            },
        };
        const out = errs(props, serviceMap);
        expect(
            out.some(
                (e) =>
                    (e.code === "constraint_contradiction" ||
                        e.code === "constraint_overridden") &&
                    e.nodeId === "t1",
            ),
        ).toBe(true);
        expect(
            out.some(
                (e) =>
                    e.code === "unsupported_constraint" &&
                    e.nodeId === "t2" &&
                    e.details?.flag === "cancel",
            ),
        ).toBe(true);
    });

    it("treats meta.multi as multi-select for custom type strings", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "fX",
                    label: "X",
                    type: "my_custom_multi", // not a known keyword
                    meta: { multi: true },
                    options: [
                        {
                            id: "o1",
                            label: "A",
                            service_id: 1,
                            pricing_role: "base",
                        },
                        {
                            id: "o2",
                            label: "B",
                            service_id: 2,
                            pricing_role: "base",
                        },
                    ],
                } as unknown as Field,
            ],
        };
        const serviceMap: DgpServiceMap = {
            1: { id: 1, rate: 1 },
            2: { id: 2, rate: 2 },
        };
        const out = errs(props, serviceMap);
        expect(
            out.some(
                (e) =>
                    e.code === "rate_mismatch_across_base" && e.nodeId === "fX",
            ),
        ).toBe(true);
    });

    it("utility_without_base is scoped per visible tag group", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root" },
                { id: "A", label: "Group A", bind_id: "root" },
                { id: "B", label: "Group B", bind_id: "root" },
            ],
            fields: [
                // Utility under A (provider-backed)
                {
                    id: "fU",
                    label: "Theme",
                    type: "select",
                    bind_id: "A",
                    options: [
                        {
                            id: "u1",
                            label: "Premium",
                            service_id: 3001,
                            pricing_role: "utility",
                        },
                    ],
                },
                // Base under B (provider-backed)
                {
                    id: "fB",
                    label: "Site Type",
                    type: "select",
                    bind_id: "B",
                    options: [
                        {
                            id: "b1",
                            label: "Basic",
                            service_id: 2001,
                            pricing_role: "base",
                        },
                    ],
                },
            ],
        };

        const out = validate(props, { serviceMap: {} });
        // Error only on tag A (its group has utility but no base)
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "A",
            ),
        ).toBe(true);
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "B",
            ),
        ).toBe(false);
    });

    it("group visibility respects excludes (base excluded → utility_without_base fires)", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root" },
                // Tag T excludes the base field, so only utility remains visible
                {
                    id: "T",
                    label: "Group T",
                    bind_id: "root",
                    excludes: ["fBase"],
                },
            ],
            fields: [
                {
                    id: "fBase",
                    label: "Base Choice",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "b1",
                            label: "Base",
                            service_id: 10,
                            pricing_role: "base",
                        },
                    ],
                },
                {
                    id: "fUtil",
                    label: "Add-on",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "u1",
                            label: "Addon",
                            service_id: 11,
                            pricing_role: "utility",
                        },
                    ],
                },
            ],
        };

        const out = validate(props, { serviceMap: {} });
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "T",
            ),
        ).toBe(true);
    });

    it("option-level include/exclude: util included, base excluded → utility_without_base on T", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root" },
                { id: "T", label: "Group", bind_id: "root" },
            ],
            fields: [
                {
                    id: "toggle",
                    label: "Toggle",
                    type: "radio",
                    bind_id: "T",
                    options: [
                        { id: "on", label: "On" },
                        { id: "off", label: "Off" },
                    ],
                },
                // Base (bound to T) but will be excluded when toggle:on
                {
                    id: "base",
                    label: "Base",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "b",
                            label: "B",
                            service_id: 1,
                            pricing_role: "base",
                        },
                    ],
                },
                // Utility (bound to T) but only included when toggle:on
                {
                    id: "util",
                    label: "Util",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "u",
                            label: "U",
                            service_id: 2,
                            pricing_role: "utility",
                        },
                    ],
                },
            ],
            includes_for_buttons: { "toggle::on": ["util"] },
            excludes_for_buttons: { "toggle::on": ["base"] }, // <-- hide base when "on"
        };

        const out = validate(props, { selectedOptionKeys: ["toggle::on"] });
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "T",
            ),
        ).toBe(true);

        const out2 = validate(props, { selectedOptionKeys: ["toggle::off"] });
        expect(
            out2.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "T",
            ),
        ).toBe(false);
    });

    it("option-level exclude hides base; util remains visible → utility_without_base fires", () => {
        const props: ServiceProps = {
            filters: [
                { id: "root", label: "Root" },
                { id: "T", label: "Group", bind_id: "root" },
            ],
            fields: [
                {
                    id: "toggle",
                    label: "Toggle",
                    type: "radio",
                    bind_id: "T",
                    options: [
                        { id: "hideBase", label: "Hide Base" },
                        { id: "showAll", label: "Show All" },
                    ],
                },
                // Base field (bound to T)
                {
                    id: "base",
                    label: "Base",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "b",
                            label: "B",
                            service_id: 1,
                            pricing_role: "base",
                        },
                    ],
                },
                // Util field (bound to T)
                {
                    id: "util",
                    label: "Util",
                    type: "select",
                    bind_id: "T",
                    options: [
                        {
                            id: "u",
                            label: "U",
                            service_id: 2,
                            pricing_role: "utility",
                        },
                    ],
                },
            ],
            excludes_for_buttons: {
                "toggle::hideBase": ["base"],
            },
        };

        // Select "hideBase": base excluded → util visible without base → error
        const out = validate(props, {
            selectedOptionKeys: ["toggle::hideBase"],
        });
        expect(
            out.some(
                (e) => e.code === "utility_without_base" && e.nodeId === "T",
            ),
        ).toBe(true);

        // Select "showAll": nothing excluded → base present → OK
        const out2 = validate(props, {
            selectedOptionKeys: ["toggle::showAll"],
        });
        expect(out2.some((e) => e.code === "utility_without_base")).toBe(false);
    });

    it("globalUtilityGuard: flags when utilities exist anywhere but no base exists", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "f",
                    label: "F",
                    type: "select",
                    bind_id: "root",
                    options: [
                        {
                            id: "u",
                            label: "U",
                            service_id: 10,
                            pricing_role: "utility",
                        },
                    ],
                },
            ],
        };
        const out = validate(props, { globalUtilityGuard: true });
        expect(
            out.some(
                (e) =>
                    e.code === "utility_without_base" && e.nodeId === "global",
            ),
        ).toBe(true);
    });

    it("globalUtilityGuard: no error when any base exists anywhere", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "uF",
                    label: "Util",
                    type: "select",
                    bind_id: "root",
                    options: [
                        {
                            id: "u",
                            label: "U",
                            service_id: 10,
                            pricing_role: "utility",
                        },
                    ],
                },
                {
                    id: "bF",
                    label: "Base",
                    type: "select",
                    bind_id: "root",
                    options: [
                        {
                            id: "b",
                            label: "B",
                            service_id: 99,
                            pricing_role: "base",
                        },
                    ],
                },
            ],
        };
        const out = validate(props, { globalUtilityGuard: true });
        expect(
            out.some(
                (e) =>
                    e.code === "utility_without_base" && e.nodeId === "global",
            ),
        ).toBe(false);
    });

    it("flags field_unbound when a field is neither bound nor included by tag/option", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                { id: "orphan", label: "Orphan", type: "text" }, // ❌
                { id: "bound", label: "Bound", type: "text", bind_id: "root" }, // ✅
            ],
        };
        const out = validate(props);
        expect(
            out.some(
                (e) => e.code === "field_unbound" && e.nodeId === "orphan",
            ),
        ).toBe(true);
        expect(
            out.some((e) => e.code === "field_unbound" && e.nodeId === "bound"),
        ).toBe(false);
    });

    it("does NOT flag when the field is only included by tag.includes", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root", includes: ["incOnly"] }],
            fields: [{ id: "incOnly", label: "Included", type: "text" }],
        };
        const out = validate(props);
        expect(out.some((e) => e.code === "field_unbound")).toBe(false);
    });

    it("does NOT flag when the field is only included via includes_for_options", () => {
        const props: ServiceProps = {
            filters: [{ id: "root", label: "Root" }],
            fields: [
                {
                    id: "toggle",
                    label: "Toggle",
                    type: "radio",
                    bind_id: "root",
                    options: [{ id: "on", label: "On" }],
                },
                { id: "incByOpt", label: "IncludedByOption", type: "text" },
            ],
            includes_for_buttons: { "toggle::on": ["incByOpt"] },
        };
        const out = validate(props);
        expect(
            out.some(
                (e) => e.code === "field_unbound" && e.nodeId === "incByOpt",
            ),
        ).toBe(false);
    });

    it("validator emits constraint_overridden warnings from normaliser meta", () => {
        const props = normalise({
            filters: [
                { id: "root", label: "Root", constraints: { dripfeed: false } },
                {
                    id: "T",
                    label: "T",
                    bind_id: "root",
                    constraints: { dripfeed: true },
                }, // overridden → false
            ],
            fields: [],
        });
        const out = validate(props);
        const warn = out.find(
            (e) => e.code === "constraint_overridden" && e.nodeId === "T",
        );
        expect(warn?.details?.flag).toBe("dripfeed");
        expect(warn?.details?.from).toBe(true);
        expect(warn?.details?.to).toBe(false);
        expect(warn?.details?.origin).toBe("root");
    });
});
```

---
#### 10


` File: src/core/__tests__/validation.rate-coherence2.spec.ts`  [↑ Back to top](#index)

```ts
import { describe, it, expect } from "vitest";
import { ServiceProps } from "@/schema";
import { DgpServiceMap } from "@/schema/provider";
import { Builder, createBuilder } from "@/core";
import { validateRateCoherenceDeep } from "@/core";

/* helpers */
function svc(id: number, rate: number) {
    return { id, rate };
}
function makeBuilder(props: ServiceProps, services: DgpServiceMap): Builder {
    const b = createBuilder({ serviceMap: services });
    b.load(props);
    return b;
}

describe("validateRateCoherenceDeep (no tag-base primary)", () => {
    it("within_pct: anchor without base → first revealed base becomes primary; flags > 10% over primary", () => {
        const services: DgpServiceMap = {
            // tag base present but must not be used
            2100: svc(2100, 999),
            2101: svc(2101, 100), // will be chosen as primary (first revealed)
            2102: svc(2102, 112), // 12% above -> violation
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2100 }],
            fields: [
                {
                    id: "f:probe",
                    type: "switch",
                    label: "Probe",
                    bind_id: "t:root",
                    button: true,
                    pricing_role: "base",
                },
                // order matters: f:A before f:B to make 100 the primary
                {
                    id: "f:A",
                    type: "select",
                    label: "A",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:100",
                            label: "100",
                            pricing_role: "base",
                            service_id: 2101,
                        },
                    ],
                },
                {
                    id: "f:B",
                    type: "select",
                    label: "B",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:112",
                            label: "112",
                            pricing_role: "base",
                            service_id: 2102,
                        },
                    ],
                },
            ],
            includes_for_buttons: {
                "f:probe": ["f:A", "f:B"],
            },
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "within_pct", pct: 10 },
        });

        // offender 112 must be flagged; 100 is primary
        const flagged112 = diags.filter((d) => d.offender.service_id === 2102);
        expect(flagged112.length).toBeGreaterThan(0);
        expect(
            flagged112.some((d) => d.simulationAnchor.id === "f:probe"),
        ).toBe(true);

        const flagged100 = diags.filter((d) => d.offender.service_id === 2101);
        expect(flagged100.length).toBe(0);
    });

    it("lte_primary: when reveal shows 100 then 105, 105 violates vs primary 100", () => {
        const services: DgpServiceMap = {
            2200: { id: 2200, rate: 777 }, // tag base (ignored for primary)
            2201: { id: 2201, rate: 100 }, // primary candidate
            2202: { id: 2202, rate: 105 }, // offender
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2200 }],
            fields: [
                // Anchor (bound) – selecting this should reveal the two base candidates
                { id: "f:reveal", type: "switch", label: "Reveal", bind_id: "t:root", button: true, pricing_role: "base" },

                // Two base buttons (UNBOUND): only become visible during the simulation via includes_for_buttons
                { id: "f:ok",  type: "switch", label: "OK",  /* no bind_id */ button: true, pricing_role: "base", service_id: 2201 },
                { id: "f:aux", type: "switch", label: "Aux", /* no bind_id */ button: true, pricing_role: "base", service_id: 2202 },
            ],
            includes_for_buttons: {
                // selecting f:reveal reveals f:ok then f:aux (order matters; 100 becomes primary)
                "f:reveal": ["f:ok", "f:aux"],
            },
        };

        const b = createBuilder({ serviceMap: services });
        b.load(props);

        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "lte_primary" },
        });

        // 105 must be flagged against primary 100
        const flagged105 = diags.filter((d) => d.offender.service_id === 2202);
        expect(flagged105.length).toBeGreaterThan(0);
        expect(flagged105.some((d) => d.simulationAnchor.id === "f:reveal")).toBe(true);

        // 100 never flagged
        const flagged100 = diags.filter((d) => d.offender.service_id === 2201);
        expect(flagged100.length).toBe(0);
    });

    it("anchor with its own base uses itself as primary (no tag), other ≤10% is OK", () => {
        const services: DgpServiceMap = {
            2300: svc(2300, 999),
            2301: svc(2301, 109),
            2302: svc(2302, 111), // within ~1.83% of 109 -> OK
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2300 }],
            fields: [
                {
                    id: "f:opt",
                    type: "select",
                    label: "Opt",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:109",
                            label: "109",
                            pricing_role: "base",
                            service_id: 2301,
                        },
                        {
                            id: "o:111",
                            label: "111",
                            pricing_role: "base",
                            service_id: 2302,
                        },
                    ],
                },
            ],
            includes_for_buttons: {},
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "within_pct", pct: 10 },
        });

        expect(diags.length).toBe(0);
    });

    it("utility-role candidates are ignored as base even if they carry service_id", () => {
        const services: DgpServiceMap = {
            2400: svc(2400, 100),
            2401: svc(2401, 1000), // absurd, but utility → must be ignored
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2400 }],
            fields: [
                {
                    id: "f:u",
                    type: "select",
                    label: "Util",
                    bind_id: "t:root",
                    options: [
                        {
                            id: "o:util",
                            label: "Util",
                            pricing_role: "utility",
                            service_id: 2401 as any,
                        },
                    ],
                },
            ],
            includes_for_buttons: {
                "f:u::o:util": [],
            },
        };

        const b = makeBuilder(props, services);
        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "lte_primary" },
        });

        expect(diags.length).toBe(0);
    });

    it("at_least_pct_lower: primary=190 (first), 195 violates (not ≥5% lower)", () => {
        const services: DgpServiceMap = {
            2500: { id: 2500, rate: 777 }, // tag base (ignored for primary)
            2501: { id: 2501, rate: 190 }, // primary
            2502: { id: 2502, rate: 195 }, // offender
        };

        const props: ServiceProps = {
            schema_version: "1.0",
            filters: [{ id: "t:root", label: "Root", service_id: 2500 }],
            fields: [
                // Anchor (bound)
                { id: "f:probe", type: "switch", label: "Probe", bind_id: "t:root", button: true, pricing_role: "base" },

                // Two base buttons (UNBOUND), revealed (in order) by selecting the anchor
                { id: "f:A", type: "switch", label: "A", /* no bind_id */ button: true, pricing_role: "base", service_id: 2501 }, // first => primary
                { id: "f:B", type: "switch", label: "B", /* no bind_id */ button: true, pricing_role: "base", service_id: 2502 },
            ],
            includes_for_buttons: {
                "f:probe": ["f:A", "f:B"],
            },
        };

        const b = createBuilder({ serviceMap: services });
        b.load(props);

        const diags = validateRateCoherenceDeep({
            builder: b,
            services,
            tagId: "t:root",
            ratePolicy: { kind: "at_least_pct_lower", pct: 5 },
        });

        const bad = diags.filter((d) => d.offender.service_id === 2502);
        const good = diags.filter((d) => d.offender.service_id === 2501);

        expect(bad.length).toBeGreaterThan(0);
        expect(bad.some((d) => d.simulationAnchor.id === "f:probe")).toBe(true);
        expect(good.length).toBe(0);
    });
});
```

---
#### 11


` File: src/core/builder.ts`  [↑ Back to top](#index)

```ts
// src/core/builder.ts
import { normalise } from "./normalise";
import { validate } from "./validate";

import type { ServiceProps, Tag, Field } from "@/schema";
import type {
    GraphNode,
    GraphEdge,
    GraphSnapshot,
    NodeKind,
    EdgeKind,
} from "@/schema/graph";
import type { DgpServiceMap } from "@/schema/provider";
import type { ValidationError, ValidatorOptions } from "@/schema/validation";

/** Options you can set on the builder (used for validation/visibility) */
export type BuilderOptions = Omit<ValidatorOptions, "serviceMap"> & {
    serviceMap?: DgpServiceMap;
    /** max history entries for undo/redo */
    historyLimit?: number;
    /**
     * Field ids whose options should be shown as nodes in the graph.
     * If a field id is NOT in this set, its options are not materialized as nodes:
     * - include/exclude wires keyed by an option id will be drawn from the FIELD instead.
     */
    showOptionNodes?: Set<string> | string[];
};

export interface Builder {
    /** Replace current payload (injects root if missing, rebuilds indexes) */
    load(props: ServiceProps): void;

    /** Graph for visualisation */
    tree(): GraphSnapshot;

    /** Deterministic save payload (drops unbound utility fields, prunes dead maps) */
    cleanedProps(): ServiceProps;

    /** Validation errors for current state */
    errors(): ValidationError[];

    /**
     * Compute IDs of fields visible under a tag.
     * If selectedOptionKeys provided, applies option-level include/exclude.
     * NOTE: keys are “button ids”: either option.id or field.id for option-less buttons.
     */
    visibleFields(tagId: string, selectedOptionKeys?: string[]): string[];

    /** Update builder options (validator context etc.) */
    setOptions(patch: Partial<BuilderOptions>): void;

    /** History */
    undo(): boolean;
    redo(): boolean;

    /** Access the current props (already normalised) */
    getProps(): ServiceProps;

    /** Service map for validation/rules */
    getServiceMap(): DgpServiceMap;
}

export function createBuilder(opts: BuilderOptions = {}): Builder {
    return new BuilderImpl(opts);
}

/* ────────────────────────────────────────────────────────────────────────── */

class BuilderImpl implements Builder {
    private props: ServiceProps = {
        filters: [],
        fields: [],
        schema_version: "1.0",
    };
    private tagById = new Map<string, Tag>();
    private fieldById = new Map<string, Field>();
    private optionOwnerById = new Map<string, { fieldId: string }>(); // option.id → fieldId

    private options: BuilderOptions;
    private readonly history: ServiceProps[] = [];
    private readonly future: ServiceProps[] = [];
    private readonly historyLimit: number;

    constructor(opts: BuilderOptions = {}) {
        this.options = { ...opts };
        this.historyLimit = opts.historyLimit ?? 50;
    }

    /* ───── lifecycle ─────────────────────────────────────────────────────── */

    load(raw: ServiceProps): void {
        const next = normalise(raw, { defaultPricingRole: "base" });
        this.pushHistory(this.props);
        this.future.length = 0; // clear redo stack
        this.props = next;
        this.rebuildIndexes();
    }

    getProps(): ServiceProps {
        return this.props;
    }

    setOptions(patch: Partial<BuilderOptions>): void {
        this.options = { ...this.options, ...patch };
    }

    getServiceMap(): DgpServiceMap {
        return this.options.serviceMap ?? {};
    }

    /* ───── querying ─────────────────────────────────────────────────────── */

    tree(): GraphSnapshot {
        const nodes: GraphNode[] = [];
        const edges: GraphEdge[] = [];

        const showSet = toStringSet(this.options.showOptionNodes);

        // 1) tags as nodes
        for (const t of this.props.filters) {
            nodes.push({ id: t.id, kind: "tag" as NodeKind, label: t.label });
        }

        // 2) tag hierarchy edges
        for (const t of this.props.filters) {
            if (t.bind_id) {
                edges.push({
                    from: t.bind_id,
                    to: t.id,
                    kind: "child" as EdgeKind,
                });
            }
        }

        // 3) fields as nodes
        for (const f of this.props.fields) {
            nodes.push({
                id: f.id,
                kind: "field" as NodeKind,
                label: f.label,
                bind_type:
                    f.pricing_role === "utility"
                        ? "utility"
                        : f.bind_id
                          ? "bound"
                          : null,
            });
        }

        // 4) field bind edges
        for (const f of this.props.fields) {
            const b = f.bind_id;
            if (Array.isArray(b)) {
                for (const tagId of b)
                    edges.push({
                        from: tagId,
                        to: f.id,
                        kind: "bind" as EdgeKind,
                    });
            } else if (typeof b === "string") {
                edges.push({ from: b, to: f.id, kind: "bind" as EdgeKind });
            }
        }

        // 5) Option nodes (only for fields in showOptionNodes)
        for (const f of this.props.fields) {
            const showOptions = showSet.has(f.id);
            if (!showOptions) continue;
            if (!Array.isArray(f.options)) continue;

            for (const o of f.options) {
                nodes.push({
                    id: o.id,
                    kind: "option",
                    label: o.label,
                });
                // field → option edge
                const e: any = {
                    from: f.id,
                    to: o.id,
                    kind: "option" as EdgeKind,
                    meta: { ownerField: f.id },
                };
                edges.push(e as GraphEdge);
            }
        }

        // 6) tag includes/excludes
        for (const t of this.props.filters) {
            for (const id of t.includes ?? []) {
                edges.push({ from: t.id, to: id, kind: "include" as EdgeKind });
            }
            for (const id of t.excludes ?? []) {
                edges.push({ from: t.id, to: id, kind: "exclude" as EdgeKind });
            }
        }

        // 7) button-level includes/excludes (keys are button IDs: option.id OR field.id)
        const incMap = this.props.includes_for_buttons ?? {};
        const excMap = this.props.excludes_for_buttons ?? {};

        const pushButtonEdge = (
            keyId: string,
            targetFieldId: string,
            kind: EdgeKind,
        ) => {
            const owner = this.optionOwnerById.get(keyId);
            const ownerFieldId =
                owner?.fieldId ??
                (this.fieldById.has(keyId) ? keyId : undefined);
            if (!ownerFieldId) return; // dangling key, ignore

            // If the key is an option AND its field is being shown, draw from the option
            const fromNode =
                owner && showSet.has(owner.fieldId)
                    ? keyId // option node → visible, draw from option
                    : ownerFieldId; // else draw from the field

            const meta: any = owner
                ? showSet.has(owner.fieldId)
                    ? {
                          via: "option-visible",
                          ownerField: owner.fieldId,
                          sourceOption: keyId,
                      }
                    : {
                          via: "option-hidden",
                          ownerField: owner.fieldId,
                          sourceOption: keyId,
                      }
                : { via: "field-button" };

            const e: any = { from: fromNode, to: targetFieldId, kind, meta };
            edges.push(e as GraphEdge);
        };

        for (const [keyId, arr] of Object.entries(incMap)) {
            for (const fid of arr ?? [])
                pushButtonEdge(keyId, fid, "include" as EdgeKind);
        }
        for (const [keyId, arr] of Object.entries(excMap)) {
            for (const fid of arr ?? [])
                pushButtonEdge(keyId, fid, "exclude" as EdgeKind);
        }

        return { nodes, edges };
    }

    cleanedProps(): ServiceProps {
        // Build quick indexes
        const fieldIds = new Set(this.props.fields.map((f) => f.id));
        const optionIds = new Set<string>();
        this.optionOwnerById.forEach((_v, oid) => optionIds.add(oid));

        // 1) drop utility fields that are truly "orphaned"
        //    (unbound + not included by tag or button includes + not referenced as a key)
        const includedByTag = new Set<string>();
        const excludedAnywhere = new Set<string>();
        for (const t of this.props.filters) {
            for (const id of t.includes ?? []) includedByTag.add(id);
            for (const id of t.excludes ?? []) excludedAnywhere.add(id);
        }

        const incMap = this.props.includes_for_buttons ?? {};
        const excMap = this.props.excludes_for_buttons ?? {};
        const includedByButtons = new Set<string>(); // field ids that might be pulled in
        const referencedKeys = new Set<string>(); // keys in maps (field button or option id)
        const referencedOwnerFields = new Set<string>();

        for (const [key, arr] of Object.entries(incMap)) {
            referencedKeys.add(key);
            const owner = this.optionOwnerById.get(key);
            if (owner) referencedOwnerFields.add(owner.fieldId);
            for (const fid of arr ?? []) {
                includedByButtons.add(fid);
            }
        }
        for (const [key, arr] of Object.entries(excMap)) {
            referencedKeys.add(key);
            const owner = this.optionOwnerById.get(key);
            if (owner) referencedOwnerFields.add(owner.fieldId);
            for (const fid of arr ?? []) {
                // exclusion targets don’t “include”, but record that these field ids are referenced
                // (so we don’t accidentally drop something host intentionally excludes/controls)
                // not strictly necessary, but conservative:
                void fid;
            }
        }

        const boundIds = new Set<string>();
        for (const f of this.props.fields) {
            const b = f.bind_id;
            if (Array.isArray(b)) b.forEach((id) => boundIds.add(id));
            else if (typeof b === "string") boundIds.add(b);
        }

        const fields = this.props.fields.filter((f) => {
            const isUtility = (f.pricing_role ?? "base") === "utility";
            if (!isUtility) return true;

            const bound = !!f.bind_id;
            const included =
                includedByTag.has(f.id) || includedByButtons.has(f.id);
            const referenced =
                referencedOwnerFields.has(f.id) || referencedKeys.has(f.id);
            const excluded = excludedAnywhere.has(f.id);

            // keep if bound OR included OR referenced by maps; drop if truly orphaned or globally excluded
            return bound || included || referenced || !excluded;
        });

        // 2) prune button maps: keep only valid keys and existing field targets
        const allowedTargets = new Set(fields.map((f) => f.id)); // targets must be existing fields

        const pruneButtons = (src?: Record<string, string[]>) => {
            if (!src) return undefined;
            const out: Record<string, string[]> = {};
            for (const [key, arr] of Object.entries(src)) {
                // key must be an existing option.id OR field.id
                const keyIsValid = optionIds.has(key) || fieldIds.has(key);
                if (!keyIsValid) continue;

                const cleaned = (arr ?? []).filter((fid) =>
                    allowedTargets.has(fid),
                );
                if (cleaned.length) out[key] = Array.from(new Set(cleaned));
            }
            return Object.keys(out).length ? out : undefined;
        };

        const includes_for_buttons = pruneButtons(
            this.props.includes_for_buttons,
        );
        const excludes_for_buttons = pruneButtons(
            this.props.excludes_for_buttons,
        );

        // 3) return canonical object
        const out: ServiceProps = {
            filters: this.props.filters.slice(),
            fields,
            ...(includes_for_buttons && { includes_for_buttons }),
            ...(excludes_for_buttons && { excludes_for_buttons }),
            schema_version: this.props.schema_version ?? "1.0",
            // keep fallbacks & other maps as-is
            ...(this.props.fallbacks
                ? { fallbacks: this.props.fallbacks }
                : {}),
        };
        return out;
    }

    errors(): ValidationError[] {
        return validate(this.props, this.options);
    }

    visibleFields(tagId: string, selectedKeys?: string[]): string[] {
        const props = this.props;
        const selected = new Set(
            selectedKeys ?? this.options.selectedOptionKeys ?? [],
        );

        const tag = (props.filters ?? []).find((t) => t.id === tagId);
        if (!tag) return [];

        const tagInclude = new Set(tag.includes ?? []);
        const tagExclude = new Set(tag.excludes ?? []);

        // Button maps (can be keyed by fieldId OR "fieldId::optionId")
        const incMap = props.includes_for_buttons ?? {};
        const excMap = props.excludes_for_buttons ?? {};

        // Collect includes/excludes coming from the current selection,
        // and keep an ordered list of *revealed* ids to preserve determinism.
        const revealedOrder: string[] = [];
        const includeFromSelection = new Set<string>();
        const excludeFromSelection = new Set<string>();

        for (const key of selected) {
            const inc = incMap[key] ?? [];
            for (const id of inc) {
                if (!includeFromSelection.has(id)) revealedOrder.push(id);
                includeFromSelection.add(id);
            }
            const exc = excMap[key] ?? [];
            for (const id of exc) excludeFromSelection.add(id);
        }

        // Build candidate pool
        const pool = new Map<string, Field>();
        for (const f of props.fields ?? []) {
            if (isBoundTo(f, tagId)) pool.set(f.id, f);
            if (tagInclude.has(f.id)) pool.set(f.id, f);
            if (includeFromSelection.has(f.id)) pool.set(f.id, f);
        }

        // Remove excludes
        for (const id of tagExclude) pool.delete(id);
        for (const id of excludeFromSelection) pool.delete(id);

        // Optional explicit ordering per tag
        const order = props.order_for_tags?.[tagId];

        if (order && order.length) {
            // 1) tag order
            const ordered: string[] = [];
            for (const fid of order) if (pool.has(fid)) ordered.push(fid);
            // 2) any remaining (preserve insertion order)
            for (const fid of pool.keys())
                if (!ordered.includes(fid)) ordered.push(fid);
            return ordered;
        }

        // No tag order → promote revealed fields FIRST (in the exact reveal order),
        // then anything else in the natural field order.
        const promoted = revealedOrder.filter((fid) => pool.has(fid));
        const rest: string[] = [];
        for (const fid of pool.keys()) {
            if (!promoted.includes(fid)) rest.push(fid);
        }
        return [...promoted, ...rest];
    }

    /* ───── history ─────────────────────────────────────────────────────── */

    undo(): boolean {
        if (this.history.length === 0) return false;
        const prev = this.history.pop()!;
        this.future.push(structuredCloneSafe(this.props));
        this.props = prev;
        this.rebuildIndexes();
        return true;
    }

    redo(): boolean {
        if (this.future.length === 0) return false;
        const next = this.future.pop()!;
        this.pushHistory(this.props);
        this.props = next;
        this.rebuildIndexes();
        return true;
    }

    /* ───── internals ──────────────────────────────────────────────────── */

    private rebuildIndexes(): void {
        this.tagById.clear();
        this.fieldById.clear();
        this.optionOwnerById.clear();

        for (const t of this.props.filters) this.tagById.set(t.id, t);
        for (const f of this.props.fields) {
            this.fieldById.set(f.id, f);
            if (Array.isArray(f.options)) {
                for (const o of f.options)
                    this.optionOwnerById.set(o.id, { fieldId: f.id });
            }
        }
    }

    private pushHistory(state: ServiceProps): void {
        // avoid pushing initial empty state on the very first load
        if (!state || (!state.filters.length && !state.fields.length)) return;
        this.history.push(structuredCloneSafe(state));
        if (this.history.length > this.historyLimit) this.history.shift();
    }
}

/* ───────────────────────── helpers ───────────────────────── */

function isBoundTo(f: Field, tagId: string): boolean {
    const b = f.bind_id;
    if (!b) return false;
    return Array.isArray(b) ? b.includes(tagId) : b === tagId;
}

function structuredCloneSafe<T>(v: T): T {
    if (typeof (globalThis as any).structuredClone === "function") {
        return (globalThis as any).structuredClone(v);
    }
    return JSON.parse(JSON.stringify(v));
}

function toStringSet(v: Set<string> | string[] | undefined): Set<string> {
    if (!v) return new Set();
    if (v instanceof Set) return new Set(Array.from(v).map(String));
    return new Set((v as string[]).map(String));
}
```

---
#### 12


` File: src/core/fallback.ts`  [↑ Back to top](#index)

```ts
// src/core/utils/fallback.ts
import type {
    ServiceProps,
    ServiceFallback,
    ServiceIdRef,
    NodeIdRef,
} from "@/schema";
import type { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import type { FallbackSettings } from "@/schema/validation";

export type FailedFallbackContext = {
    scope: "node" | "global";
    nodeId?: string; // when scope='node'
    primary: ServiceIdRef;
    candidate: ServiceIdRef;
    tagContext?: string; // tag.id when evaluating constraints
    reason:
        | "unknown_service"
        | "no_primary"
        | "rate_violation"
        | "constraint_mismatch"
        | "cycle"
        | "no_tag_context";
    details?: Record<string, unknown>;
};

const DEFAULT_SETTINGS: Required<FallbackSettings> = {
    requireConstraintFit: true,
    ratePolicy: { kind: "lte_primary" },
    selectionStrategy: "priority",
    mode: "strict",
};

export function resolveServiceFallback(params: {
    primary: ServiceIdRef;
    nodeId?: NodeIdRef; // prefer node-scoped first if provided
    tagId?: string; // constraints context (if known)
    services: DgpServiceMap;
    fallbacks?: ServiceFallback;
    settings?: FallbackSettings;
    props: ServiceProps;
}): ServiceIdRef | null {
    const s = { ...DEFAULT_SETTINGS, ...(params.settings ?? {}) };
    const { primary, nodeId, tagId, services } = params;
    const fb = params.fallbacks ?? {};
    const tried: ServiceIdRef[] = [];

    const lists: ServiceIdRef[][] = [];
    if (nodeId && fb.nodes?.[nodeId]) lists.push(fb.nodes[nodeId]);
    if (fb.global?.[primary]) lists.push(fb.global[primary]);

    const primaryRate = rateOf(services, primary);

    for (const list of lists) {
        for (const cand of list) {
            if (tried.includes(cand)) continue;
            tried.push(cand);

            const candCap = services[Number(cand)] ?? services[cand as any];
            if (!candCap) continue;

            if (!passesRate(s.ratePolicy, primaryRate, candCap.rate)) continue;
            if (s.requireConstraintFit && tagId) {
                const ok = satisfiesTagConstraints(tagId, params, candCap);
                if (!ok) continue;
            }
            return cand;
        }
    }
    return null;
}

export function collectFailedFallbacks(
    props: ServiceProps,
    services: DgpServiceMap,
    settings?: FallbackSettings,
): FailedFallbackContext[] {
    const s = { ...DEFAULT_SETTINGS, ...(settings ?? {}) };
    const out: FailedFallbackContext[] = [];
    const fb = props.fallbacks ?? {};
    const primaryRate = (p: ServiceIdRef) => rateOf(services, p);

    // Node-scoped (tags or options)
    for (const [nodeId, list] of Object.entries(fb.nodes ?? {})) {
        const { primary, tagContexts } = primaryForNode(props, nodeId);
        if (!primary) {
            out.push({
                scope: "node",
                nodeId,
                primary: "" as any,
                candidate: "" as any,
                reason: "no_primary",
            });
            continue;
        }
        for (const cand of list) {
            const cap = getCap(services, cand);
            if (!cap) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "unknown_service",
                });
                continue;
            }
            if (String(cand) === String(primary)) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "cycle",
                });
                continue;
            }
            if (!passesRate(s.ratePolicy, primaryRate(primary), cap.rate)) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "rate_violation",
                });
                continue;
            }
            // Tag contexts
            if (tagContexts.length === 0) {
                out.push({
                    scope: "node",
                    nodeId,
                    primary,
                    candidate: cand,
                    reason: "no_tag_context",
                });
                continue;
            }
            let anyPass = false;
            let anyFail = false;
            for (const tagId of tagContexts) {
                const ok = s.requireConstraintFit
                    ? satisfiesTagConstraints(tagId, { services, props }, cap)
                    : true;
                if (ok) anyPass = true;
                else {
                    anyFail = true;
                    out.push({
                        scope: "node",
                        nodeId,
                        primary,
                        candidate: cand,
                        tagContext: tagId,
                        reason: "constraint_mismatch",
                    });
                }
            }
            // If none passed, we already added per-context mismatches above
            void anyPass;
            void anyFail;
        }
    }

    // Global (soft; no tag context)
    for (const [primary, list] of Object.entries(fb.global ?? {})) {
        for (const cand of list) {
            const cap = getCap(services, cand);
            if (!cap) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "unknown_service",
                });
                continue;
            }
            if (String(cand) === String(primary)) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "cycle",
                });
                continue;
            }
            if (!passesRate(s.ratePolicy, primaryRate(primary), cap.rate)) {
                out.push({
                    scope: "global",
                    primary,
                    candidate: cand,
                    reason: "rate_violation",
                });
            }
        }
    }
    return out;
}

/* ───────────────────────── helpers ───────────────────────── */

function rateOf(
    map: DgpServiceMap,
    id: ServiceIdRef | undefined,
): number | undefined {
    if (id === undefined || id === null) return undefined;
    const c = getCap(map, id);
    return c?.rate ?? undefined;
}

function passesRate(
    policy: Required<FallbackSettings>["ratePolicy"],
    primaryRate?: number,
    candRate?: number,
): boolean {
    if (typeof candRate !== "number" || !Number.isFinite(candRate))
        return false;
    if (typeof primaryRate !== "number" || !Number.isFinite(primaryRate))
        return false;
    switch (policy.kind) {
        case "lte_primary":
            return candRate <= primaryRate;
        case "within_pct":
            return candRate <= primaryRate * (1 + policy.pct / 100);
        case "at_least_pct_lower":
            return candRate <= primaryRate * (1 - policy.pct / 100);
    }
}

function getCap(
    map: DgpServiceMap,
    id: ServiceIdRef,
): DgpServiceCapability | undefined {
    // Keep the old behavior, but avoid NaN poisoning lookups.
    const direct: DgpServiceCapability | undefined = (map as any)[id];
    if (direct) return direct;

    const strKey: string = String(id);
    const byStr: DgpServiceCapability | undefined = (map as any)[strKey];
    if (byStr) return byStr;

    const n: number =
        typeof id === "number"
            ? id
            : typeof id === "string"
              ? Number(id)
              : Number.NaN;

    if (Number.isFinite(n)) {
        const byNum: DgpServiceCapability | undefined = (map as any)[n];
        if (byNum) return byNum;
    }

    return undefined;
}

function isCapFlagEnabled(cap: DgpServiceCapability, flagId: string): boolean {
    // New structure: flags[flagId].enabled
    const fromFlags: boolean | undefined = cap.flags?.[flagId]?.enabled;
    if (fromFlags === true) return true;
    if (fromFlags === false) return false;

    // Soft-compat during migration: if legacy boolean exists on cap, respect it.
    const legacy: unknown = (cap as any)[flagId];
    return legacy === true;
}

function satisfiesTagConstraints(
    tagId: string,
    ctx: Readonly<{ props: ServiceProps; services: DgpServiceMap }>,
    cap: DgpServiceCapability,
): boolean {
    const tag = ctx.props.filters.find((t) => t.id === tagId);
    const eff: Record<string, unknown> | undefined = tag?.constraints as any; // effective constraints (propagated)
    if (!eff) return true;

    // Enforce only keys explicitly set TRUE at the tag; false/undefined => no requirement.
    for (const [key, value] of Object.entries(eff)) {
        if (value === true && !isCapFlagEnabled(cap, key)) {
            return false;
        }
    }

    return true;
}

function primaryForNode(
    props: ServiceProps,
    nodeId: string,
): {
    primary?: ServiceIdRef;
    tagContexts: string[];
    reasonNoPrimary?: string;
} {
    // Tag node?
    const tag = props.filters.find((t) => t.id === nodeId);
    if (tag) {
        return { primary: tag.service_id as any, tagContexts: [tag.id] };
    }
    // Option node: locate its parent field
    const field = props.fields.find(
        (f) =>
            Array.isArray(f.options) && f.options.some((o) => o.id === nodeId),
    );
    if (!field) return { tagContexts: [], reasonNoPrimary: "no_parent_field" };
    const opt = field.options!.find((o) => o.id === nodeId)!;
    const contexts = bindIdsToArray(field.bind_id);
    return { primary: opt.service_id as any, tagContexts: contexts };
}

function bindIdsToArray(bind: string | string[] | undefined): string[] {
    if (!bind) return [];
    return Array.isArray(bind) ? bind.slice() : [bind];
}

/**
 * Return all fallback candidates that are eligible for the given primary,
 * respecting:
 *  - node-scoped list first (if nodeId provided), then global list for `primary`
 *  - rate policy vs. primary
 *  - (optional) tag constraint fit, only when tagId is provided and requireConstraintFit=true
 *  - excludes (including primary automatically)
 *  - selectionStrategy: 'priority' keeps list order, 'cheapest' sorts by rate asc
 *  - unique (dedupe) and optional limit
 */
export function getEligibleFallbacks(params: {
    primary: ServiceIdRef;
    nodeId?: NodeIdRef; // prefer node-scoped list first
    tagId?: string; // constraints context (if known)
    services: DgpServiceMap;
    fallbacks?: ServiceFallback;
    settings?: FallbackSettings;
    props: ServiceProps;
    exclude?: Array<ServiceIdRef>; // additional ids to ignore
    unique?: boolean; // default true
    limit?: number; // optional cap
}): ServiceIdRef[] {
    const s = { ...DEFAULT_SETTINGS, ...(params.settings ?? {}) };
    const { primary, nodeId, tagId, services } = params;
    const fb = params.fallbacks ?? {};
    const excludes = new Set<string>((params.exclude ?? []).map(String));
    excludes.add(String(primary)); // never return the primary itself
    const unique = params.unique ?? true;

    // Gather source lists: node → global
    const lists: ServiceIdRef[][] = [];
    if (nodeId && fb.nodes?.[nodeId]) lists.push(fb.nodes[nodeId]);
    if (fb.global?.[primary]) lists.push(fb.global[primary]);

    if (!lists.length) return [];

    const primaryRate = rateOf(services, primary);
    const seen = new Set<string>();
    const eligible: ServiceIdRef[] = [];

    for (const list of lists) {
        for (const cand of list) {
            const key = String(cand);
            if (excludes.has(key)) continue;
            if (unique && seen.has(key)) continue;
            seen.add(key);

            const cap = getCap(services, cand);
            if (!cap) continue;

            // Rate policy must pass
            if (!passesRate(s.ratePolicy, primaryRate, cap.rate)) continue;

            // Tag constraint fit is only enforced if we know tagId and setting requires it
            if (s.requireConstraintFit && tagId) {
                const ok = satisfiesTagConstraints(
                    tagId,
                    { props: params.props, services },
                    cap,
                );
                if (!ok) continue;
            }

            eligible.push(cand);
        }
    }

    // Selection strategy
    if (s.selectionStrategy === "cheapest") {
        eligible.sort((a, b) => {
            const ra = rateOf(services, a) ?? Infinity;
            const rb = rateOf(services, b) ?? Infinity;
            return ra - rb;
        });
    }
    // 'priority' keeps original order

    // Optional limit
    if (typeof params.limit === "number" && params.limit >= 0) {
        return eligible.slice(0, params.limit);
    }
    return eligible;
}
```

---
#### 13


` File: src/core/index.ts`  [↑ Back to top](#index)

```ts
export * from "./normalise";
export * from "./validate";
export * from "./builder";
export * from "./fallback";
export * from "./rate-coherence";
```

---
#### 14


` File: src/core/normalise.ts`  [↑ Back to top](#index)

```ts
// src/core/normalise.ts

import type {
    ServiceProps,
    Tag,
    Field,
    FieldOption,
    PricingRole,
    ServiceFallback,
    ServiceIdRef,
} from "@/schema";

export type NormaliseOptions = {
    /** default pricing role for fields/options when missing */
    defaultPricingRole?: PricingRole; // default: 'base'
};

export function normalise(
    input: unknown,
    opts: NormaliseOptions = {},
): ServiceProps {
    const defRole: PricingRole = opts.defaultPricingRole ?? "base";
    const obj = toObject(input);

    // ── Canonical top-level keys only
    const rawFilters = Array.isArray((obj as any).filters)
        ? (obj as any).filters
        : [];
    const rawFields = Array.isArray((obj as any).fields)
        ? (obj as any).fields
        : [];

    const includes_for_buttons = toStringArrayMap(
        (obj as any).includes_for_buttons,
    );
    const excludes_for_buttons = toStringArrayMap(
        (obj as any).excludes_for_buttons,
    );

    // Tags & fields
    let filters: Tag[] = rawFilters.map(coerceTag);
    const fields: Field[] = rawFields.map((f: any) => coerceField(f, defRole));

    // ── Ensure a root tag exists (id: 't:root')
    if (!filters.some((t) => t.id === "t:root")) {
        filters = [{ id: "t:root", label: "Root" }, ...filters];
    }

    // Canonical fallbacks only
    const fallbacks = coerceFallbacks((obj as any).fallbacks);

    const out: ServiceProps = {
        filters,
        fields,
        ...(isNonEmpty(includes_for_buttons) && { includes_for_buttons }),
        ...(isNonEmpty(excludes_for_buttons) && { excludes_for_buttons }),
        ...(fallbacks &&
            (isNonEmpty(fallbacks.nodes) || isNonEmpty(fallbacks.global)) && {
                fallbacks,
            }),
        schema_version:
            typeof (obj as any).schema_version === "string"
                ? (obj as any).schema_version
                : "1.0",
    };

    propagateConstraints(out);
    return out;
}

/* ───────────────────────── Constraint propagation ───────────────────────── */

const FLAG_KEYS = ["refill", "cancel", "dripfeed"] as const;
type FlagKey = (typeof FLAG_KEYS)[number];

/**
 * Propagate constraint flags down the tag tree:
 * - Any flag defined on an ancestor overrides the child's local value.
 * - Writes back the effective value to each tag.constraints.
 * - Records provenance in tag.constraints_origin[flag] = <originTagId>.
 * - Records child overrides in tag.constraints_overrides[flag] = { from, to, origin }.
 *
 * IMPORTANT: Children inherit the **effective** value from their parent,
 * not the parent's raw local. This ensures overridden values keep propagating.
 */
function propagateConstraints(props: ServiceProps): void {
    const tags = Array.isArray(props.filters) ? props.filters : [];
    if (!tags.length) return;

    const byId = new Map(tags.map((t) => [t.id, t]));
    const children = new Map<string, Tag[]>();

    for (const t of tags) {
        const pid = t.bind_id;
        if (!pid || !byId.has(pid)) continue;
        if (!children.has(pid)) children.set(pid, []);
        children.get(pid)!.push(t);
    }

    const roots = tags.filter((t) => !t.bind_id || !byId.has(t.bind_id));
    const starts = roots.length ? roots : tags;

    type Inherited = Partial<Record<FlagKey, { val: boolean; origin: string }>>;
    const visited = new Set<string>();

    const visit = (tag: Tag, inherited: Inherited) => {
        if (visited.has(tag.id)) return;
        visited.add(tag.id);

        const local = tag.constraints ?? {};
        const next: Partial<Record<FlagKey, boolean>> = {};
        const origin: Partial<Record<FlagKey, string>> = {};
        const overrides: NonNullable<Tag["constraints_overrides"]> = {};

        for (const k of FLAG_KEYS) {
            const inh = inherited[k];
            const prev = local[k];

            if (inh) {
                if (prev === undefined) {
                    next[k] = inh.val;
                    origin[k] = inh.origin;
                } else if (prev === inh.val) {
                    next[k] = inh.val;
                    origin[k] = tag.id;
                } else {
                    next[k] = inh.val;
                    origin[k] = inh.origin;
                    overrides[k] = {
                        from: prev as boolean,
                        to: inh.val,
                        origin: inh.origin,
                    };
                }
            } else if (prev !== undefined) {
                next[k] = prev as boolean;
                origin[k] = tag.id;
            }
        }

        // Persist only defined keys (keep JSON lean)
        const definedConstraints: Partial<Record<FlagKey, boolean>> = {};
        const definedOrigin: Partial<Record<FlagKey, string>> = {};
        const definedOverrides: NonNullable<Tag["constraints_overrides"]> = {};

        for (const k of FLAG_KEYS) {
            if (next[k] !== undefined)
                definedConstraints[k] = next[k] as boolean;
            if (origin[k] !== undefined) definedOrigin[k] = origin[k] as string;
            if (overrides[k] !== undefined) definedOverrides[k] = overrides[k]!;
        }

        tag.constraints = Object.keys(definedConstraints).length
            ? definedConstraints
            : undefined;
        tag.constraints_origin = Object.keys(definedOrigin).length
            ? definedOrigin
            : undefined;
        tag.constraints_overrides = Object.keys(definedOverrides).length
            ? definedOverrides
            : undefined;

        // Children inherit effective values + nearest origin
        const passDown: Inherited = { ...inherited };
        for (const k of FLAG_KEYS) {
            if (next[k] !== undefined && origin[k] !== undefined) {
                passDown[k] = { val: next[k] as boolean, origin: origin[k]! };
            }
        }
        for (const c of children.get(tag.id) ?? []) visit(c, passDown);
    };

    for (const r of starts) visit(r, {});
}

/* ───────────────────────────── coercers ───────────────────────────── */

function coerceTag(src: any): Tag {
    if (!src || typeof src !== "object") src = {};
    const id = str(src.id);
    const label = str(src.label);
    const bind_id = str(src.bind_id) || undefined;
    const service_id = toNumberOrUndefined(src.service_id);

    const includes = toStringArray(src.includes);
    const excludes = toStringArray(src.excludes);

    const constraints =
        src.constraints && typeof src.constraints === "object"
            ? {
                  refill: bool((src.constraints as any).refill),
                  cancel: bool((src.constraints as any).cancel),
                  dripfeed: bool((src.constraints as any).dripfeed),
              }
            : undefined;

    const meta =
        src.meta && typeof src.meta === "object"
            ? (src.meta as Record<string, unknown>)
            : undefined;

    const tag: Tag = {
        id: "",
        label: "",
        ...(id && { id }),
        ...(label && { label }),
        ...(bind_id && { bind_id }),
        ...(service_id !== undefined && { service_id }),
        ...(constraints && { constraints }),
        ...(includes.length && { includes: dedupe(includes) }),
        ...(excludes.length && { excludes: dedupe(excludes) }),
        ...(meta && { meta }),
    };
    return tag;
}
function coerceField(src: any, defRole: PricingRole): Field {
    if (!src || typeof src !== "object") src = {};

    const bind_id = normaliseBindId(src.bind_id);
    const type = str(src.type) || "text";
    const id = str(src.id);
    const name = typeof src.name === "string" ? src.name : undefined;

    // BaseFieldUI (trimmed)
    const label = str(src.label) || "";
    const required = !!src.required;

    // host-defined UI schema + defaults (pass-through if objects)
    const ui =
        src.ui && typeof src.ui === "object"
            ? (src.ui as Record<string, unknown>)
            : undefined;
    const defaults =
        src.defaults && typeof src.defaults === "object"
            ? (src.defaults as Record<string, unknown>)
            : undefined;

    // field-level role (used as default for options)
    const pricing_role: PricingRole =
        src.pricing_role === "utility" || src.pricing_role === "base"
            ? src.pricing_role
            : defRole;

    // options
    const srcHasOptions = Array.isArray(src.options) && src.options.length > 0;
    const options = srcHasOptions
        ? (src.options as any[]).map((o) => coerceOption(o, pricing_role))
        : undefined;

    // custom component (only for type === 'custom')
    const component =
        type === "custom" ? str(src.component) || undefined : undefined;

    // meta (pass-through)
    const meta =
        src.meta && typeof src.meta === "object"
            ? { ...(src.meta as any) }
            : undefined;

    // button rule:
    // - option-based fields are always buttons
    // - otherwise, respect explicit boolean true
    const button: boolean = srcHasOptions ? true : src.button === true;

    // field-level service_id is allowed only for *buttons* with base role
    const field_service_id_raw = toNumberOrUndefined(src.service_id);
    const field_service_id =
        button &&
        pricing_role !== "utility" &&
        field_service_id_raw !== undefined
            ? field_service_id_raw
            : undefined;

    const field: Field = {
        id,
        type,
        ...(bind_id !== undefined && { bind_id }),
        ...(name && { name }),
        ...(options && options.length && { options }),
        ...(component && { component }),
        pricing_role,
        label,
        required,
        ...(ui && { ui: ui as any }),
        ...(defaults && { defaults }),
        ...(meta && { meta }),
        ...(button ? { button } : {}),
        ...(field_service_id !== undefined && { service_id: field_service_id }),
    };

    return field;
}

function coerceOption(src: any, inheritRole: PricingRole): FieldOption {
    if (!src || typeof src !== "object") src = {};
    const id = str(src.id);
    const label = str(src.label);
    const service_id = toNumberOrUndefined(src.service_id);
    const value =
        typeof src.value === "string" || typeof src.value === "number"
            ? (src.value as string | number)
            : undefined;

    const pricing_role: PricingRole =
        src.pricing_role === "utility" || src.pricing_role === "base"
            ? src.pricing_role
            : inheritRole;

    const meta =
        src.meta && typeof src.meta === "object"
            ? (src.meta as Record<string, unknown>)
            : undefined;

    const option: FieldOption = {
        id: "",
        label: "",
        ...(id && { id }),
        ...(label && { label }),
        ...(value !== undefined && { value }),
        ...(service_id !== undefined && { service_id }),
        pricing_role,
        ...(meta && { meta }),
    };
    return option;
}

/* ───────────────────────── fallbacks (canonical only) ───────────────────────── */

function coerceFallbacks(src: any): ServiceFallback | undefined {
    if (!src || typeof src !== "object") return undefined;

    const out: ServiceFallback = {};
    const g = (src as any).global;
    const n = (src as any).nodes;

    if (g && typeof g === "object") {
        const rg: Record<string, ServiceIdRef[]> = {};
        for (const [k, v] of Object.entries(g)) {
            const key = String(k);
            const arr = toServiceIdArray(v);
            const clean = dedupe(arr.filter((x) => String(x) !== key));
            if (clean.length) rg[key] = clean;
        }
        if (Object.keys(rg).length) out.global = rg;
    }

    if (n && typeof n === "object") {
        const rn: Record<string, ServiceIdRef[]> = {};
        for (const [nodeId, v] of Object.entries(n)) {
            const key = String(nodeId);
            const arr = toServiceIdArray(v);
            const clean = dedupe(arr.filter((x) => String(x) !== key));
            if (clean.length) rn[key] = clean;
        }
        if (Object.keys(rn).length) out.nodes = rn;
    }

    return out.nodes || out.global ? out : undefined;
}

/* ───────────────────────── utilities ───────────────────────── */

function toObject(input: unknown): Record<string, unknown> {
    if (input && typeof input === "object")
        return input as Record<string, unknown>;
    throw new TypeError("normalise(): expected an object payload");
}

function normaliseBindId(bind: unknown): string | string[] | undefined {
    if (typeof bind === "string" && bind.trim()) return bind.trim();
    if (Array.isArray(bind)) {
        const arr = dedupe(bind.map((b) => String(b).trim()).filter(Boolean));
        if (arr.length === 0) return undefined;
        if (arr.length === 1) return arr[0];
        return arr;
    }
    return undefined;
}

function toStringArrayMap(src: any): Record<string, string[]> | undefined {
    if (!src || typeof src !== "object") return undefined;
    const out: Record<string, string[]> = {};
    for (const [k, v] of Object.entries(src)) {
        if (!k) continue;
        const arr = toStringArray(v);
        if (arr.length) out[k] = dedupe(arr);
    }
    return Object.keys(out).length ? out : undefined;
}

function toStringArray(v: any): string[] {
    if (!Array.isArray(v)) return [];
    return v.map((x) => String(x)).filter((s) => !!s && s.trim().length > 0);
}

function toNumberOrUndefined(v: any): number | undefined {
    if (v === null || v === undefined) return undefined;
    const n = Number(v);
    return Number.isFinite(n) ? n : undefined;
}

function str(v: any): string | undefined {
    if (typeof v === "string" && v.trim().length > 0) return v.trim();
    return undefined;
}

function bool(v: any): boolean | undefined {
    if (v === undefined) return undefined;
    return !!v;
}

function dedupe<T>(arr: T[]): T[] {
    return Array.from(new Set(arr));
}

function isNonEmpty<T extends Record<string, any> | undefined>(
    obj: T,
): obj is NonNullable<T> {
    return !!obj && Object.keys(obj).length > 0;
}

function toServiceIdArray(v: any): ServiceIdRef[] {
    if (!Array.isArray(v)) return [];
    return v
        .map((x) =>
            typeof x === "number" || typeof x === "string" ? x : String(x),
        )
        .filter(
            (x) => x !== "" && x !== null && x !== undefined,
        ) as ServiceIdRef[];
}
```

---
#### 15


` File: src/core/policy.ts`  [↑ Back to top](#index)

```ts
// src/core/policy.ts
import type { DynamicRule, ValidatorOptions } from "@/schema/validation";

export type PolicyDiagnostic = {
    ruleIndex: number;
    ruleId?: string;
    severity: "error" | "warning";
    message: string;
    path?: string; // e.g. "filter.role", "op"
};

const ALLOWED_SCOPES = new Set<DynamicRule["scope"]>([
    "global",
    "visible_group",
]);
const ALLOWED_SUBJECTS = new Set<DynamicRule["subject"]>(["services"]);
const ALLOWED_OPS = new Set<DynamicRule["op"]>([
    "all_equal",
    "unique",
    "no_mix",
    "all_true",
    "any_true",
    "max_count",
    "min_count",
]);
const ALLOWED_ROLES = new Set<NonNullable<DynamicRule["filter"]>["role"]>([
    "base",
    "utility",
    "both",
]);
const ALLOWED_SEVERITIES = new Set<NonNullable<DynamicRule["severity"]>>([
    "error",
    "warning",
]);

const ALLOWED_WHERE_OPS = new Set<
    NonNullable<NonNullable<DynamicRule["filter"]>["where"]>[number]["op"]
>(["eq", "neq", "in", "nin", "exists", "truthy", "falsy"]);

type WhereClause = NonNullable<
    NonNullable<DynamicRule["filter"]>["where"]
>[number];

function normaliseWhere(
    src: unknown,
    d: PolicyDiagnostic[],
    i: number,
    id: string,
): WhereClause[] | undefined {
    if (src === undefined) return undefined;
    if (!Array.isArray(src)) {
        d.push({
            ruleIndex: i,
            ruleId: id,
            severity: "warning",
            message: "filter.where must be an array; ignored.",
            path: "filter.where",
        });
        return undefined;
    }

    const out: WhereClause[] = [];

    src.forEach((raw, j) => {
        const obj: any = raw && typeof raw === "object" ? raw : null;
        const path: string | undefined =
            typeof obj?.path === "string" && obj.path.trim()
                ? obj.path.trim()
                : undefined;

        if (!path) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: `filter.where[${j}].path must be a non-empty string; entry ignored.`,
                path: `filter.where[${j}].path`,
            });
            return;
        }

        if (!path.startsWith("service.")) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: `filter.where[${j}].path should start with "service." for subject "services".`,
                path: `filter.where[${j}].path`,
            });
        }

        const opRaw: unknown = obj?.op;
        const op: WhereClause["op"] =
            opRaw === undefined
                ? "eq"
                : typeof opRaw === "string" &&
                    ALLOWED_WHERE_OPS.has(opRaw as any)
                  ? (opRaw as any)
                  : "eq";

        if (
            opRaw !== undefined &&
            !(typeof opRaw === "string" && ALLOWED_WHERE_OPS.has(opRaw as any))
        ) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: `Unknown filter.where[${j}].op; defaulted to "eq".`,
                path: `filter.where[${j}].op`,
            });
        }

        const value: unknown = obj?.value;

        // validate value requirements lightly (non-fatal)
        if (op === "exists" || op === "truthy" || op === "falsy") {
            if (value !== undefined) {
                d.push({
                    ruleIndex: i,
                    ruleId: id,
                    severity: "warning",
                    message: `filter.where[${j}] op "${op}" does not use "value".`,
                    path: `filter.where[${j}].value`,
                });
            }
        } else if (op === "in" || op === "nin") {
            if (!Array.isArray(value)) {
                d.push({
                    ruleIndex: i,
                    ruleId: id,
                    severity: "warning",
                    message: `filter.where[${j}] op "${op}" expects an array "value".`,
                    path: `filter.where[${j}].value`,
                });
            }
        }

        out.push({ path, op, value });
    });

    return out.length ? out : undefined;
}

/**
 * Compile & validate arbitrary JSON into DynamicRule[] with defaults:
 * - scope: (default) "visible_group"
 * - subject: (default) "services"
 * - filter.role: (default) "both"
 * - severity: (default) "error"
 * - projection: (default) "service.id"
 *
 * Returns normalized rules + diagnostics (errors/warnings).
 */
export function compilePolicies(raw: unknown): {
    policies: DynamicRule[];
    diagnostics: PolicyDiagnostic[];
} {
    const diagnostics: PolicyDiagnostic[] = [];
    const policies: DynamicRule[] = [];

    if (!Array.isArray(raw)) {
        diagnostics.push({
            ruleIndex: -1,
            severity: "error",
            message: "Policies root must be an array.",
        });
        return { policies, diagnostics };
    }

    raw.forEach((entry, i) => {
        const d: PolicyDiagnostic[] = [];
        const src = entry && typeof entry === "object" ? (entry as any) : {};

        let id: string | undefined =
            typeof src.id === "string" && src.id.trim()
                ? src.id.trim()
                : undefined;

        // id default
        if (!id) {
            id = `policy_${i + 1}`;
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Missing "id"; generated automatically.',
                path: "id",
            });
        }

        // ✅ label: required by DynamicRule; default to id
        const label: string =
            typeof src.label === "string" && src.label.trim()
                ? src.label.trim()
                : id;

        if (!(typeof src.label === "string" && src.label.trim())) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Missing "label"; defaulted to rule id.',
                path: "label",
            });
        }

        // scope default + validation
        let scope: DynamicRule["scope"] = ALLOWED_SCOPES.has(src.scope)
            ? src.scope
            : src.scope === undefined
              ? "visible_group"
              : "visible_group";
        if (src.scope !== undefined && !ALLOWED_SCOPES.has(src.scope)) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Unknown "scope"; defaulted to "visible_group".',
                path: "scope",
            });
        }

        // subject default + validation
        let subject: DynamicRule["subject"] = ALLOWED_SUBJECTS.has(src.subject)
            ? src.subject
            : "services";
        if (src.subject !== undefined && !ALLOWED_SUBJECTS.has(src.subject)) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Unknown "subject"; defaulted to "services".',
                path: "subject",
            });
        }

        // op required & valid
        const op: DynamicRule["op"] = src.op;
        if (!ALLOWED_OPS.has(op)) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "error",
                message: `Invalid "op": ${String(op)}.`,
                path: "op",
            });
        }

        // projection default
        let projection: string | undefined =
            typeof src.projection === "string" && src.projection.trim()
                ? src.projection.trim()
                : "service.id";

        // For services subject, encourage service.* projection
        if (
            subject === "services" &&
            projection &&
            !projection.startsWith("service.")
        ) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message:
                    'Projection should start with "service." for subject "services".',
                path: "projection",
            });
        }

        const filterSrc =
            src.filter && typeof src.filter === "object"
                ? (src.filter as DynamicRule["filter"])
                : undefined;

        const role: NonNullable<DynamicRule["filter"]>["role"] =
            filterSrc?.role && ALLOWED_ROLES.has(filterSrc.role)
                ? filterSrc.role
                : "both";

        if (filterSrc?.role && !ALLOWED_ROLES.has(filterSrc.role)) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Unknown filter.role; defaulted to "both".',
                path: "filter.role",
            });
        }

        const filter: DynamicRule["filter"] | undefined = {
            role,
            tag_id:
                filterSrc?.tag_id !== undefined
                    ? Array.isArray(filterSrc.tag_id)
                        ? filterSrc.tag_id
                        : [filterSrc.tag_id]
                    : undefined,
            field_id:
                filterSrc?.field_id !== undefined
                    ? Array.isArray(filterSrc.field_id)
                        ? filterSrc.field_id
                        : [filterSrc.field_id]
                    : undefined,
            where: normaliseWhere((filterSrc as any)?.where, d, i, id),
        };

        // severity default
        const severity: NonNullable<DynamicRule["severity"]> =
            ALLOWED_SEVERITIES.has(src.severity) ? src.severity : "error";
        if (
            src.severity !== undefined &&
            !ALLOWED_SEVERITIES.has(src.severity)
        ) {
            d.push({
                ruleIndex: i,
                ruleId: id,
                severity: "warning",
                message: 'Unknown "severity"; defaulted to "error".',
                path: "severity",
            });
        }

        // value requirements by op
        const value = src.value;
        if (op === "max_count" || op === "min_count") {
            if (!(typeof value === "number" && Number.isFinite(value))) {
                d.push({
                    ruleIndex: i,
                    ruleId: id,
                    severity: "error",
                    message: `"${op}" requires numeric "value".`,
                    path: "value",
                });
            }
        } else if (op === "all_true" || op === "any_true") {
            if (value !== undefined) {
                d.push({
                    ruleIndex: i,
                    ruleId: id,
                    severity: "warning",
                    message: `"${op}" ignores "value"; it checks all/any true.`,
                    path: "value",
                });
            }
        } else {
            if (value !== undefined) {
                d.push({
                    ruleIndex: i,
                    ruleId: id,
                    severity: "warning",
                    message: `"${op}" does not use "value".`,
                    path: "value",
                });
            }
        }

        // assemble rule if no fatal (error-level) diagnostics for op/value
        const hasFatal = d.some((x) => x.severity === "error");
        if (!hasFatal) {
            const rule: DynamicRule = {
                id,
                label, // ✅ now always present
                scope,
                subject,
                filter,
                projection,
                op,
                value: value as any,
                severity,
                message:
                    typeof src.message === "string" ? src.message : undefined,
            };
            policies.push(rule);
        }

        diagnostics.push(...d);
    });

    return { policies, diagnostics };
}

/** Split diagnostics for convenience in UI */
export function splitPolicyDiagnostics(diags: PolicyDiagnostic[]): {
    errors: PolicyDiagnostic[];
    warnings: PolicyDiagnostic[];
} {
    return {
        errors: diags.filter((d) => d.severity === "error"),
        warnings: diags.filter((d) => d.severity === "warning"),
    };
}

/**
 * Convenience helper: compile policies and pass to validator options.
 * You can use this in your editor before calling validate().
 */
export function withCompiledPolicies(
    opts: ValidatorOptions,
    rawPolicies: unknown,
): { opts: ValidatorOptions; diagnostics: PolicyDiagnostic[] } {
    const { policies, diagnostics } = compilePolicies(rawPolicies);
    return { opts: { ...opts, policies }, diagnostics };
}
```

---
#### 16


` File: src/core/rate-coherence.ts`  [↑ Back to top](#index)

```ts
import { RatePolicy } from "@/schema/validation";
import { Builder } from "./builder";
import { DgpServiceCapability, DgpServiceMap } from "@/schema/provider";
import { Field, PricingRole, ServiceProps, Tag } from "@/schema";

type BaseCandidate = {
    kind: "field" | "option";
    id: string;
    label?: string;
    service_id: number;
    rate: number;
};

/** Result for each violation discovered during deep simulation. */
export type RateCoherenceDiagnostic = {
    scope: "visible_group";
    tagId: string;
    /** The “primary” used for comparison in this simulation:
     *  anchor service if present; otherwise, the first base service among simulated candidates.
     *  (Tag service is never used as primary.)
     */
    primary: BaseCandidate;
    /** The item that violated the policy against the primary. */
    offender: {
        kind: "field" | "option";
        id: string;
        label?: string;
        service_id: number;
        rate: number;
    };
    policy: RatePolicy["kind"];
    policyPct?: number; // for within_pct / at_least_pct_lower
    message: string;
    /** Which button triggered this simulation */
    simulationAnchor: {
        kind: "field" | "option";
        id: string;
        fieldId: string;
        label?: string;
    };
};

/** Run deep rate-coherence validation by simulating each button selection in the active tag. */
export function validateRateCoherenceDeep(params: {
    builder: Builder;
    services: DgpServiceMap;
    tagId: string;
    /** Optional rate policy (defaults to { kind: 'lte_primary' }) */
    ratePolicy?: RatePolicy;
}): RateCoherenceDiagnostic[] {
    const { builder, services, tagId } = params;
    const ratePolicy: RatePolicy = params.ratePolicy ?? { kind: "lte_primary" };
    const props = builder.getProps() as ServiceProps;

    // Indexes
    const fields = props.fields ?? [];
    const fieldById = new Map(fields.map((f) => [f.id, f]));
    const tagById = new Map((props.filters ?? []).map((t) => [t.id, t]));
    const tag: Tag | undefined = tagById.get(tagId);

    // Baseline visible fields (no selection)
    const baselineFieldIds = builder.visibleFields(tagId, []);
    const baselineFields = baselineFieldIds
        .map((fid) => fieldById.get(fid))
        .filter(Boolean) as Field[];

    // Build the list of *simulation anchors* = every button in the baseline group
    const anchors: Array<{
        kind: "field" | "option";
        id: string;
        fieldId: string;
        label?: string;
        service_id?: number;
    }> = [];

    for (const f of baselineFields) {
        if (!isButton(f)) continue;

        if (Array.isArray(f.options) && f.options.length) {
            // Option buttons → every option becomes an anchor (even if it has no base service)
            for (const o of f.options) {
                anchors.push({
                    kind: "option",
                    id: o.id,
                    fieldId: f.id,
                    label: o.label ?? o.id,
                    service_id: numberOrUndefined((o as any).service_id),
                });
            }
        } else {
            // Non-option button → the field itself is an anchor (even if it has no base service)
            anchors.push({
                kind: "field",
                id: f.id,
                fieldId: f.id,
                label: f.label ?? f.id,
                service_id: numberOrUndefined((f as any).service_id),
            });
        }
    }

    const diags: RateCoherenceDiagnostic[] = [];
    const seen = new Set<string>(); // dedupe across simulations

    for (const anchor of anchors) {
        // Build the simulated “selected keys” (how includes_for_buttons is addressed)
        const selectedKeys =
            anchor.kind === "option"
                ? [`${anchor.fieldId}::${anchor.id}`]
                : [anchor.fieldId];

        // Recompute the visible group under this simulation
        const vgFieldIds = builder.visibleFields(tagId, selectedKeys);
        const vgFields = vgFieldIds
            .map((fid) => fieldById.get(fid))
            .filter(Boolean) as Field[];

        // Collect base service candidates in this simulated group
        const baseCandidates: Array<BaseCandidate> = [];

        for (const f of vgFields) {
            if (!isButton(f)) continue;

            if (Array.isArray(f.options) && f.options.length) {
                for (const o of f.options) {
                    const sid = numberOrUndefined((o as any).service_id);
                    const role = normalizeRole(o.pricing_role, "base");
                    if (sid == null || role !== "base") continue;
                    const r = rateOf(services, sid);
                    if (!isFiniteNumber(r)) continue;
                    baseCandidates.push({
                        kind: "option",
                        id: o.id,
                        label: o.label ?? o.id,
                        service_id: sid,
                        rate: r!,
                    });
                }
            } else {
                const sid = numberOrUndefined((f as any).service_id);
                const role = normalizeRole((f as any).pricing_role, "base");
                if (sid == null || role !== "base") continue;
                const r = rateOf(services, sid);
                if (!isFiniteNumber(r)) continue;
                baseCandidates.push({
                    kind: "field",
                    id: f.id,
                    label: f.label ?? f.id,
                    service_id: sid,
                    rate: r!,
                });
            }
        }

        if (baseCandidates.length === 0) continue;

        // Choose the “primary” for this simulation:
        // 1) Anchor’s base service (if present),
        // 2) else first base candidate (deterministic).
        const anchorPrimary =
            anchor.service_id != null
                ? pickByServiceId(baseCandidates, anchor.service_id)
                : undefined;

        const primary = anchorPrimary ? anchorPrimary : baseCandidates[0]!;

        // Compare every *other* candidate against the primary using the configured policy
        for (const cand of baseCandidates) {
            if (sameService(primary, cand)) continue;

            if (!rateOkWithPolicy(ratePolicy, cand.rate, primary.rate)) {
                const key = dedupeKey(tagId, anchor, primary, cand, ratePolicy);
                if (seen.has(key)) continue;
                seen.add(key);

                diags.push({
                    scope: "visible_group",
                    tagId,
                    primary,
                    offender: {
                        kind: cand.kind,
                        id: cand.id,
                        label: cand.label,
                        service_id: cand.service_id,
                        rate: cand.rate,
                    },
                    policy: ratePolicy.kind,
                    policyPct: "pct" in ratePolicy ? ratePolicy.pct : undefined,
                    message: explainRateMismatch(
                        ratePolicy,
                        primary.rate,
                        cand.rate,
                        describeLabel(tag),
                    ),
                    simulationAnchor: {
                        kind: anchor.kind,
                        id: anchor.id,
                        fieldId: anchor.fieldId,
                        label: anchor.label,
                    },
                });
            }
        }
    }

    return diags;
}

/* ───────────────────────── helpers ───────────────────────── */

function isButton(f: Field): boolean {
    // Buttons = explicit flag OR any option-based field
    if ((f as any).button === true) return true;
    return Array.isArray(f.options) && f.options.length > 0;
}

function normalizeRole(
    role: PricingRole | undefined,
    d: PricingRole,
): PricingRole {
    return role === "utility" || role === "base" ? role : d;
}

function numberOrUndefined(v: unknown): number | undefined {
    const n = Number(v);
    return Number.isFinite(n) ? n : undefined;
}

function isFiniteNumber(v: unknown): v is number {
    return typeof v === "number" && Number.isFinite(v);
}

function rateOf(
    map: DgpServiceMap,
    id: number | string | undefined,
): number | undefined {
    if (id === undefined || id === null) return undefined;
    const cap: DgpServiceCapability | undefined =
        map[Number(id)] ?? (map as any)[id];
    return cap?.rate;
}

function pickByServiceId<T extends BaseCandidate>(
    arr: T[],
    sid: number,
): T | undefined {
    return arr.find((x) => x.service_id === sid);
}

function sameService(a: { service_id: number }, b: { service_id: number }) {
    return a.service_id === b.service_id;
}

function rateOkWithPolicy(
    policy: RatePolicy,
    candRate: number,
    primaryRate: number,
): boolean {
    const rp = policy ?? { kind: "lte_primary" as const };
    switch (rp.kind) {
        case "lte_primary":
            return candRate <= primaryRate;
        case "within_pct": {
            const pct = Math.max(0, rp.pct ?? 0);
            return candRate <= primaryRate * (1 + pct / 100);
        }
        case "at_least_pct_lower": {
            const pct = Math.max(0, rp.pct ?? 0);
            return candRate <= primaryRate * (1 - pct / 100);
        }
        default:
            return candRate <= primaryRate;
    }
}

function describeLabel(tag?: Tag): string {
    const tagName = tag?.label ?? tag?.id ?? "tag";
    return `${tagName}`;
}

function explainRateMismatch(
    policy: RatePolicy,
    primary: number,
    candidate: number,
    where: string,
): string {
    switch (policy.kind) {
        case "lte_primary":
            return `Rate coherence failed (${where}): candidate ${candidate} must be ≤ primary ${primary}.`;
        case "within_pct":
            return `Rate coherence failed (${where}): candidate ${candidate} must be within ${policy.pct}% of primary ${primary}.`;
        case "at_least_pct_lower":
            return `Rate coherence failed (${where}): candidate ${candidate} must be at least ${policy.pct}% lower than primary ${primary}.`;
        default:
            return `Rate coherence failed (${where}): candidate ${candidate} mismatches primary ${primary}.`;
    }
}

function dedupeKey(
    tagId: string,
    anchor: { kind: "field" | "option"; id: string },
    primary: { service_id: number },
    cand: { service_id: number; id: string },
    rp: RatePolicy,
) {
    const rpKey =
        rp.kind +
        ("pct" in rp && typeof rp.pct === "number" ? `:${rp.pct}` : "");
    return `${tagId}|${anchor.kind}:${anchor.id}|p${primary.service_id}|c${cand.service_id}:${cand.id}|${rpKey}`;
}
```

---
#### 17


` File: src/core/validate.ts`  [↑ Back to top](#index)

```ts
// src/core/validate.ts
export { validate } from "./validate/index";
```

---
#### 18


` File: src/core/validate/index.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/index.ts
import type { ServiceProps, Tag, Field } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";
import type { ValidationError, ValidatorOptions } from "@/schema/validation";

import {
    createFieldsVisibleUnder,
    validateVisibility,
} from "./steps/visibility";
import { validateStructure } from "./steps/structure";
import { validateIdentity } from "./steps/identity";
import { validateOptionMaps } from "./steps/option-maps";
import { validateServiceVsUserInput } from "./steps/service-vs-input";
import { validateUtilityMarkers } from "./steps/utility";
import { validateRates } from "./steps/rates";
import { validateConstraints } from "./steps/constraints";
import { validateCustomFields } from "./steps/custom";
import { validateGlobalUtilityGuard } from "./steps/global-utility-guard";
import { validateUnboundFields } from "./steps/unbound";
import { validateFallbacks } from "./steps/fallbacks";

import { applyPolicies } from "./policies/apply-policies";
import type { ValidationCtx } from "./shared";

export function validate(
    props: ServiceProps,
    ctx: ValidatorOptions = {},
): ValidationError[] {
    const errors: ValidationError[] = [];
    const serviceMap: DgpServiceMap = ctx.serviceMap ?? {};
    const selectedKeys: Set<string> = new Set<string>(
        ctx.selectedOptionKeys ?? [],
    );

    const tags: Tag[] = Array.isArray(props.filters) ? props.filters : [];
    const fields: Field[] = Array.isArray(props.fields) ? props.fields : [];

    const tagById: Map<string, Tag> = new Map<string, Tag>();
    const fieldById: Map<string, Field> = new Map<string, Field>();

    for (const t of tags) tagById.set(t.id, t);
    for (const f of fields) fieldById.set(f.id, f);

    const v: ValidationCtx = {
        props,
        options: ctx,
        errors,
        serviceMap,
        selectedKeys,
        tags,
        fields,
        tagById,
        fieldById,
        fieldsVisibleUnder: (_tagId: string): Field[] => [],
    };

    // 1) structure
    validateStructure(v);

    // 2) identity + labels
    validateIdentity(v);

    // 3) option maps
    validateOptionMaps(v);

    // 4) visibility helpers + visibility rules
    v.fieldsVisibleUnder = createFieldsVisibleUnder(v);
    validateVisibility(v);

    // --------- Dynamic policies (super-admin) --------------------------
    applyPolicies(
        v.errors,
        v.props,
        v.serviceMap,
        v.options.policies,
        v.fieldsVisibleUnder,
        v.tags,
    );

    // 5) service vs user-input rules
    validateServiceVsUserInput(v);

    // 6) utility marker rules
    validateUtilityMarkers(v);

    // 7) rates & pricing roles
    validateRates(v);

    // 8) constraints vs capabilities + inheritance
    validateConstraints(v);

    // 9) custom field rules
    validateCustomFields(v);

    // 10) optional global utility guard
    validateGlobalUtilityGuard(v);

    // 11) unbound fields
    validateUnboundFields(v);

    // 12) fallbacks strict-mode conversion
    validateFallbacks(v);

    return v.errors;
}
```

---
#### 19


` File: src/core/validate/policies/apply-policies.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/policies/apply-policies.ts
import type { ServiceProps, Tag, Field } from "@/schema";
import type { DgpServiceMap, IdType } from "@/schema/provider";
import type { DynamicRule, ValidationError } from "@/schema/validation";

import { getByPath } from "../shared";
import { collectServiceItems, type ServiceItem } from "./collect-service-items";
import { evalPolicyOp } from "./ops";

function uniq<T>(arr: readonly T[]): T[] {
    return Array.from(new Set<T>(arr));
}

function stableSeverity(
    s: DynamicRule["severity"] | undefined,
): "error" | "warning" | "info" {
    if (s === "warning") return "warning";
    if (s === "error") return "error";
    return "error";
}

function defaultPolicyMessage(rule: DynamicRule): string {
    if (typeof rule.message === "string" && rule.message.trim())
        return rule.message;
    if (typeof rule.label === "string" && rule.label.trim())
        return rule.label.trim();
    return `Policy "${rule.id}" violated`;
}

function affectedFromItems(items: readonly ServiceItem[]): string[] {
    const ids: string[] = [];
    for (const it of items) {
        for (const x of it.affectedIds ?? []) ids.push(x);
        ids.push(`service:${String(it.serviceId)}`);
    }
    return uniq(ids);
}

function visibleGroupNodeIds(tag: Tag, fields: readonly Field[]): string[] {
    const ids: string[] = [tag.id];

    for (const f of fields) {
        for (const o of f.options ?? []) {
            ids.push(o.id);
        }
    }

    return uniq(ids);
}

function visibleGroupPrimaries(tag: Tag, fields: readonly Field[]): IdType[] {
    const prim: IdType[] = [];

    const tagSid: unknown = (tag as any).service_id;
    if (
        typeof tagSid === "string" ||
        (typeof tagSid === "number" && Number.isFinite(tagSid))
    ) {
        prim.push(tagSid);
    }

    for (const f of fields) {
        const fsid: unknown = (f as any).service_id;
        if (
            typeof fsid === "string" ||
            (typeof fsid === "number" && Number.isFinite(fsid))
        ) {
            prim.push(fsid);
        }

        for (const o of f.options ?? []) {
            const osid: unknown = (o as any).service_id;
            if (
                typeof osid === "string" ||
                (typeof osid === "number" && Number.isFinite(osid))
            ) {
                prim.push(osid);
            }
        }
    }

    return uniq(prim);
}

export function applyPolicies(
    errors: ValidationError[],
    props: ServiceProps,
    serviceMap: DgpServiceMap,
    policies: DynamicRule[] | undefined,
    fieldsVisibleUnder: (tagId: string) => Field[],
    tags: Tag[],
): void {
    if (!policies?.length) return;

    const tagById: Map<string, Tag> = new Map<string, Tag>();
    for (const t of tags) tagById.set(t.id, t);

    for (const rule of policies) {
        const projPath: string = rule.projection ?? "service.id";
        const severity: "error" | "warning" | "info" = stableSeverity(
            rule.severity,
        );
        const message: string = defaultPolicyMessage(rule);

        // ────────────────────────────────────────────────────────────────
        // GLOBAL: "all services - everywhere, anywhere"
        // - includes tags, fields (field.service_id + option.service_id), fallbacks (nodes + global)
        // - if rule.filter.tag_id is present, global becomes "union of those visible groups"
        //   (still strict within the selected universe)
        // ────────────────────────────────────────────────────────────────
        if (rule.scope === "global") {
            const tagAllow: readonly string[] | undefined = Array.isArray(
                rule.filter?.tag_id,
            )
                ? (rule.filter?.tag_id as string[])
                : rule.filter?.tag_id
                  ? [rule.filter.tag_id as string]
                  : undefined;

            let items: ServiceItem[] = [];

            if (tagAllow && tagAllow.length) {
                // Union of selected visible-groups (including tag itself + group fallbacks)
                const merged: Map<string, ServiceItem> = new Map<
                    string,
                    ServiceItem
                >();

                for (const id of tagAllow) {
                    const t: Tag | undefined = tagById.get(id);
                    if (!t) continue;

                    const visibleFields: Field[] = fieldsVisibleUnder(t.id);
                    const nodeIds: string[] = visibleGroupNodeIds(
                        t,
                        visibleFields,
                    );
                    const primaries: IdType[] = visibleGroupPrimaries(
                        t,
                        visibleFields,
                    );

                    const sub: ServiceItem[] = collectServiceItems({
                        mode: "visible_group",
                        props,
                        serviceMap,
                        tag: t,
                        tagId: t.id,
                        fields: visibleFields,
                        filter: rule.filter,
                        visibleNodeIds: nodeIds,
                        visiblePrimaries: primaries,
                    });

                    for (const it of sub) {
                        const k: string = `${String(it.serviceId)}|${it.role}`;
                        const existing: ServiceItem | undefined = merged.get(k);
                        if (!existing) {
                            merged.set(k, it);
                        } else {
                            merged.set(k, {
                                ...existing,
                                affectedIds: uniq([
                                    ...existing.affectedIds,
                                    ...it.affectedIds,
                                ]),
                            });
                        }
                    }
                }

                items = Array.from(merged.values());
            } else {
                // Truly everything, anywhere:
                const allFields: Field[] = props.fields ?? [];

                items = collectServiceItems({
                    mode: "global",
                    props,
                    serviceMap,
                    tags,
                    fields: allFields,
                    filter: rule.filter,
                });
            }

            const values: unknown[] = items.map((it) =>
                getByPath(it as any, projPath),
            );

            if (!evalPolicyOp(rule.op, values, rule)) {
                errors.push({
                    code: "policy_violation",
                    severity,
                    message,
                    nodeId: "global",
                    details: {
                        ruleId: rule.id,
                        scope: "global",
                        op: rule.op,
                        projection: projPath,
                        count: items.length,
                        affectedIds: affectedFromItems(items),
                    },
                });
            }

            continue;
        }

        // ────────────────────────────────────────────────────────────────
        // VISIBLE GROUP: "all current visible nodes under tagId including the tag"
        // + include node-scoped fallbacks for the tag + visible option ids
        // + include global fallbacks for primaries present in that group
        // ────────────────────────────────────────────────────────────────
        for (const t of tags) {
            const visibleFields: Field[] = fieldsVisibleUnder(t.id);

            const nodeIds: string[] = visibleGroupNodeIds(t, visibleFields);
            const primaries: IdType[] = visibleGroupPrimaries(t, visibleFields);

            const items: ServiceItem[] = collectServiceItems({
                mode: "visible_group",
                props,
                serviceMap,
                tag: t,
                tagId: t.id,
                fields: visibleFields,
                filter: rule.filter,
                visibleNodeIds: nodeIds,
                visiblePrimaries: primaries,
            });

            if (!items.length) continue;

            const values: unknown[] = items.map((it) =>
                getByPath(it as any, projPath),
            );

            if (!evalPolicyOp(rule.op, values, rule)) {
                errors.push({
                    code: "policy_violation",
                    severity,
                    message,
                    nodeId: t.id,
                    details: {
                        ruleId: rule.id,
                        scope: "visible_group",
                        op: rule.op,
                        projection: projPath,
                        count: items.length,
                        affectedIds: affectedFromItems(items),
                    },
                });
            }
        }
    }
}
```

---
#### 20


` File: src/core/validate/policies/collect-service-items.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/policies/collect-service-items.ts
import type { ServiceProps, Tag, Field } from "@/schema";
import type {
    DgpServiceCapability,
    DgpServiceMap,
    IdType,
} from "@/schema/provider";
import type { DynamicRule } from "@/schema/validation";

import { getByPath } from "../shared";

export type ServiceItem = Readonly<{
    /** Scope tag context (only meaningful for visible_group / tag-filtered global) */
    tagId?: string;

    /** Reference metadata (used for affectedIds + debugging) */
    fieldId?: string;
    optionId?: string;
    nodeId?: string;

    /** Canonical service id reference */
    serviceId: IdType;

    /** Pricing role context */
    role: "base" | "utility";

    /** Projection target (always present with at least { id }) */
    service: Record<string, unknown>;

    /** Aggregated affected ids (node/service refs that contributed to this item) */
    affectedIds: string[];
}>;

type WhereClause = NonNullable<
    NonNullable<DynamicRule["filter"]>["where"]
>[number];

type CollectMode = "global" | "visible_group";

export type CollectServiceItemsArgs = Readonly<{
    mode: CollectMode;

    props: ServiceProps;
    serviceMap: DgpServiceMap;

    /** For global: pass all tags, and usually props.fields */
    tags?: readonly Tag[];
    fields?: readonly Field[];

    /** For visible_group */
    tag?: Tag;
    tagId?: string;

    /** Host-defined filter surface */
    filter?: DynamicRule["filter"];

    /**
     * visible_group fallbacks:
     * - include node-scoped fallbacks for these node ids (tag.id, option.id, etc.)
     */
    visibleNodeIds?: readonly string[];

    /**
     * visible_group fallbacks:
     * - include global fallbacks for these primary ids (services in the group)
     */
    visiblePrimaries?: readonly IdType[];
}>;

function asArray<T>(v: T | readonly T[] | undefined): readonly T[] | undefined {
    if (v === undefined) return undefined;
    return Array.isArray(v) ? v : [v as any];
}

function isServiceIdRef(v: unknown): v is IdType {
    return (
        typeof v === "string" || (typeof v === "number" && Number.isFinite(v))
    );
}

function jsonStable(v: unknown): string {
    try {
        return JSON.stringify(v);
    } catch {
        return String(v);
    }
}

function eqValue(a: unknown, b: unknown): boolean {
    if (Object.is(a, b)) return true;
    return jsonStable(a) === jsonStable(b);
}

function includesValue(arr: readonly unknown[], needle: unknown): boolean {
    for (const v of arr) {
        if (eqValue(v, needle)) return true;
    }
    return false;
}

function matchesWhere(
    svc: Record<string, unknown>,
    where: readonly WhereClause[] | undefined,
): boolean {
    if (!where || where.length === 0) return true;

    const root: Record<string, unknown> = { service: svc };

    for (const clause of where) {
        const path: string = clause.path;
        const op: string = clause.op ?? "eq";
        const value: unknown = clause.value;

        const cur: unknown = getByPath(root as any, path);

        if (op === "exists") {
            if (cur === undefined || cur === null) return false;
            continue;
        }
        if (op === "truthy") {
            if (!cur) return false;
            continue;
        }
        if (op === "falsy") {
            if (cur) return false;
            continue;
        }

        if (op === "in" || op === "nin") {
            const list: unknown[] = Array.isArray(value) ? value : [];
            const hit: boolean = includesValue(list, cur);
            if (op === "in" && !hit) return false;
            if (op === "nin" && hit) return false;
            continue;
        }

        if (op === "neq") {
            if (eqValue(cur, value)) return false;
            continue;
        }

        // default "eq"
        if (!eqValue(cur, value)) return false;
    }

    return true;
}

function svcSnapshot(
    serviceMap: DgpServiceMap,
    sid: IdType,
): Record<string, unknown> {
    const svc: DgpServiceCapability | undefined = (serviceMap as any)[sid];
    if (!svc) return { id: sid };

    const meta: Record<string, unknown> =
        svc.meta && typeof svc.meta === "object" ? (svc.meta as any) : {};

    return {
        ...svc,
        id: sid,
        ...meta,
    } as unknown as Record<string, unknown>;
}

function pushItem(
    out: Map<string, ServiceItem>,
    next: Readonly<{
        tagId?: string;
        fieldId?: string;
        optionId?: string;
        nodeId?: string;
        serviceId: IdType;
        role: "base" | "utility";
        affectedIds: readonly string[];
        service: Record<string, unknown>;
    }>,
): void {
    // dedupe by (serviceId, role) to preserve role semantics
    const key: string = `${String(next.serviceId)}|${next.role}`;

    const existing: ServiceItem | undefined = out.get(key);
    if (!existing) {
        out.set(key, {
            tagId: next.tagId,
            fieldId: next.fieldId,
            optionId: next.optionId,
            nodeId: next.nodeId,
            serviceId: next.serviceId,
            role: next.role,
            service: next.service,
            affectedIds: Array.from(new Set(next.affectedIds)),
        });
        return;
    }

    const mergedIds: string[] = Array.from(
        new Set<string>([...existing.affectedIds, ...next.affectedIds]),
    );

    // Prefer preserving an existing tagId if present; otherwise use new
    out.set(key, {
        ...existing,
        tagId: existing.tagId ?? next.tagId,
        affectedIds: mergedIds,
    });
}

function fieldRoleOf(
    f: Field,
    o?: { pricing_role?: string | undefined },
): "base" | "utility" {
    const roleRaw: string | undefined =
        (o?.pricing_role as any) ?? (f.pricing_role as any) ?? "base";
    return roleRaw === "utility" ? "utility" : "base";
}

function applyFilterAllowLists(
    tagId: string | undefined,
    fieldId: string | undefined,
    filter: DynamicRule["filter"] | undefined,
): boolean {
    const tagAllow: readonly string[] | undefined = asArray(filter?.tag_id);
    const fieldAllow: readonly string[] | undefined = asArray(filter?.field_id);

    if (tagAllow) {
        if (!tagId) return false;
        if (!tagAllow.includes(tagId)) return false;
    }

    if (fieldAllow) {
        if (!fieldId) return false;
        if (!fieldAllow.includes(fieldId)) return false;
    }

    return true;
}

export function collectServiceItems(
    args: CollectServiceItemsArgs,
): ServiceItem[] {
    const filter: DynamicRule["filter"] | undefined = args.filter;
    const roleFilter: NonNullable<DynamicRule["filter"]>["role"] =
        (filter?.role as any) ?? "both";
    const where: readonly WhereClause[] | undefined = filter?.where;

    const out: Map<string, ServiceItem> = new Map<string, ServiceItem>();

    const addServiceRef = (
        ref: Readonly<{
            tagId?: string;
            fieldId?: string;
            optionId?: string;
            nodeId?: string;

            serviceId: IdType;
            role: "base" | "utility";

            affectedIds: readonly string[];
        }>,
    ): void => {
        if (roleFilter !== "both" && ref.role !== roleFilter) return;
        if (!applyFilterAllowLists(ref.tagId, ref.fieldId, filter)) return;

        const svc: DgpServiceCapability | undefined = (args.serviceMap as any)[
            ref.serviceId
        ];

        // IMPORTANT (per your 1:A): unknown services are INCLUDED; where-filter only applies when svc exists.
        if (where && svc && !matchesWhere(svc as any, where)) return;

        pushItem(out, {
            ...ref,
            service: svcSnapshot(args.serviceMap, ref.serviceId),
        });
    };

    // ────────────────────────────────────────────────────────────────
    // 1) TAG SERVICES (tag.service_id)
    // ────────────────────────────────────────────────────────────────
    if (args.mode === "global") {
        for (const t of args.tags ?? []) {
            const sid: unknown = (t as any).service_id;
            if (!isServiceIdRef(sid)) continue;

            addServiceRef({
                tagId: t.id,
                serviceId: sid,
                role: "base",
                affectedIds: [`tag:${t.id}`, `service:${String(sid)}`],
            });
        }
    } else if (args.mode === "visible_group") {
        const t: Tag | undefined = args.tag;
        const sid: unknown = t ? (t as any).service_id : undefined;

        if (t && isServiceIdRef(sid)) {
            addServiceRef({
                tagId: t.id,
                serviceId: sid,
                role: "base",
                affectedIds: [`tag:${t.id}`, `service:${String(sid)}`],
            });
        }
    }

    // ────────────────────────────────────────────────────────────────
    // 2) FIELD SERVICES (field.service_id) + OPTION SERVICES
    //    - fields can be button fields with service_id
    //    - multi-field options can map to services
    // ────────────────────────────────────────────────────────────────
    const fields: readonly Field[] = args.fields ?? [];

    for (const f of fields) {
        // field.service_id (button field)
        const fSid: unknown = (f as any).service_id;
        if (isServiceIdRef(fSid)) {
            addServiceRef({
                tagId: args.tagId,
                fieldId: f.id,
                serviceId: fSid,
                role: "base",
                affectedIds: [`field:${f.id}`, `service:${String(fSid)}`],
            });
        }

        // option services
        for (const o of f.options ?? []) {
            const oSid: unknown = (o as any).service_id;
            if (!isServiceIdRef(oSid)) continue;

            const role: "base" | "utility" = fieldRoleOf(f, o);

            addServiceRef({
                tagId: args.tagId,
                fieldId: f.id,
                optionId: o.id,
                serviceId: oSid,
                role,
                affectedIds: [
                    `field:${f.id}`,
                    `option:${o.id}`,
                    `service:${String(oSid)}`,
                ],
            });
        }
    }

    // ────────────────────────────────────────────────────────────────
    // 3) FALLBACK SERVICES (node + global)
    //    Global: include ALL fallbacks everywhere
    //    Visible group: include:
    //      - nodes fallbacks for visibleNodeIds (tag + visible option ids)
    //      - global fallbacks for visiblePrimaries (primary ids in group)
    // ────────────────────────────────────────────────────────────────
    const fb: ServiceProps["fallbacks"] | undefined = args.props.fallbacks;
    if (!fb) return Array.from(out.values());

    const includeAllFallbacks: boolean = args.mode === "global";
    const includeGroupFallbacks: boolean = args.mode === "visible_group";

    // node-scoped fallbacks
    const nodes: Record<string, IdType[] | undefined> | undefined =
        fb.nodes && typeof fb.nodes === "object"
            ? (fb.nodes as any)
            : undefined;

    if (nodes) {
        if (includeAllFallbacks) {
            for (const [nodeId, list] of Object.entries(nodes)) {
                const arr: readonly unknown[] = Array.isArray(list) ? list : [];
                for (const cand of arr) {
                    if (!isServiceIdRef(cand)) continue;

                    addServiceRef({
                        tagId: args.tagId,
                        nodeId,
                        serviceId: cand,
                        role: "base",
                        affectedIds: [
                            `fallback-node:${nodeId}`,
                            `service:${String(cand)}`,
                        ],
                    });
                }
            }
        } else if (includeGroupFallbacks) {
            const allowNodes: Set<string> = new Set<string>(
                Array.isArray(args.visibleNodeIds)
                    ? (args.visibleNodeIds as string[])
                    : [],
            );

            for (const nodeId of allowNodes) {
                const list: unknown = (nodes as any)[nodeId];
                const arr: readonly unknown[] = Array.isArray(list) ? list : [];
                for (const cand of arr) {
                    if (!isServiceIdRef(cand)) continue;

                    addServiceRef({
                        tagId: args.tagId,
                        nodeId,
                        serviceId: cand,
                        role: "base",
                        affectedIds: [
                            `fallback-node:${nodeId}`,
                            `service:${String(cand)}`,
                        ],
                    });
                }
            }
        }
    }

    // global fallbacks: primary -> candidates
    const globalFb: Record<string, IdType[] | undefined> | undefined =
        fb.global && typeof fb.global === "object"
            ? (fb.global as any)
            : undefined;

    if (globalFb) {
        if (includeAllFallbacks) {
            for (const [primaryKey, list] of Object.entries(globalFb)) {
                // Include the primary itself (object key is a service ref too)
                const primaryId: IdType = primaryKey;

                addServiceRef({
                    tagId: args.tagId,
                    nodeId: primaryKey,
                    serviceId: primaryId,
                    role: "base",
                    affectedIds: [
                        `fallback-global-primary:${primaryKey}`,
                        `service:${String(primaryId)}`,
                    ],
                });

                const arr: readonly unknown[] = Array.isArray(list) ? list : [];
                for (const cand of arr) {
                    if (!isServiceIdRef(cand)) continue;

                    addServiceRef({
                        tagId: args.tagId,
                        nodeId: primaryKey,
                        serviceId: cand,
                        role: "base",
                        affectedIds: [
                            `fallback-global:${primaryKey}`,
                            `service:${String(cand)}`,
                        ],
                    });
                }
            }
        } else if (includeGroupFallbacks) {
            const allowPrimaries: Set<string> = new Set<string>(
                (args.visiblePrimaries ?? []).map((x) => String(x)),
            );

            for (const primaryKey of allowPrimaries) {
                const list: unknown = (globalFb as any)[primaryKey];
                if (list === undefined) continue;

                const primaryId: IdType = primaryKey;

                addServiceRef({
                    tagId: args.tagId,
                    nodeId: primaryKey,
                    serviceId: primaryId,
                    role: "base",
                    affectedIds: [
                        `fallback-global-primary:${primaryKey}`,
                        `service:${String(primaryId)}`,
                    ],
                });

                const arr: readonly unknown[] = Array.isArray(list) ? list : [];
                for (const cand of arr) {
                    if (!isServiceIdRef(cand)) continue;

                    addServiceRef({
                        tagId: args.tagId,
                        nodeId: primaryKey,
                        serviceId: cand,
                        role: "base",
                        affectedIds: [
                            `fallback-global:${primaryKey}`,
                            `service:${String(cand)}`,
                        ],
                    });
                }
            }
        }
    }

    return Array.from(out.values());
}
```

---
#### 21


` File: src/core/validate/policies/ops.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/policies/ops.ts
import type { DynamicRule } from "@/schema/validation";

export function evalPolicyOp(
    op: DynamicRule["op"],
    values: unknown[],
    rule: DynamicRule,
): boolean {
    switch (op) {
        case "all_equal": {
            const set: Set<string> = new Set<string>(
                values.map((v) => JSON.stringify(v)),
            );
            return set.size <= 1;
        }
        case "no_mix": {
            const set: Set<string> = new Set<string>(
                values.map((v) => JSON.stringify(v)),
            );
            return set.size <= 1;
        }
        case "unique": {
            const seen: Set<string> = new Set<string>();
            for (const v of values) {
                const k: string = JSON.stringify(v);
                if (seen.has(k)) return false;
                seen.add(k);
            }
            return true;
        }
        case "all_true": {
            return values.every((v) => v === true);
        }
        case "any_true": {
            return values.some((v) => v === true);
        }
        case "max_count": {
            const limit: number =
                typeof rule.value === "number" ? rule.value : Infinity;
            return values.length <= limit;
        }
        case "min_count": {
            const min: number = typeof rule.value === "number" ? rule.value : 0;
            return values.length >= min;
        }
        default:
            return true;
    }
}
```

---
#### 22


` File: src/core/validate/policies/where.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/policies/where.ts
import type { WhereClause } from "../shared";
import { getByPath, includesValue, eqValue } from "../shared";

export function matchesWhere(
    svc: Record<string, unknown>,
    where: readonly WhereClause[] | undefined,
): boolean {
    if (!where || where.length === 0) return true;

    const root: Record<string, unknown> = { service: svc };

    for (const clause of where) {
        const path: string = clause.path;
        const op: string = clause.op ?? "eq";
        const value: unknown = clause.value;

        const cur: unknown = getByPath(root, path);

        if (op === "exists") {
            if (cur === undefined || cur === null) return false;
            continue;
        }
        if (op === "truthy") {
            if (!cur) return false;
            continue;
        }
        if (op === "falsy") {
            if (cur) return false;
            continue;
        }

        if (op === "in" || op === "nin") {
            const list: unknown[] = Array.isArray(value) ? value : [];
            const hit: boolean = includesValue(list, cur);
            if (op === "in" && !hit) return false;
            if (op === "nin" && hit) return false;
            continue;
        }

        if (op === "neq") {
            if (eqValue(cur, value)) return false;
            continue;
        }

        if (!eqValue(cur, value)) return false;
    }

    return true;
}
```

---
#### 23


` File: src/core/validate/shared.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/shared.ts
import type { ServiceProps, Tag, Field } from "@/schema";
import type { DgpServiceMap } from "@/schema/provider";
import type { ValidationError, ValidatorOptions } from "@/schema/validation";

export interface ValidationCtx {
    readonly props: ServiceProps;
    readonly options: ValidatorOptions;

    readonly errors: ValidationError[];

    readonly serviceMap: DgpServiceMap;
    readonly selectedKeys: Set<string>;

    readonly tags: Tag[];
    readonly fields: Field[];

    readonly tagById: Map<string, Tag>;
    readonly fieldById: Map<string, Field>;

    fieldsVisibleUnder: (tagId: string) => Field[];
}

export function isFiniteNumber(v: unknown): v is number {
    return typeof v === "number" && Number.isFinite(v);
}

export function hasAnyServiceOption(f: Field): boolean {
    return (f.options ?? []).some((o) => isFiniteNumber(o.service_id));
}

export function isBoundTo(f: Field, tagId: string): boolean {
    const b: string | string[] | undefined = f.bind_id;
    if (!b) return false;
    return Array.isArray(b) ? b.includes(tagId) : b === tagId;
}

export function getByPath(obj: unknown, path: string | undefined): unknown {
    if (!path) return undefined;

    const parts: string[] = path.split(".");
    let cur: any = obj;

    for (const p of parts) {
        if (cur == null) return undefined;
        cur = cur[p];
    }

    return cur;
}

export type WhereClause = NonNullable<
    NonNullable<import("@/schema/validation").DynamicRule["filter"]>["where"]
>[number];

export function jsonStable(v: unknown): string {
    try {
        return JSON.stringify(v);
    } catch {
        return String(v);
    }
}

export function eqValue(a: unknown, b: unknown): boolean {
    if (Object.is(a, b)) return true;
    return jsonStable(a) === jsonStable(b);
}

export function includesValue(
    arr: readonly unknown[],
    needle: unknown,
): boolean {
    for (const v of arr) {
        if (eqValue(v, needle)) return true;
    }
    return false;
}

export function serviceFlagState(
    svc: Record<string, unknown>,
    flagId: string,
): boolean | undefined {
    const flags: unknown = (svc as any).flags;
    const entry: unknown =
        flags && typeof flags === "object" ? (flags as any)[flagId] : undefined;

    const enabled: unknown =
        entry && typeof entry === "object" ? (entry as any).enabled : undefined;

    if (enabled === true) return true;
    if (enabled === false) return false;

    return undefined;
}

export function isServiceFlagEnabled(
    svc: Record<string, unknown>,
    flagId: string,
): boolean {
    return serviceFlagState(svc, flagId) === true;
}

// src/core/validate/error.ts
export function withAffected(
    details: Record<string, unknown> | undefined,
    ids: string[] | undefined,
): Record<string, unknown> | undefined {
    if (!ids || ids.length <= 1) return details;
    return { ...(details ?? {}), affectedIds: ids };
}
```

---
#### 24


` File: src/core/validate/steps/constraints.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/constraints.ts
import type { ValidationCtx } from "../shared";
import {
    isFiniteNumber,
    isServiceFlagEnabled,
    withAffected, // <-- your helper (adjust name/import if you named it differently)
} from "../shared";

type ConstraintBag = Record<string, boolean | undefined>;

function constraintKeysInChain(v: ValidationCtx, tagId: string): string[] {
    const keys: string[] = [];
    const seenKeys: Set<string> = new Set<string>();

    let cur: string | undefined = tagId;
    const seenTags: Set<string> = new Set<string>();

    while (cur && !seenTags.has(cur)) {
        seenTags.add(cur);

        const t = v.tagById.get(cur);
        const c: unknown = t?.constraints;

        if (c && typeof c === "object") {
            for (const k of Object.keys(c as any)) {
                if (!seenKeys.has(k)) {
                    seenKeys.add(k);
                    keys.push(k);
                }
            }
        }

        cur = t?.bind_id;
    }

    return keys;
}

function effectiveConstraints(v: ValidationCtx, tagId: string): ConstraintBag {
    const out: ConstraintBag = {};
    const keys: string[] = constraintKeysInChain(v, tagId);

    for (const key of keys) {
        let cur: string | undefined = tagId;
        const seen: Set<string> = new Set<string>();

        while (cur && !seen.has(cur)) {
            seen.add(cur);

            const t = v.tagById.get(cur);
            const val: unknown = (t?.constraints as any)?.[key];

            if (val === true || val === false) {
                out[key] = val;
                break;
            }

            cur = t?.bind_id;
        }
    }

    return out;
}

export function validateConstraints(v: ValidationCtx): void {
    // Enforce tag constraints on visible options' services
    for (const t of v.tags) {
        const eff: ConstraintBag = effectiveConstraints(v, t.id);
        const hasAnyRequired: boolean = Object.values(eff).some(
            (x) => x === true,
        );
        if (!hasAnyRequired) continue;

        const visible = v.fieldsVisibleUnder(t.id);

        for (const f of visible) {
            for (const o of f.options ?? []) {
                if (!isFiniteNumber(o.service_id)) continue;

                const svc: unknown = (v.serviceMap as any)[o.service_id];
                if (!svc || typeof svc !== "object") continue;

                for (const [k, val] of Object.entries(eff)) {
                    if (val === true && !isServiceFlagEnabled(svc as any, k)) {
                        v.errors.push({
                            code: "unsupported_constraint",
                            severity: "error",
                            message: `Service option "${o.id}" under tag "${t.id}" does not support required constraint "${k}".`,
                            nodeId: t.id,
                            details: withAffected(
                                {
                                    flag: k,
                                    serviceId: o.service_id,
                                    fieldId: f.id,
                                    optionId: o.id,
                                },
                                [t.id, f.id, o.id],
                            ),
                        });
                    }
                }
            }
        }
    }

    // Unsupported constraint vs tag's mapped service capabilities
    for (const t of v.tags) {
        const sid: unknown = t.service_id;
        if (!isFiniteNumber(sid)) continue;

        const svc: unknown = (v.serviceMap as any)[Number(sid)];
        if (!svc || typeof svc !== "object") continue;

        const eff: ConstraintBag = effectiveConstraints(v, t.id);

        for (const [k, val] of Object.entries(eff)) {
            if (val === true && !isServiceFlagEnabled(svc as any, k)) {
                v.errors.push({
                    code: "unsupported_constraint",
                    severity: "error",
                    message: `Tag "${t.id}" maps to service "${String(
                        sid,
                    )}" which does not support required constraint "${k}".`,
                    nodeId: t.id,
                    details: { flag: k, serviceId: sid },
                });
            }
        }
    }

    // constraint_overridden diagnostics
    for (const t of v.tags) {
        const ov: unknown = t.constraints_overrides;
        if (!ov || typeof ov !== "object") continue;

        for (const k of Object.keys(ov as Record<string, unknown>)) {
            const row: any = (ov as any)[k];
            if (!row) continue;

            const from: boolean = row.from === true;
            const to: boolean = row.to === true;
            const origin: string = String(row.origin ?? "");

            v.errors.push({
                code: "constraint_overridden",
                severity: "warning",
                message: origin
                    ? `Constraint "${k}" on tag "${t.id}" was overridden by ancestor "${origin}" (${String(from)} → ${String(
                          to,
                      )}).`
                    : `Constraint "${k}" on tag "${t.id}" was overridden by an ancestor (${String(from)} → ${String(to)}).`,
                nodeId: t.id,
                details: withAffected(
                    { flag: k, from, to, origin },
                    origin ? [t.id, origin] : undefined,
                ),
            });
        }
    }
}
```

---
#### 25


` File: src/core/validate/steps/custom.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/custom.ts
import type { ValidationCtx } from "../shared";

export function validateCustomFields(v: ValidationCtx): void {
    for (const f of v.fields) {
        if (f.type !== "custom") continue;

        if (!f.component || !String(f.component).trim()) {
            v.errors.push({
                code: "custom_component_missing",
                severity: "error",
                message: `Custom field "${f.id}" is missing a valid component reference.`,
                nodeId: f.id,
            });
        }
    }
}
```

---
#### 26


` File: src/core/validate/steps/fallbacks.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/fallbacks.ts
import type { ValidationCtx } from "../shared";
import { withAffected } from "../shared";
import { collectFailedFallbacks } from "@/core";

function codeForReason(
    reason: string,
):
    | "fallback_unknown_service"
    | "fallback_no_primary"
    | "fallback_rate_violation"
    | "fallback_constraint_mismatch"
    | "fallback_cycle"
    | "fallback_bad_node" {
    switch (reason) {
        case "unknown_service":
            return "fallback_unknown_service";
        case "no_primary":
            return "fallback_no_primary";
        case "rate_violation":
            return "fallback_rate_violation";
        case "constraint_mismatch":
            return "fallback_constraint_mismatch";
        case "cycle":
            return "fallback_cycle";
        default:
            return "fallback_bad_node";
    }
}

function messageFor(
    code:
        | "fallback_unknown_service"
        | "fallback_no_primary"
        | "fallback_rate_violation"
        | "fallback_constraint_mismatch"
        | "fallback_cycle"
        | "fallback_bad_node",
    d: {
        nodeId?: string;
        primary?: unknown;
        candidate?: unknown;
        tagContext?: unknown;
        scope?: unknown;
    },
): string {
    const n = d.nodeId ? `node "${String(d.nodeId)}"` : "node";
    switch (code) {
        case "fallback_unknown_service":
            return `Fallback candidate "${String(
                d.candidate,
            )}" is unknown for ${n}.`;
        case "fallback_no_primary":
            return `Fallback rule has no primary service for ${n}.`;
        case "fallback_rate_violation":
            return `Fallback candidate "${String(
                d.candidate,
            )}" violates the base-rate rules for ${n}.`;
        case "fallback_constraint_mismatch":
            return `Fallback candidate "${String(
                d.candidate,
            )}" does not satisfy required constraints for ${n}.`;
        case "fallback_cycle":
            return `Fallback rules contain a cycle for ${n}.`;
        default:
            return `Fallback rule is invalid for ${n}.`;
    }
}

export function validateFallbacks(v: ValidationCtx): void {
    const mode: string = v.options.fallbackSettings?.mode ?? "strict";
    if (!v.props.fallbacks) return;

    // collect non-fatal diagnostics first
    const diags = collectFailedFallbacks(v.props, v.options.serviceMap ?? {}, {
        ...v.options.fallbackSettings,
        mode: "dev",
    });

    if (mode !== "strict") return;

    for (const d of diags) {
        if (d.scope === "global") continue;

        const code = codeForReason(
            String((d as any).reason ?? "fallback_bad_node"),
        );

        const nodeId: string | undefined = (d as any).nodeId
            ? String((d as any).nodeId)
            : undefined;

        // Best-effort affected ids:
        // - Always include nodeId (if present)
        // - Include tagContext if it looks like a tag id (string)
        const tagContext: unknown = (d as any).tagContext;
        const affectedIds: string[] = [];
        if (nodeId) affectedIds.push(nodeId);
        if (
            typeof tagContext === "string" &&
            tagContext &&
            tagContext !== nodeId
        )
            affectedIds.push(tagContext);

        v.errors.push({
            code,
            severity: "error",
            message: messageFor(code, {
                nodeId,
                primary: (d as any).primary,
                candidate: (d as any).candidate,
                tagContext,
                scope: (d as any).scope,
            }),
            nodeId,
            details: withAffected(
                {
                    primary: (d as any).primary,
                    candidate: (d as any).candidate,
                    tagContext,
                    scope: (d as any).scope,
                },
                affectedIds.length > 1 ? affectedIds : undefined,
            ),
        });
    }
}
```

---
#### 27


` File: src/core/validate/steps/global-utility-guard.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/global-utility-guard.ts
import type { ValidationCtx } from "../shared";
import { isFiniteNumber } from "../shared";

export function validateGlobalUtilityGuard(v: ValidationCtx): void {
    if (!v.options.globalUtilityGuard) return;

    let hasUtility: boolean = false;
    let hasBase: boolean = false;

    for (const f of v.fields) {
        for (const o of f.options ?? []) {
            if (!isFiniteNumber(o.service_id)) continue;

            const role: string = o.pricing_role ?? f.pricing_role ?? "base";
            if (role === "base") hasBase = true;
            else if (role === "utility") hasUtility = true;

            if (hasUtility && hasBase) break;
        }

        if (hasUtility && hasBase) break;
    }

    if (hasUtility && !hasBase) {
        v.errors.push({
            code: "utility_without_base",
            severity: "warning",
            message:
                "Global utility guard: utility-priced options exist but no base-priced options were found.",
            nodeId: "global",
            details: { scope: "global" },
        });
    }
}
```

---
#### 28


` File: src/core/validate/steps/identity.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/identity.ts
import type { ValidationCtx } from "../shared";
import { hasAnyServiceOption, withAffected } from "../shared";

export function validateIdentity(v: ValidationCtx): void {
    const tags = v.tags;
    const fields = v.fields;

    // duplicate ids across tags + fields
    {
        const firstSeen: Map<string, string> = new Map<string, string>(); // id -> first kind ("tag"|"field")
        const seen: Set<string> = new Set<string>();

        for (const t of tags) {
            if (seen.has(t.id)) {
                v.errors.push({
                    code: "duplicate_id",
                    severity: "error",
                    message: `Duplicate id "${t.id}" found (tag).`,
                    nodeId: t.id,
                    // we only know the id itself; no other id to point at
                });
            } else {
                seen.add(t.id);
                firstSeen.set(t.id, "tag");
            }
        }

        for (const f of fields) {
            if (seen.has(f.id)) {
                const kind: string = firstSeen.get(f.id) ?? "tag/field";
                v.errors.push({
                    code: "duplicate_id",
                    severity: "error",
                    message: `Duplicate id "${f.id}" found (field) — already used by a ${kind}.`,
                    nodeId: f.id,
                });
            } else {
                seen.add(f.id);
                firstSeen.set(f.id, "field");
            }
        }
    }

    // tag labels unique + required
    {
        const seen: Map<string, string> = new Map<string, string>(); // label -> tagId

        for (const t of tags) {
            if (!t.label || !t.label.trim()) {
                v.errors.push({
                    code: "label_missing",
                    severity: "error",
                    message: `Tag "${t.id}" is missing a label.`,
                    nodeId: t.id,
                    details: { kind: "tag" },
                });
                continue;
            }

            const k: string = t.label;

            if (seen.has(k)) {
                const otherId: string | undefined = seen.get(k);
                v.errors.push({
                    code: "duplicate_tag_label",
                    severity: "error",
                    message: `Duplicate tag label "${k}" found on tag "${t.id}".`,
                    nodeId: t.id,
                    details: withAffected(
                        { other: otherId, label: k },
                        otherId ? [t.id, otherId] : undefined,
                    ),
                });
            } else {
                seen.set(k, t.id);
            }
        }
    }

    // field labels required; names unique among user-input fields
    {
        const seenNames: Map<string, string> = new Map<string, string>(); // name -> fieldId

        for (const f of fields) {
            if (!f.label || !f.label.trim()) {
                v.errors.push({
                    code: "label_missing",
                    severity: "error",
                    message: `Field "${f.id}" is missing a label.`,
                    nodeId: f.id,
                    details: { kind: "field" },
                });
            }

            const isUserInput: boolean = !!f.name && !hasAnyServiceOption(f);

            if (isUserInput && f.name) {
                const k: string = f.name;

                if (seenNames.has(k)) {
                    const otherId: string | undefined = seenNames.get(k);
                    v.errors.push({
                        code: "duplicate_field_name",
                        severity: "error",
                        message: `Duplicate field name "${k}" found on field "${f.id}".`,
                        nodeId: f.id,
                        details: withAffected(
                            { other: otherId, name: k },
                            otherId ? [f.id, otherId] : undefined,
                        ),
                    });
                } else {
                    seenNames.set(k, f.id);
                }
            }
        }
    }

    // option labels required
    for (const f of fields) {
        for (const o of f.options ?? []) {
            if (!o.label || !o.label.trim()) {
                v.errors.push({
                    code: "label_missing",
                    severity: "error",
                    message: `Option "${o.id}" (field "${f.id}") is missing a label.`,
                    nodeId: o.id,
                    details: { kind: "option", fieldId: f.id },
                });
            }
        }
    }
}
```

---
#### 29


` File: src/core/validate/steps/option-maps.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/option-maps.ts
import type { ValidationCtx } from "../shared";
import { withAffected } from "../shared";

type ParsedKey = { fieldId: string; optionId: string };

export function validateOptionMaps(v: ValidationCtx): void {
    const incMap: Record<string, string[]> = v.props.includes_for_buttons ?? {};
    const excMap: Record<string, string[]> = v.props.excludes_for_buttons ?? {};

    const parseKey = (key: string): ParsedKey | null => {
        const parts: string[] = key.split("::");
        const fid: string | undefined = parts[0];
        const oid: string | undefined = parts[1];
        if (!fid || !oid) return null;
        return { fieldId: fid, optionId: oid };
    };

    const hasOption = (fid: string, oid: string): boolean => {
        const f = v.fieldById.get(fid);
        if (!f) return false;
        return !!(f.options ?? []).find((o) => o.id === oid);
    };

    const badKeyMessage = (key: string): string =>
        `Invalid option-map key "${key}". Expected "fieldId::optionId" pointing to an existing option.`;

    // bad_option_key
    for (const k of Object.keys(incMap)) {
        const p = parseKey(k);
        if (!p || !hasOption(p.fieldId, p.optionId)) {
            v.errors.push({
                code: "bad_option_key",
                severity: "error",
                message: badKeyMessage(k),
                details: { key: k },
            });
        }
    }
    for (const k of Object.keys(excMap)) {
        const p = parseKey(k);
        if (!p || !hasOption(p.fieldId, p.optionId)) {
            v.errors.push({
                code: "bad_option_key",
                severity: "error",
                message: badKeyMessage(k),
                details: { key: k },
            });
        }
    }

    // option_include_exclude_conflict
    for (const k of Object.keys(incMap)) {
        if (k in excMap) {
            const p = parseKey(k);
            const affected: string[] | undefined = p
                ? [p.fieldId, p.optionId]
                : undefined;

            v.errors.push({
                code: "option_include_exclude_conflict",
                severity: "error",
                message: `Option-map key "${k}" appears in both includes_for_buttons and excludes_for_buttons.`,
                nodeId: p?.fieldId,
                details: withAffected({ key: k }, affected),
            });
        }
    }
}
```

---
#### 30


` File: src/core/validate/steps/rates.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/rates.ts
import type { ValidationCtx } from "../shared";
import { isFiniteNumber, withAffected } from "../shared";
import { isMultiField } from "@/utils";

export function validateRates(v: ValidationCtx): void {
    for (const f of v.fields) {
        if (!isMultiField(f)) continue;

        const baseRates: Set<number> = new Set<number>();
        const contributingOptionIds: Set<string> = new Set<string>();

        for (const o of f.options ?? []) {
            const role: string = o.pricing_role ?? f.pricing_role ?? "base";
            if (role !== "base") continue;

            const sid: unknown = o.service_id;
            if (!isFiniteNumber(sid)) continue;

            const rate: unknown = (v.serviceMap as any)[sid]?.rate;
            if (isFiniteNumber(rate)) {
                baseRates.add(Number(rate));
                contributingOptionIds.add(o.id);
            }
        }

        if (baseRates.size > 1) {
            const affectedIds: string[] = [
                f.id,
                ...Array.from(contributingOptionIds),
            ];

            v.errors.push({
                code: "rate_mismatch_across_base",
                severity: "error",
                message: `Base options under field "${f.id}" resolve to different service rates.`,
                nodeId: f.id,
                details: withAffected(
                    {
                        fieldId: f.id,
                        rates: Array.from(baseRates.values()),
                        optionIds: Array.from(contributingOptionIds.values()),
                    },
                    affectedIds.length > 1 ? affectedIds : undefined,
                ),
            });
        }
    }
}
```

---
#### 31


` File: src/core/validate/steps/service-vs-input.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/service-vs-input.ts
import type { ValidationCtx } from "../shared";
import { hasAnyServiceOption } from "../shared";

export function validateServiceVsUserInput(v: ValidationCtx): void {
    for (const f of v.fields) {
        const anySvc: boolean = hasAnyServiceOption(f);
        const hasName: boolean = !!(f.name && f.name.trim());

        if (f.type === "custom" && anySvc) {
            v.errors.push({
                code: "user_input_field_has_service_option",
                severity: "error",
                message: `Custom field "${f.id}" cannot map service options.`,
                nodeId: f.id,
                details: { reason: "custom_cannot_map_service" },
            });
        }

        if (!hasName) {
            // treated as service-backed → require at least one service option
            if (!anySvc) {
                v.errors.push({
                    code: "service_field_missing_service_id",
                    severity: "error",
                    message: `Service-backed field "${f.id}" has no "name" and must provide at least one option with a service_id.`,
                    nodeId: f.id,
                });
            }
        } else {
            // user-input → options must not carry service_id
            if (anySvc) {
                v.errors.push({
                    code: "user_input_field_has_service_option",
                    severity: "error",
                    message: `User-input field "${f.id}" has a name and must not include any options with service_id.`,
                    nodeId: f.id,
                });
            }
        }
    }
}
```

---
#### 32


` File: src/core/validate/steps/structure.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/structure.ts
import type { ValidationCtx } from "../shared";
import { withAffected } from "../shared";
import { isFiniteNumber } from "../shared";

export function validateStructure(v: ValidationCtx): void {
    const tags = v.tags;
    const fields = v.fields;

    // root present
    if (!tags.some((t) => t.id === "root")) {
        v.errors.push({
            code: "root_missing",
            severity: "error",
            message: 'Missing required root tag with id "root".',
        });
    }

    // cycles in tag parentage
    const visiting: Set<string> = new Set<string>();
    const visited: Set<string> = new Set<string>();

    const hasCycleFrom = (id: string): boolean => {
        if (visiting.has(id)) return true;
        if (visited.has(id)) return false;

        visiting.add(id);

        const parent: string | undefined = v.tagById.get(id)?.bind_id;
        if (parent && v.tagById.has(parent) && hasCycleFrom(parent))
            return true;

        visiting.delete(id);
        visited.add(id);
        return false;
    };

    for (const t of tags) {
        if (hasCycleFrom(t.id)) {
            v.errors.push({
                code: "cycle_in_tags",
                severity: "error",
                message: `Cycle detected in tag parentage starting at tag "${t.id}".`,
                nodeId: t.id,
                details: { tagId: t.id },
            });
            break;
        }
    }

    // tag.bind_id must point to existing tag (if present)
    for (const t of tags) {
        if (t.bind_id && !v.tagById.has(t.bind_id)) {
            v.errors.push({
                code: "bad_bind_reference",
                severity: "error",
                message: `Tag "${t.id}" binds to missing parent tag "${t.bind_id}".`,
                nodeId: t.id,
                details: withAffected({ ref: t.bind_id }, [t.id]),
            });
        }
    }

    // field.bind_id must reference tags
    for (const f of fields) {
        const b = f.bind_id;

        if (Array.isArray(b)) {
            for (const id of b) {
                if (!v.tagById.has(id)) {
                    v.errors.push({
                        code: "bad_bind_reference",
                        severity: "error",
                        message: `Field "${f.id}" binds to missing tag "${id}".`,
                        nodeId: f.id,
                        details: withAffected({ ref: id }, [f.id]),
                    });
                }
            }
        } else if (typeof b === "string") {
            if (!v.tagById.has(b)) {
                v.errors.push({
                    code: "bad_bind_reference",
                    severity: "error",
                    message: `Field "${f.id}" binds to missing tag "${b}".`,
                    nodeId: f.id,
                    details: withAffected({ ref: b }, [f.id]),
                });
            }
        }
    }

    void isFiniteNumber; // keeps parity if you had helper usage in the original file
}
```

---
#### 33


` File: src/core/validate/steps/unbound.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/unbound.ts
import type { ValidationCtx } from "../shared";
import { withAffected } from "../shared";

export function validateUnboundFields(v: ValidationCtx): void {
    const boundFieldIds: Set<string> = new Set<string>();

    for (const f of v.fields) {
        if (f.bind_id) boundFieldIds.add(f.id);
    }

    const includedByTag: Set<string> = new Set<string>();
    for (const t of v.tags) {
        for (const id of t.includes ?? []) includedByTag.add(id);
    }

    const includedByOption: Set<string> = new Set<string>();
    for (const arr of Object.values(v.props.includes_for_buttons ?? {})) {
        for (const id of arr ?? []) includedByOption.add(id);
    }

    for (const f of v.fields) {
        if (
            !boundFieldIds.has(f.id) &&
            !includedByTag.has(f.id) &&
            !includedByOption.has(f.id)
        ) {
            v.errors.push({
                code: "field_unbound",
                severity: "error",
                message: `Field "${f.id}" is unbound: it is not bound to any tag and not included by tags or option maps.`,
                nodeId: f.id,
                details: withAffected(
                    {
                        fieldId: f.id,
                        bound: false,
                        // exposing these helps editors explain "why"
                        includedByTag: includedByTag.has(f.id),
                        includedByOption: includedByOption.has(f.id),
                    },
                    [f.id],
                ),
            });
        }
    }
}
```

---
#### 34


` File: src/core/validate/steps/utility.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/utility.ts
import type { ValidationCtx } from "../shared";
import { isFiniteNumber, withAffected } from "../shared";

export function validateUtilityMarkers(v: ValidationCtx): void {
    const ALLOWED_UTILITY_MODES: Set<string> = new Set<string>([
        "flat",
        "per_quantity",
        "per_value",
        "percent",
    ]);

    // option-level
    for (const f of v.fields) {
        const optsArr = Array.isArray(f.options) ? f.options : [];
        for (const o of optsArr) {
            const role: string = o.pricing_role ?? f.pricing_role ?? "base";
            const hasService: boolean = isFiniteNumber(o.service_id);
            const util: unknown = (o.meta as any)?.utility;

            if (role === "utility" && hasService) {
                v.errors.push({
                    code: "utility_with_service_id",
                    severity: "error",
                    message: `Utility-priced option "${o.id}" (field "${f.id}") must not reference a service_id.`,
                    nodeId: o.id,
                    details: withAffected(
                        {
                            fieldId: f.id,
                            optionId: o.id,
                            service_id: o.service_id,
                        },
                        [f.id, o.id],
                    ),
                });
            }

            if (util) {
                const mode: unknown = (util as any).mode;
                const rate: unknown = (util as any).rate;

                if (!isFiniteNumber(rate)) {
                    v.errors.push({
                        code: "utility_missing_rate",
                        severity: "error",
                        message: `Utility definition for option "${o.id}" (field "${f.id}") is missing a valid rate.`,
                        nodeId: o.id,
                        details: withAffected(
                            { fieldId: f.id, optionId: o.id },
                            [f.id, o.id],
                        ),
                    });
                }

                if (!ALLOWED_UTILITY_MODES.has(String(mode))) {
                    v.errors.push({
                        code: "utility_invalid_mode",
                        severity: "error",
                        message: `Utility definition for option "${o.id}" (field "${f.id}") has invalid mode "${String(
                            mode,
                        )}".`,
                        nodeId: o.id,
                        details: withAffected(
                            { fieldId: f.id, optionId: o.id, mode },
                            [f.id, o.id],
                        ),
                    });
                }
            }
        }
    }

    // field-level
    for (const f of v.fields) {
        const util: unknown = (f.meta as any)?.utility;
        if (!util) continue;

        const mode: unknown = (util as any).mode;
        const rate: unknown = (util as any).rate;

        if (!isFiniteNumber(rate)) {
            v.errors.push({
                code: "utility_missing_rate",
                severity: "error",
                message: `Utility definition for field "${f.id}" is missing a valid rate.`,
                nodeId: f.id,
                details: withAffected({ fieldId: f.id }, [f.id]),
            });
        }

        if (!ALLOWED_UTILITY_MODES.has(String(mode))) {
            v.errors.push({
                code: "utility_invalid_mode",
                severity: "error",
                message: `Utility definition for field "${f.id}" has invalid mode "${String(
                    mode,
                )}".`,
                nodeId: f.id,
                details: withAffected({ fieldId: f.id, mode }, [f.id]),
            });
        }
    }
}
```

---
#### 35


` File: src/core/validate/steps/visibility.ts`  [↑ Back to top](#index)

```ts
// src/core/validate/steps/visibility.ts
import type { Field } from "@/schema";
import type { ValidationCtx } from "../shared";
import { isBoundTo, isFiniteNumber, withAffected } from "../shared";

export function createFieldsVisibleUnder(
    v: ValidationCtx,
): (tagId: string) => Field[] {
    return (tagId: string): Field[] => {
        const tag = v.tagById.get(tagId);
        const includesTag: Set<string> = new Set<string>(tag?.includes ?? []);
        const excludesTag: Set<string> = new Set<string>(tag?.excludes ?? []);

        const incForOpt: Record<string, string[]> =
            v.props.includes_for_buttons ?? {};
        const excForOpt: Record<string, string[]> =
            v.props.excludes_for_buttons ?? {};

        const includesOpt: Set<string> = new Set<string>();
        const excludesOpt: Set<string> = new Set<string>();

        for (const key of v.selectedKeys) {
            for (const id of incForOpt[key] ?? []) includesOpt.add(id);
            for (const id of excForOpt[key] ?? []) excludesOpt.add(id);
        }

        const merged: Map<string, Field> = new Map<string, Field>();

        for (const f of v.fields) {
            if (isBoundTo(f, tagId)) merged.set(f.id, f);
            if (includesTag.has(f.id)) merged.set(f.id, f);
            if (includesOpt.has(f.id)) merged.set(f.id, f);
        }

        for (const id of excludesTag) merged.delete(id);
        for (const id of excludesOpt) merged.delete(id);

        return Array.from(merged.values());
    };
}

export function validateVisibility(v: ValidationCtx): void {
    // duplicate visible labels (selection-aware)
    for (const t of v.tags) {
        const visible: Field[] = v.fieldsVisibleUnder(t.id);
        const seen: Map<string, string> = new Map<string, string>();

        for (const f of visible) {
            const label: string = (f.label ?? "").trim();
            if (!label) continue;

            if (seen.has(label)) {
                const otherId: string | undefined = seen.get(label);

                v.errors.push({
                    code: "duplicate_visible_label",
                    severity: "error",
                    message: `Duplicate visible label "${label}" under tag "${t.id}".`,
                    nodeId: f.id,
                    details: withAffected(
                        { tagId: t.id, other: otherId, label },
                        otherId ? [t.id, f.id, otherId] : [t.id, f.id],
                    ),
                });
            } else {
                seen.set(label, f.id);
            }
        }
    }

    // Quantity marker rule: at most one marker per visible group (tag)
    for (const t of v.tags) {
        const visible: Field[] = v.fieldsVisibleUnder(t.id);
        const markers: string[] = [];

        for (const f of visible) {
            const q: unknown = (f.meta as any)?.quantity;
            if (q) markers.push(f.id);
        }

        if (markers.length > 1) {
            v.errors.push({
                code: "quantity_multiple_markers",
                severity: "error",
                message: `Multiple quantity markers found under tag "${t.id}". Only one is allowed per visible group.`,
                nodeId: t.id,
                details: withAffected({ tagId: t.id, markers }, [
                    t.id,
                    ...markers,
                ]),
            });
        }
    }

    // utility_without_base per visible tag group (selection-aware)
    for (const t of v.tags) {
        const visible: Field[] = v.fieldsVisibleUnder(t.id);

        let hasBase: boolean = false;
        let hasUtility: boolean = false;
        const utilityOptionIds: string[] = [];

        for (const f of visible) {
            for (const o of f.options ?? []) {
                if (!isFiniteNumber(o.service_id)) continue;

                const role: string = o.pricing_role ?? f.pricing_role ?? "base";
                if (role === "base") hasBase = true;
                else if (role === "utility") {
                    hasUtility = true;
                    utilityOptionIds.push(o.id);
                }
            }
        }

        if (hasUtility && !hasBase) {
            v.errors.push({
                code: "utility_without_base",
                severity: "error",
                message: `Utility-priced options exist under tag "${t.id}" but no base-priced options were found in the same visible group.`,
                nodeId: t.id,
                details: withAffected({ tagId: t.id, utilityOptionIds }, [
                    t.id,
                    ...utilityOptionIds,
                ]),
            });
        }
    }
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.11 | 2026-01-22T02:55:14.253Z -->